#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CrabChampions

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum CrabChampions.ECrabBossPhase
// NumValues: 0x0004
enum class ECrabBossPhase : uint8
{
	PhaseOne                                 = 0,
	PhaseTwo                                 = 1,
	PhaseThree                               = 2,
	ECrabBossPhase_MAX                       = 3,
};

// Enum CrabChampions.ECrabDamageAreaType
// NumValues: 0x0007
enum class ECrabDamageAreaType : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Health                                   = 2,
	MaxHealth                                = 3,
	EnergyRing                               = 4,
	BlackHole                                = 5,
	ECrabDamageAreaType_MAX                  = 6,
};

// Enum CrabChampions.ECrabEQCType
// NumValues: 0x0005
enum class ECrabEQCType : uint8
{
	None                                     = 0,
	BestEnemyC                               = 1,
	BestEnemyCoreLoc                         = 2,
	BestFriendlyC                            = 3,
	ECrabEQCType_MAX                         = 4,
};

// Enum CrabChampions.ECrabInputDir
// NumValues: 0x0006
enum class ECrabInputDir : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Backward                                 = 2,
	Right                                    = 3,
	Left                                     = 4,
	ECrabInputDir_MAX                        = 5,
};

// Enum CrabChampions.ECrabTargetType
// NumValues: 0x0005
enum class ECrabTargetType : uint8
{
	None                                     = 0,
	CurrentLoc                               = 1,
	PredictedLoc                             = 2,
	TelegraphedLoc                           = 3,
	ECrabTargetType_MAX                      = 4,
};

// Enum CrabChampions.ECrabEnemyBuff
// NumValues: 0x0008
enum class ECrabEnemyBuff : uint8
{
	None                                     = 0,
	Angered                                  = 1,
	Frenzied                                 = 2,
	Healthy                                  = 3,
	Speedy                                   = 4,
	Shielded                                 = 5,
	Last                                     = 6,
	ECrabEnemyBuff_MAX                       = 7,
};

// Enum CrabChampions.ECrabEnemyMovementType
// NumValues: 0x0005
enum class ECrabEnemyMovementType : uint8
{
	None                                     = 0,
	MoveDirectlyToEnemy                      = 1,
	MoveToPredictedEnemyLoc                  = 2,
	MoveToRangedActionLoc                    = 3,
	ECrabEnemyMovementType_MAX               = 4,
};

// Enum CrabChampions.ECrabEnemyCategory
// NumValues: 0x0007
enum class ECrabEnemyCategory : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Elite                                    = 4,
	Boss                                     = 5,
	ECrabEnemyCategory_MAX                   = 6,
};

// Enum CrabChampions.ECrabBlessing
// NumValues: 0x0005
enum class ECrabBlessing : uint8
{
	None                                     = 0,
	Flawless                                 = 1,
	Rush                                     = 2,
	Last                                     = 3,
	ECrabBlessing_MAX                        = 4,
};

// Enum CrabChampions.ECrabChallengeModifier
// NumValues: 0x0010
enum class ECrabChallengeModifier : uint8
{
	None                                     = 0,
	OneHit                                   = 1,
	MirroredProjectiles                      = 2,
	Shrapnel                                 = 3,
	HomingThorns                             = 4,
	HomingBarrels                            = 5,
	ElementalExplosions                      = 6,
	EnergyRings                              = 7,
	SpikeStrikes                             = 8,
	ArmoredEnemies                           = 9,
	SpeedyEnemies                            = 10,
	ExplosiveEnemies                         = 11,
	XL                                       = 12,
	BarrelRain                               = 13,
	Last                                     = 14,
	ECrabChallengeModifier_MAX               = 15,
};

// Enum CrabChampions.ECrabIslandType
// NumValues: 0x0014
enum class ECrabIslandType : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	NewRun                                   = 2,
	ContinueRun                              = 3,
	Arena                                    = 4,
	Horde                                    = 5,
	Waves                                    = 6,
	Harvest                                  = 7,
	Demolition                               = 8,
	Parkour                                  = 9,
	Shop                                     = 10,
	Elite                                    = 11,
	Boss                                     = 12,
	Biome                                    = 13,
	CrabIsland                               = 14,
	Loop                                     = 15,
	Arcade                                   = 16,
	Holdout                                  = 17,
	Duel                                     = 18,
	ECrabIslandType_MAX                      = 19,
};

// Enum CrabChampions.ECrabRank
// NumValues: 0x0009
enum class ECrabRank : uint8
{
	None                                     = 0,
	Bronze                                   = 1,
	Silver                                   = 2,
	Gold                                     = 3,
	Sapphire                                 = 4,
	Emerald                                  = 5,
	Ruby                                     = 6,
	Diamond                                  = 7,
	ECrabRank_MAX                            = 8,
};

// Enum CrabChampions.ECrabDifficultyModifier
// NumValues: 0x000E
enum class ECrabDifficultyModifier : uint8
{
	StrategicEnemies                         = 0,
	RegeneratingEnemies                      = 1,
	LockedSlots                              = 2,
	BuffedEnemies                            = 3,
	ResurrectingEnemies                      = 4,
	ExpensiveShops                           = 5,
	DoubleChallenge                          = 6,
	EvolvedEnemies                           = 7,
	UnfairBosses                             = 8,
	EternalPunishment                        = 9,
	LimitedHeals                             = 10,
	NoSafetyNet                              = 11,
	Last                                     = 12,
	ECrabDifficultyModifier_MAX              = 13,
};

// Enum CrabChampions.ECrabDifficulty
// NumValues: 0x0005
enum class ECrabDifficulty : uint8
{
	Easy                                     = 0,
	Normal                                   = 1,
	Nightmare                                = 2,
	UltraChaos                               = 3,
	ECrabDifficulty_MAX                      = 4,
};

// Enum CrabChampions.ECrabTotemType
// NumValues: 0x0013
enum class ECrabTotemType : uint8
{
	None                                     = 0,
	Cosmetics                                = 1,
	Difficulty                               = 2,
	Key                                      = 3,
	Multiplayer                              = 4,
	Reroll                                   = 5,
	Health                                   = 6,
	Crystal                                  = 7,
	Loot                                     = 8,
	Gold                                     = 9,
	Glass                                    = 10,
	Fuse                                     = 11,
	Greed                                    = 12,
	Chance                                   = 13,
	Gamble                                   = 14,
	Enhancement                              = 15,
	Random                                   = 16,
	Contract                                 = 17,
	ECrabTotemType_MAX                       = 18,
};

// Enum CrabChampions.ECrabConsumableType
// NumValues: 0x0007
enum class ECrabConsumableType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	Health                                   = 2,
	MaxHealth                                = 3,
	Crystal                                  = 4,
	Key                                      = 5,
	ECrabConsumableType_MAX                  = 6,
};

// Enum CrabChampions.ECrabRelicType
// NumValues: 0x002D
enum class ECrabRelicType : uint8
{
	None                                     = 0,
	RingOfHealing                            = 1,
	RingOfArmor                              = 2,
	RingOfParrying                           = 3,
	RingOfDestruction                        = 4,
	AncientBlade                             = 5,
	PortalRing                               = 6,
	RingOfRevolution                         = 7,
	RingOfReloading                          = 8,
	WisdomRing                               = 9,
	CoralAmulet                              = 10,
	RubyDice                                 = 11,
	TonysRing                                = 12,
	ComboRing                                = 13,
	TonysAmulet                              = 14,
	RingOfValue                              = 15,
	EtherealArmor                            = 16,
	RingOfDefense                            = 17,
	RingOfDeflection                         = 18,
	RingOfRepulsion                          = 19,
	RingOfPower                              = 20,
	RingOfPrecision                          = 21,
	IceRing                                  = 22,
	FireRing                                 = 23,
	LightningRing                            = 24,
	PoisonRing                               = 25,
	ChaoticRing                              = 26,
	ElementalRing                            = 27,
	AmmoRing                                 = 28,
	RingOfGravity                            = 29,
	RingOfRocketJumping                      = 30,
	SkillRing                                = 31,
	DuplicationRing                          = 32,
	RingOfProtection                         = 33,
	RingOfSwiftness                          = 34,
	RingOfLuck                               = 35,
	RecursiveRing                            = 36,
	GoldenArc                                = 37,
	PortalAmulet                             = 38,
	AbilityRing                              = 39,
	GoldRing                                 = 40,
	TonysCrown                               = 41,
	CursedRing                               = 42,
	RushedRing                               = 43,
	ECrabRelicType_MAX                       = 44,
};

// Enum CrabChampions.ECrabPerkType
// NumValues: 0x0092
enum class ECrabPerkType : uint8
{
	None                                     = 0,
	Fortitude                                = 1,
	ValuedCustomer                           = 2,
	PersonalSpace                            = 3,
	Bullseye                                 = 4,
	BigHearts                                = 5,
	Endurance                                = 6,
	HealthyCombo                             = 7,
	Vampire                                  = 8,
	NourishingSalvage                        = 9,
	Regenerator                              = 10,
	AmberResin                               = 11,
	HardTarget                               = 12,
	Scavenger                                = 13,
	Vitality                                 = 14,
	SecondWind                               = 15,
	DamageCombo                              = 16,
	FMJ                                      = 17,
	IceCube                                  = 18,
	OilCan                                   = 19,
	MetalRod                                 = 20,
	PoisonVial                               = 21,
	Sharpshooter                             = 22,
	HotShot                                  = 23,
	PowerPunch                               = 24,
	CriticalThinking                         = 25,
	CriticalArrow                            = 26,
	ChainReaction                            = 27,
	Efficiency                               = 28,
	Autoloader                               = 29,
	RiggedTotems                             = 30,
	SturdyTotems                             = 31,
	SonicBoom                                = 32,
	RedFury                                  = 33,
	Adrenaline                               = 34,
	SpecialDelivery                          = 35,
	TonysBlackCard                           = 36,
	BigClaws                                 = 37,
	SharpClaws                               = 38,
	IronClaws                                = 39,
	Blender                                  = 40,
	DangerClose                              = 41,
	EagleEye                                 = 42,
	PowerArmor                               = 43,
	Equalizer                                = 44,
	SpeedDemon                               = 45,
	Stamina                                  = 46,
	Slugger                                  = 47,
	ExplosiveArmor                           = 48,
	FlammableArmor                           = 49,
	CrystalCombo                             = 50,
	Snatcher                                 = 51,
	FinishingMove                            = 52,
	GoldCoating                              = 53,
	Paycheck                                 = 54,
	CrystalDividends                         = 55,
	Frostbite                                = 56,
	BubblingAcid                             = 57,
	Icebreaker                               = 58,
	HotSteam                                 = 59,
	IceCold                                  = 60,
	Firestarter                              = 61,
	HighVoltage                              = 62,
	Toxic                                    = 63,
	PotentMagic                              = 64,
	CrystalFertilizer                        = 65,
	Driller                                  = 66,
	EnhancedTurrets                          = 67,
	TurboTurrets                             = 68,
	TurretFriendship                         = 69,
	DamageAura                               = 70,
	IceAura                                  = 71,
	FireAura                                 = 72,
	LightningAura                            = 73,
	PoisonAura                               = 74,
	OrbitingScythes                          = 75,
	CrimsonHaze                              = 76,
	IceClaws                                 = 77,
	FireClaws                                = 78,
	Shockwave                                = 79,
	GrimReaper                               = 80,
	GraveDodger                              = 81,
	Bulletproof                              = 82,
	TastyOrange                              = 83,
	Checklist                                = 84,
	Assassin                                 = 85,
	Gemstone                                 = 86,
	Collector                                = 87,
	MoneyIsPower                             = 88,
	MegaCrit                                 = 89,
	CriticalBlast                            = 90,
	AllYouCanEat                             = 91,
	StreamerLoot                             = 92,
	BigChests                                = 93,
	PerformanceBonus                         = 94,
	DoubleVision                             = 95,
	BonusCrystals                            = 96,
	Reinforced                               = 97,
	SentryTurret                             = 98,
	SniperTurret                             = 99,
	RareTreasure                             = 100,
	ExplodingEnemies                         = 101,
	FreezingEnemies                          = 102,
	FlammableEnemies                         = 103,
	ElectricEnemies                          = 104,
	PoisonousEnemies                         = 105,
	GoldDice                                 = 106,
	FaultyChests                             = 107,
	CrystalAsteroids                         = 108,
	BonusChests                              = 109,
	CarePackage                              = 110,
	LevelUp                                  = 111,
	RegeneratingArmor                        = 112,
	DivineBlessing                           = 113,
	CriticalLightning                        = 114,
	IceDash                                  = 115,
	DaggerDash                               = 116,
	Powerslide                               = 117,
	StormCloud                               = 118,
	FireTurret                               = 119,
	PoisonTurret                             = 120,
	MortarTurret                             = 121,
	LeapOfFaith                              = 122,
	Bribe                                    = 123,
	DoubleTrouble                            = 124,
	HeavyArmor                               = 125,
	Juggernaut                               = 126,
	BigBones                                 = 127,
	GlassCannon                              = 128,
	DamageSeeker                             = 129,
	BruteForce                               = 130,
	ThinkFast                                = 131,
	MetalClaw                                = 132,
	UpTheAnte                                = 133,
	Brawler                                  = 134,
	Untouchable                              = 135,
	CursedLottery                            = 136,
	SlipperySlope                            = 137,
	DoubleEdgedSword                         = 138,
	Workaholic                               = 139,
	RisingStar                               = 140,
	LimitedLoot                              = 141,
	FlashSale                                = 142,
	HighRoller                               = 143,
	Hoarder                                  = 144,
	ECrabPerkType_MAX                        = 145,
};

// Enum CrabChampions.ECrabGrenadeModType
// NumValues: 0x0036
enum class ECrabGrenadeModType : uint8
{
	None                                     = 0,
	BouncingGrenade                          = 1,
	SpiralGrenade                            = 2,
	SnakeGrenade                             = 3,
	LightGrenade                             = 4,
	GlueGrenade                              = 5,
	ChaoticGrenade                           = 6,
	HeavyGrenade                             = 7,
	BigGrenade                               = 8,
	ImplodingGrenade                         = 9,
	IronGrenade                              = 10,
	TimeGrenade                              = 11,
	BiggerBoom                               = 12,
	EarthquakeGrenade                        = 13,
	ConfusionExplosion                       = 14,
	WeakExplosion                            = 15,
	SlowExplosion                            = 16,
	DamageGrenade                            = 17,
	RapidGrenade                             = 18,
	StackedGrenade                           = 19,
	CloneGrenade                             = 20,
	TripleGrenade                            = 21,
	LayeredGrenade                           = 22,
	SplitGrenade                             = 23,
	ScatterGrenade                           = 24,
	AuraGrenade                              = 25,
	BubbleBlast                              = 26,
	DaggerBlast                              = 27,
	FireworkExplosion                        = 28,
	ThornExplosion                           = 29,
	SparkExplosion                           = 30,
	ShrapnelExplosion                        = 31,
	BarrelExplosion                          = 32,
	ElementalExplosion                       = 33,
	GiantDrill                               = 34,
	ArtilleryStrike                          = 35,
	Grenadier                                = 36,
	HomingGrenade                            = 37,
	CloneExplosion                           = 38,
	BombExplosion                            = 39,
	SpinningBlade                            = 40,
	SporeExplosion                           = 41,
	UltraMushroom                            = 42,
	ScytheVortex                             = 43,
	CrystalBarrage                           = 44,
	EnergyRing                               = 45,
	BlackHole                                = 46,
	IceExplosion                             = 47,
	FireExplosion                            = 48,
	LightningExplosion                       = 49,
	PoisonExplosion                          = 50,
	SpikeStrike                              = 51,
	CrystalStrike                            = 52,
	ECrabGrenadeModType_MAX                  = 53,
};

// Enum CrabChampions.ECrabWeaponModType
// NumValues: 0x0058
enum class ECrabWeaponModType : uint8
{
	None                                     = 0,
	BouncingShot                             = 1,
	AcceleratingShot                         = 2,
	ZigZagShot                               = 3,
	SpiralShot                               = 4,
	SnakeShot                                = 5,
	ChaoticShot                              = 6,
	BoomerangShot                            = 7,
	OrbitingShot                             = 8,
	RecoilShot                               = 9,
	FastShot                                 = 10,
	HealthShot                               = 11,
	BigMag                                   = 12,
	HighCaliber                              = 13,
	WindUp                                   = 14,
	SteadyShot                               = 15,
	TrickShot                                = 16,
	AerialShot                               = 17,
	GripTape                                 = 18,
	BlindFire                                = 19,
	MoneyShot                                = 20,
	TimeShot                                 = 21,
	TimeBolt                                 = 22,
	UltraShot                                = 23,
	SharpShot                                = 24,
	GlueShot                                 = 25,
	BigShot                                  = 26,
	StreakShot                               = 27,
	MagShot                                  = 28,
	Uppercut                                 = 29,
	HeavyShot                                = 30,
	HeavyHitter                              = 31,
	RapidFire                                = 32,
	LightShot                                = 33,
	EscalatingShot                           = 34,
	IceShot                                  = 35,
	FireShot                                 = 36,
	LightningShot                            = 37,
	PoisonShot                               = 38,
	ArcaneShot                               = 39,
	RandomShot                               = 40,
	ReloadArc                                = 41,
	TripleShot                               = 42,
	ArcShot                                  = 43,
	SplitShot                                = 44,
	ScatterShot                              = 45,
	TargetingShot                            = 46,
	LinkShot                                 = 47,
	DrillShot                                = 48,
	DamageShot                               = 49,
	Supercharged                             = 50,
	Juiced                                   = 51,
	AuraShot                                 = 52,
	PiercingShot                             = 53,
	BubbleShot                               = 54,
	DaggerArc                                = 55,
	PiercingWave                             = 56,
	ArcaneBlast                              = 57,
	ShotgunBlast                             = 58,
	MaceShot                                 = 59,
	FireworkShot                             = 60,
	ThornShot                                = 61,
	SparkShot                                = 62,
	Firepower                                = 63,
	XShot                                    = 64,
	SquareShot                               = 65,
	HomingShot                               = 66,
	DoubleTap                                = 67,
	SplashDamage                             = 68,
	ProximityBarrage                         = 69,
	HomingBlades                             = 70,
	BombShot                                 = 71,
	LandmineShot                             = 72,
	TorpedoShot                              = 73,
	FireballShot                             = 74,
	SharpenedAxe                             = 75,
	TriangleShot                             = 76,
	SporeShot                                = 77,
	IceStorm                                 = 78,
	FireStorm                                = 79,
	LightningStorm                           = 80,
	PoisonStorm                              = 81,
	IceStrike                                = 82,
	FireStrike                               = 83,
	LightningStrike                          = 84,
	PoisonStrike                             = 85,
	SpikeStrike                              = 86,
	ECrabWeaponModType_MAX                   = 87,
};

// Enum CrabChampions.ECrabCurrencyType
// NumValues: 0x0004
enum class ECrabCurrencyType : uint8
{
	Crystal                                  = 0,
	Key                                      = 1,
	Health                                   = 2,
	ECrabCurrencyType_MAX                    = 3,
};

// Enum CrabChampions.ECrabEnhancementType
// NumValues: 0x000F
enum class ECrabEnhancementType : uint8
{
	None                                     = 0,
	Spiraling                                = 1,
	Snaking                                  = 2,
	Chaotic                                  = 3,
	Sticky                                   = 4,
	Freezing                                 = 5,
	Flaming                                  = 6,
	Electrifying                             = 7,
	Toxifying                                = 8,
	Damaging                                 = 9,
	Splitting                                = 10,
	Scattering                               = 11,
	Homing                                   = 12,
	Last                                     = 13,
	ECrabEnhancementType_MAX                 = 14,
};

// Enum CrabChampions.ECrabPickupTag
// NumValues: 0x000A
enum class ECrabPickupTag : uint8
{
	None                                     = 0,
	Critical                                 = 1,
	Bounce                                   = 2,
	Ice                                      = 3,
	Fire                                     = 4,
	Lightning                                = 5,
	Poison                                   = 6,
	Arcane                                   = 7,
	Turret                                   = 8,
	ECrabPickupTag_MAX                       = 9,
};

// Enum CrabChampions.ECrabRarity
// NumValues: 0x0006
enum class ECrabRarity : uint8
{
	None                                     = 0,
	Rare                                     = 1,
	Epic                                     = 2,
	Legendary                                = 3,
	Greed                                    = 4,
	ECrabRarity_MAX                          = 5,
};

// Enum CrabChampions.ECrabLootPool
// NumValues: 0x0014
enum class ECrabLootPool : uint8
{
	None                                     = 0,
	Damage                                   = 1,
	Critical                                 = 2,
	Elemental                                = 3,
	Speed                                    = 4,
	Luck                                     = 5,
	Health                                   = 6,
	Economy                                  = 7,
	Skill                                    = 8,
	Greed                                    = 9,
	Upgrade                                  = 10,
	Random                                   = 11,
	RelicChest                               = 12,
	SpikedChest                              = 13,
	EpicChest                                = 14,
	LegendaryChest                           = 15,
	HealingChest                             = 16,
	KeyChest                                 = 17,
	Lesser                                   = 18,
	ECrabLootPool_MAX                        = 19,
};

// Enum CrabChampions.ECrabPickupType
// NumValues: 0x000B
enum class ECrabPickupType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Ability                                  = 2,
	Melee                                    = 3,
	WeaponMod                                = 4,
	GrenadeMod                               = 5,
	Perk                                     = 6,
	Relic                                    = 7,
	Consumable                               = 8,
	Random                                   = 9,
	ECrabPickupType_MAX                      = 10,
};

// Enum CrabChampions.ECrabLesserProjectileType
// NumValues: 0x0023
enum class ECrabLesserProjectileType : uint8
{
	None                                     = 0,
	Generic                                  = 1,
	Duplicate                                = 2,
	TimeBolt                                 = 3,
	UltraShot                                = 4,
	ReloadArc                                = 5,
	LinkShot                                 = 6,
	DrillShot                                = 7,
	BubbleShot                               = 8,
	DaggerArc                                = 9,
	PiercingWave                             = 10,
	ArcaneBlast                              = 11,
	ShotgunBlast                             = 12,
	MaceShot                                 = 13,
	FireworkShot                             = 14,
	ThornShot                                = 15,
	SparkShot                                = 16,
	ProximityBarrage                         = 17,
	HomingBlade                              = 18,
	BombShot                                 = 19,
	TorpedoShot                              = 20,
	FireballShot                             = 21,
	SharpenedAxe                             = 22,
	TriangleShot                             = 23,
	BubbleBlast                              = 24,
	DaggerBlast                              = 25,
	FireworkExplosion                        = 26,
	ThornExplosion                           = 27,
	SparkExplosion                           = 28,
	CloneExplosion                           = 29,
	BombExplosion                            = 30,
	SpinningBlade                            = 31,
	OrbitingScythe                           = 32,
	DaggerDash                               = 33,
	ECrabLesserProjectileType_MAX            = 34,
};

// Enum CrabChampions.ECrabFormationType
// NumValues: 0x0019
enum class ECrabFormationType : uint8
{
	Single                                   = 0,
	Double                                   = 1,
	Triple                                   = 2,
	Quad                                     = 3,
	SmallCluster                             = 4,
	MediumCluster                            = 5,
	LargeCluster                             = 6,
	SmallArc                                 = 7,
	LargeArc                                 = 8,
	LargeArcTightSpread                      = 9,
	TripleArc                                = 10,
	Box                                      = 11,
	Triangle                                 = 12,
	X                                        = 13,
	Square                                   = 14,
	LargeSquare                              = 15,
	Circle                                   = 16,
	LargeCircle                              = 17,
	Line                                     = 18,
	Cross                                    = 19,
	Ring                                     = 20,
	MediumRing                               = 21,
	LargeRing                                = 22,
	Random                                   = 23,
	ECrabFormationType_MAX                   = 24,
};

// Enum CrabChampions.ECrabHitmarkerType
// NumValues: 0x0004
enum class ECrabHitmarkerType : uint8
{
	Quiet                                    = 0,
	Normal                                   = 1,
	Loud                                     = 2,
	ECrabHitmarkerType_MAX                   = 3,
};

// Enum CrabChampions.ECrabCrosshairType
// NumValues: 0x0006
enum class ECrabCrosshairType : uint8
{
	None                                     = 0,
	Cross                                    = 1,
	HalfCross                                = 2,
	Circle                                   = 3,
	SniperScope                              = 4,
	ECrabCrosshairType_MAX                   = 5,
};

// Enum CrabChampions.ECrabDamageHitType
// NumValues: 0x0007
enum class ECrabDamageHitType : uint8
{
	None                                     = 0,
	Armor                                    = 1,
	ArmorBreak                               = 2,
	Health                                   = 3,
	Crit                                     = 4,
	Elimination                              = 5,
	ECrabDamageHitType_MAX                   = 6,
};

// Enum CrabChampions.ECrabDebuffType
// NumValues: 0x000B
enum class ECrabDebuffType : uint8
{
	None                                     = 0,
	Confusion                                = 1,
	Weak                                     = 2,
	Slow                                     = 3,
	Ice                                      = 4,
	Fire                                     = 5,
	Lightning                                = 6,
	Poison                                   = 7,
	Arcane                                   = 8,
	Last                                     = 9,
	ECrabDebuffType_MAX                      = 10,
};

// Enum CrabChampions.ECrabDamageType
// NumValues: 0x000D
enum class ECrabDamageType : uint8
{
	None                                     = 0,
	Radial                                   = 1,
	Ability                                  = 2,
	Melee                                    = 3,
	Lesser                                   = 4,
	Knockback                                = 5,
	DOT                                      = 6,
	Fire                                     = 7,
	Lightning                                = 8,
	Arcane                                   = 9,
	Hazard                                   = 10,
	Unblockable                              = 11,
	ECrabDamageType_MAX                      = 12,
};

// Enum CrabChampions.ECrabSpawnPointType
// NumValues: 0x000A
enum class ECrabSpawnPointType : uint8
{
	Player                                   = 0,
	Turret                                   = 1,
	Destructible                             = 2,
	Totem                                    = 3,
	Secret                                   = 4,
	Enemy                                    = 5,
	Reward                                   = 6,
	Portal                                   = 7,
	Shop                                     = 8,
	ECrabSpawnPointType_MAX                  = 9,
};

// Enum CrabChampions.ECrabBiome
// NumValues: 0x0006
enum class ECrabBiome : uint8
{
	None                                     = 0,
	Tropical                                 = 1,
	Arctic                                   = 2,
	Desert                                   = 3,
	Volcanic                                 = 4,
	ECrabBiome_MAX                           = 5,
};

// Enum CrabChampions.ECrabMatchState
// NumValues: 0x0009
enum class ECrabMatchState : uint8
{
	None                                     = 0,
	WaitingToStart                           = 1,
	PortalCountdown                          = 2,
	StartedIsland                            = 3,
	ClearedIsland                            = 4,
	AllPlayersEliminated                     = 5,
	GameOver                                 = 6,
	Restarting                               = 7,
	ECrabMatchState_MAX                      = 8,
};

// Enum CrabChampions.ECrabCosmeticType
// NumValues: 0x0003
enum class ECrabCosmeticType : uint8
{
	CrabSkin                                 = 0,
	WeaponSkin                               = 1,
	ECrabCosmeticType_MAX                    = 2,
};

// Enum CrabChampions.ECrabProjectileState
// NumValues: 0x0005
enum class ECrabProjectileState : uint8
{
	None                                     = 0,
	Pooled                                   = 1,
	Active                                   = 2,
	Exploded                                 = 3,
	ECrabProjectileState_MAX                 = 4,
};

// Enum CrabChampions.ECrabFireMode
// NumValues: 0x0003
enum class ECrabFireMode : uint8
{
	Automatic                                = 0,
	Burst                                    = 1,
	ECrabFireMode_MAX                        = 2,
};

// Enum CrabChampions.ECrabConfirmationPromptType
// NumValues: 0x0005
enum class ECrabConfirmationPromptType : uint8
{
	None                                     = 0,
	QuitToLobby                              = 1,
	BringPartyMembersToLobby                 = 2,
	QuitToDesktop                            = 3,
	ECrabConfirmationPromptType_MAX          = 4,
};

// Enum CrabChampions.ECrabBlockingHitState
// NumValues: 0x0003
enum class ECrabBlockingHitState : uint8
{
	Deflected                                = 0,
	Aborted                                  = 1,
	ECrabBlockingHitState_MAX                = 2,
};

// ScriptStruct CrabChampions.CrabCosmetic
// 0x0028 (0x0028 - 0x0000)
struct FCrabCosmetic final
{
public:
	ECrabCosmeticType                             CosmeticType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C1[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmeticName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CosmeticIcon;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CosmeticObject;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabCosmetic) == 0x000008, "Wrong alignment on FCrabCosmetic");
static_assert(sizeof(FCrabCosmetic) == 0x000028, "Wrong size on FCrabCosmetic");
static_assert(offsetof(FCrabCosmetic, CosmeticType) == 0x000000, "Member 'FCrabCosmetic::CosmeticType' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticName) == 0x000008, "Member 'FCrabCosmetic::CosmeticName' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticIcon) == 0x000018, "Member 'FCrabCosmetic::CosmeticIcon' has a wrong offset!");
static_assert(offsetof(FCrabCosmetic, CosmeticObject) == 0x000020, "Member 'FCrabCosmetic::CosmeticObject' has a wrong offset!");

// ScriptStruct CrabChampions.CrabProjectileInfo
// 0x0030 (0x0030 - 0x0000)
struct FCrabProjectileInfo final
{
public:
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Dir;                                               // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C2[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 OwningC;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLesserProjectileType                     LesserProjectileType;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C3[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorToMoveIgnore;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabProjectileInfo) == 0x000008, "Wrong alignment on FCrabProjectileInfo");
static_assert(sizeof(FCrabProjectileInfo) == 0x000030, "Wrong size on FCrabProjectileInfo");
static_assert(offsetof(FCrabProjectileInfo, ProjectileDA) == 0x000000, "Member 'FCrabProjectileInfo::ProjectileDA' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, Dir) == 0x000008, "Member 'FCrabProjectileInfo::Dir' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, OwningC) == 0x000018, "Member 'FCrabProjectileInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, LesserProjectileType) == 0x000020, "Member 'FCrabProjectileInfo::LesserProjectileType' has a wrong offset!");
static_assert(offsetof(FCrabProjectileInfo, ActorToMoveIgnore) == 0x000028, "Member 'FCrabProjectileInfo::ActorToMoveIgnore' has a wrong offset!");

// ScriptStruct CrabChampions.ClientAuthoritativeMoveData
// 0x0050 (0x0050 - 0x0000)
struct FClientAuthoritativeMoveData final
{
public:
	struct FVector_NetQuantize10                  Location;                                          // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Velocity;                                          // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation;                                   // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         MovementMode;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C4[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    BasedMovementBase;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BasedMovementBaseBoneName;                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBasedHasRelativeRotation;                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C5[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientAuthoritativeMoveData) == 0x000008, "Wrong alignment on FClientAuthoritativeMoveData");
static_assert(sizeof(FClientAuthoritativeMoveData) == 0x000050, "Wrong size on FClientAuthoritativeMoveData");
static_assert(offsetof(FClientAuthoritativeMoveData, Location) == 0x000000, "Member 'FClientAuthoritativeMoveData::Location' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, Rotation) == 0x00000C, "Member 'FClientAuthoritativeMoveData::Rotation' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, Velocity) == 0x000018, "Member 'FClientAuthoritativeMoveData::Velocity' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, ControlRotation) == 0x000024, "Member 'FClientAuthoritativeMoveData::ControlRotation' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, MovementMode) == 0x000030, "Member 'FClientAuthoritativeMoveData::MovementMode' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, BasedMovementBase) == 0x000038, "Member 'FClientAuthoritativeMoveData::BasedMovementBase' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, BasedMovementBaseBoneName) == 0x000040, "Member 'FClientAuthoritativeMoveData::BasedMovementBaseBoneName' has a wrong offset!");
static_assert(offsetof(FClientAuthoritativeMoveData, bBasedHasRelativeRotation) == 0x000048, "Member 'FClientAuthoritativeMoveData::bBasedHasRelativeRotation' has a wrong offset!");

// ScriptStruct CrabChampions.CrabEnemySpawnSettings
// 0x0028 (0x0028 - 0x0000)
struct FCrabEnemySpawnSettings final
{
public:
	int32                                         IslandToStartSpawningAt;                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySpawnIfLooping;                               // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C6[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabIslandType>                       BannedIslandTypes;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsEvolvedEnemy;                                   // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExplosiveEnemy;                                 // 0x0019(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C7[0x2];                                     // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnCost;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnLimit;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabEnemySpawnSettings) == 0x000008, "Wrong alignment on FCrabEnemySpawnSettings");
static_assert(sizeof(FCrabEnemySpawnSettings) == 0x000028, "Wrong size on FCrabEnemySpawnSettings");
static_assert(offsetof(FCrabEnemySpawnSettings, IslandToStartSpawningAt) == 0x000000, "Member 'FCrabEnemySpawnSettings::IslandToStartSpawningAt' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bOnlySpawnIfLooping) == 0x000004, "Member 'FCrabEnemySpawnSettings::bOnlySpawnIfLooping' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, BannedIslandTypes) == 0x000008, "Member 'FCrabEnemySpawnSettings::BannedIslandTypes' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bIsEvolvedEnemy) == 0x000018, "Member 'FCrabEnemySpawnSettings::bIsEvolvedEnemy' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, bIsExplosiveEnemy) == 0x000019, "Member 'FCrabEnemySpawnSettings::bIsExplosiveEnemy' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnCost) == 0x00001C, "Member 'FCrabEnemySpawnSettings::SpawnCost' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnWeight) == 0x000020, "Member 'FCrabEnemySpawnSettings::SpawnWeight' has a wrong offset!");
static_assert(offsetof(FCrabEnemySpawnSettings, SpawnLimit) == 0x000024, "Member 'FCrabEnemySpawnSettings::SpawnLimit' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPickupsSpawnInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabPickupsSpawnInfo final
{
public:
	TArray<class UCrabPickupDA*>                  PickupsToSpawn;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        SpawnLocs;                                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPickupsSpawnInfo) == 0x000008, "Wrong alignment on FCrabPickupsSpawnInfo");
static_assert(sizeof(FCrabPickupsSpawnInfo) == 0x000020, "Wrong size on FCrabPickupsSpawnInfo");
static_assert(offsetof(FCrabPickupsSpawnInfo, PickupsToSpawn) == 0x000000, "Member 'FCrabPickupsSpawnInfo::PickupsToSpawn' has a wrong offset!");
static_assert(offsetof(FCrabPickupsSpawnInfo, SpawnLocs) == 0x000010, "Member 'FCrabPickupsSpawnInfo::SpawnLocs' has a wrong offset!");

// ScriptStruct CrabChampions.CrabLobbyStats
// 0x0058 (0x0058 - 0x0000)
struct FCrabLobbyStats final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Difficulty;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighScore;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Attempts;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Wins;                                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreak;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighestIslandReached;                              // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCompletedChallenges;                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedWeapons;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedAbilities;                              // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedMeleeWeapons;                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedWeaponMods;                             // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedGrenadeMods;                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedPerks;                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUnlockedRelics;                                 // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C8[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabLobbyStats) == 0x000008, "Wrong alignment on FCrabLobbyStats");
static_assert(sizeof(FCrabLobbyStats) == 0x000058, "Wrong size on FCrabLobbyStats");
static_assert(offsetof(FCrabLobbyStats, PlayerName) == 0x000000, "Member 'FCrabLobbyStats::PlayerName' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Difficulty) == 0x000010, "Member 'FCrabLobbyStats::Difficulty' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, HighScore) == 0x000020, "Member 'FCrabLobbyStats::HighScore' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Attempts) == 0x000024, "Member 'FCrabLobbyStats::Attempts' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, Wins) == 0x000028, "Member 'FCrabLobbyStats::Wins' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, WinStreak) == 0x00002C, "Member 'FCrabLobbyStats::WinStreak' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, HighestIslandReached) == 0x000030, "Member 'FCrabLobbyStats::HighestIslandReached' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumCompletedChallenges) == 0x000034, "Member 'FCrabLobbyStats::NumCompletedChallenges' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedWeapons) == 0x000038, "Member 'FCrabLobbyStats::NumUnlockedWeapons' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedAbilities) == 0x00003C, "Member 'FCrabLobbyStats::NumUnlockedAbilities' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedMeleeWeapons) == 0x000040, "Member 'FCrabLobbyStats::NumUnlockedMeleeWeapons' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedWeaponMods) == 0x000044, "Member 'FCrabLobbyStats::NumUnlockedWeaponMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedGrenadeMods) == 0x000048, "Member 'FCrabLobbyStats::NumUnlockedGrenadeMods' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedPerks) == 0x00004C, "Member 'FCrabLobbyStats::NumUnlockedPerks' has a wrong offset!");
static_assert(offsetof(FCrabLobbyStats, NumUnlockedRelics) == 0x000050, "Member 'FCrabLobbyStats::NumUnlockedRelics' has a wrong offset!");

// ScriptStruct CrabChampions.CrabHealthInfo
// 0x001C (0x001C - 0x0000)
struct FCrabHealthInfo final
{
public:
	int32                                         CurrentArmorPlates;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentArmorPlateHealth;                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousArmorPlateHealth;                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHealth;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMaxHealth;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousHealth;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousMaxHealth;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabHealthInfo) == 0x000004, "Wrong alignment on FCrabHealthInfo");
static_assert(sizeof(FCrabHealthInfo) == 0x00001C, "Wrong size on FCrabHealthInfo");
static_assert(offsetof(FCrabHealthInfo, CurrentArmorPlates) == 0x000000, "Member 'FCrabHealthInfo::CurrentArmorPlates' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentArmorPlateHealth) == 0x000004, "Member 'FCrabHealthInfo::CurrentArmorPlateHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousArmorPlateHealth) == 0x000008, "Member 'FCrabHealthInfo::PreviousArmorPlateHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentHealth) == 0x00000C, "Member 'FCrabHealthInfo::CurrentHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, CurrentMaxHealth) == 0x000010, "Member 'FCrabHealthInfo::CurrentMaxHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousHealth) == 0x000014, "Member 'FCrabHealthInfo::PreviousHealth' has a wrong offset!");
static_assert(offsetof(FCrabHealthInfo, PreviousMaxHealth) == 0x000018, "Member 'FCrabHealthInfo::PreviousMaxHealth' has a wrong offset!");

// ScriptStruct CrabChampions.CrabInventoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabInventoryInfo final
{
public:
	uint8                                         Level;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C9[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabEnhancementType>                  Enhancements;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AccumulatedBuff;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CA[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabInventoryInfo) == 0x000008, "Wrong alignment on FCrabInventoryInfo");
static_assert(sizeof(FCrabInventoryInfo) == 0x000020, "Wrong size on FCrabInventoryInfo");
static_assert(offsetof(FCrabInventoryInfo, Level) == 0x000000, "Member 'FCrabInventoryInfo::Level' has a wrong offset!");
static_assert(offsetof(FCrabInventoryInfo, Enhancements) == 0x000008, "Member 'FCrabInventoryInfo::Enhancements' has a wrong offset!");
static_assert(offsetof(FCrabInventoryInfo, AccumulatedBuff) == 0x000018, "Member 'FCrabInventoryInfo::AccumulatedBuff' has a wrong offset!");

// ScriptStruct CrabChampions.CrabWeaponMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabWeaponMod final
{
public:
	class UCrabWeaponModDA*                       WeaponModDA;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabWeaponMod) == 0x000008, "Wrong alignment on FCrabWeaponMod");
static_assert(sizeof(FCrabWeaponMod) == 0x000028, "Wrong size on FCrabWeaponMod");
static_assert(offsetof(FCrabWeaponMod, WeaponModDA) == 0x000000, "Member 'FCrabWeaponMod::WeaponModDA' has a wrong offset!");
static_assert(offsetof(FCrabWeaponMod, InventoryInfo) == 0x000008, "Member 'FCrabWeaponMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabChallenge
// 0x0050 (0x0050 - 0x0000)
struct FCrabChallenge final
{
public:
	class FName                                   ChallengeID;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChallengeDescription;                              // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeProgress;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeGoal;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChallengeCompleted;                               // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CB[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabCosmetic                          CosmeticReward;                                    // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabChallenge) == 0x000008, "Wrong alignment on FCrabChallenge");
static_assert(sizeof(FCrabChallenge) == 0x000050, "Wrong size on FCrabChallenge");
static_assert(offsetof(FCrabChallenge, ChallengeID) == 0x000000, "Member 'FCrabChallenge::ChallengeID' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeDescription) == 0x000008, "Member 'FCrabChallenge::ChallengeDescription' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeProgress) == 0x000018, "Member 'FCrabChallenge::ChallengeProgress' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, ChallengeGoal) == 0x00001C, "Member 'FCrabChallenge::ChallengeGoal' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, bChallengeCompleted) == 0x000020, "Member 'FCrabChallenge::bChallengeCompleted' has a wrong offset!");
static_assert(offsetof(FCrabChallenge, CosmeticReward) == 0x000028, "Member 'FCrabChallenge::CosmeticReward' has a wrong offset!");

// ScriptStruct CrabChampions.CrabNextIslandInfo
// 0x0030 (0x0030 - 0x0000)
struct FCrabNextIslandInfo final
{
public:
	ECrabBiome                                    Biome;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CC[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIsland;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IslandName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabIslandType                               IslandType;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CD[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECrabBlessing                                 Blessing;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 RewardLootPool;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CE[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabNextIslandInfo) == 0x000008, "Wrong alignment on FCrabNextIslandInfo");
static_assert(sizeof(FCrabNextIslandInfo) == 0x000030, "Wrong size on FCrabNextIslandInfo");
static_assert(offsetof(FCrabNextIslandInfo, Biome) == 0x000000, "Member 'FCrabNextIslandInfo::Biome' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, CurrentIsland) == 0x000004, "Member 'FCrabNextIslandInfo::CurrentIsland' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, IslandName) == 0x000008, "Member 'FCrabNextIslandInfo::IslandName' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, IslandType) == 0x000010, "Member 'FCrabNextIslandInfo::IslandType' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, ChallengeModifiers) == 0x000018, "Member 'FCrabNextIslandInfo::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, Blessing) == 0x000028, "Member 'FCrabNextIslandInfo::Blessing' has a wrong offset!");
static_assert(offsetof(FCrabNextIslandInfo, RewardLootPool) == 0x000029, "Member 'FCrabNextIslandInfo::RewardLootPool' has a wrong offset!");

// ScriptStruct CrabChampions.CrabGrenadeMod
// 0x0028 (0x0028 - 0x0000)
struct FCrabGrenadeMod final
{
public:
	class UCrabGrenadeModDA*                      GrenadeModDA;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabGrenadeMod) == 0x000008, "Wrong alignment on FCrabGrenadeMod");
static_assert(sizeof(FCrabGrenadeMod) == 0x000028, "Wrong size on FCrabGrenadeMod");
static_assert(offsetof(FCrabGrenadeMod, GrenadeModDA) == 0x000000, "Member 'FCrabGrenadeMod::GrenadeModDA' has a wrong offset!");
static_assert(offsetof(FCrabGrenadeMod, InventoryInfo) == 0x000008, "Member 'FCrabGrenadeMod::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPerk
// 0x0028 (0x0028 - 0x0000)
struct FCrabPerk final
{
public:
	class UCrabPerkDA*                            PerkDA;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPerk) == 0x000008, "Wrong alignment on FCrabPerk");
static_assert(sizeof(FCrabPerk) == 0x000028, "Wrong size on FCrabPerk");
static_assert(offsetof(FCrabPerk, PerkDA) == 0x000000, "Member 'FCrabPerk::PerkDA' has a wrong offset!");
static_assert(offsetof(FCrabPerk, InventoryInfo) == 0x000008, "Member 'FCrabPerk::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabRelic
// 0x0028 (0x0028 - 0x0000)
struct FCrabRelic final
{
public:
	class UCrabRelicDA*                           RelicDA;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabRelic) == 0x000008, "Wrong alignment on FCrabRelic");
static_assert(sizeof(FCrabRelic) == 0x000028, "Wrong size on FCrabRelic");
static_assert(offsetof(FCrabRelic, RelicDA) == 0x000000, "Member 'FCrabRelic::RelicDA' has a wrong offset!");
static_assert(offsetof(FCrabRelic, InventoryInfo) == 0x000008, "Member 'FCrabRelic::InventoryInfo' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAutoSave
// 0x0130 (0x0130 - 0x0000)
struct FCrabAutoSave final
{
public:
	int32                                         CurrentTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDifficulty                               Difficulty;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13CF[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCrabNextIslandInfo                    NextIslandInfo;                                    // 0x0018(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         Points;                                            // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboCounter;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Combo;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Eliminations;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsFired;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DamageDealt;                                       // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        HighestDamageDealt;                                // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageTaken;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFlawlessIslands;                                // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x006C(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxHealthMultiplier;                               // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMultiplier;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D0[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumWeaponModSlots;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D1[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumGrenadeModSlots;                                // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D2[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabGrenadeMod>                GrenadeMods;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         NumPerkSlots;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D3[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabPerk>                      Perks;                                             // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabRelic>                     Relics;                                            // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NumTimesSalvaged;                                  // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShopPurchases;                                  // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumShopRerolls;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTotemsDestroyed;                                // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Crystals;                                          // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTimeTaken;                                    // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAutoSave) == 0x000008, "Wrong alignment on FCrabAutoSave");
static_assert(sizeof(FCrabAutoSave) == 0x000130, "Wrong size on FCrabAutoSave");
static_assert(offsetof(FCrabAutoSave, CurrentTime) == 0x000000, "Member 'FCrabAutoSave::CurrentTime' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Difficulty) == 0x000004, "Member 'FCrabAutoSave::Difficulty' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DifficultyModifiers) == 0x000008, "Member 'FCrabAutoSave::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NextIslandInfo) == 0x000018, "Member 'FCrabAutoSave::NextIslandInfo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Points) == 0x000048, "Member 'FCrabAutoSave::Points' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ComboCounter) == 0x00004C, "Member 'FCrabAutoSave::ComboCounter' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Combo) == 0x000050, "Member 'FCrabAutoSave::Combo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Eliminations) == 0x000054, "Member 'FCrabAutoSave::Eliminations' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ShotsFired) == 0x000058, "Member 'FCrabAutoSave::ShotsFired' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageDealt) == 0x00005C, "Member 'FCrabAutoSave::DamageDealt' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, HighestDamageDealt) == 0x000060, "Member 'FCrabAutoSave::HighestDamageDealt' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageTaken) == 0x000064, "Member 'FCrabAutoSave::DamageTaken' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumFlawlessIslands) == 0x000068, "Member 'FCrabAutoSave::NumFlawlessIslands' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, HealthInfo) == 0x00006C, "Member 'FCrabAutoSave::HealthInfo' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MaxHealthMultiplier) == 0x000088, "Member 'FCrabAutoSave::MaxHealthMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, DamageMultiplier) == 0x00008C, "Member 'FCrabAutoSave::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, ScaleMultiplier) == 0x000090, "Member 'FCrabAutoSave::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, WeaponDA) == 0x000098, "Member 'FCrabAutoSave::WeaponDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, AbilityDA) == 0x0000A0, "Member 'FCrabAutoSave::AbilityDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, MeleeDA) == 0x0000A8, "Member 'FCrabAutoSave::MeleeDA' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumWeaponModSlots) == 0x0000B0, "Member 'FCrabAutoSave::NumWeaponModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, WeaponMods) == 0x0000B8, "Member 'FCrabAutoSave::WeaponMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumGrenadeModSlots) == 0x0000C8, "Member 'FCrabAutoSave::NumGrenadeModSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, GrenadeMods) == 0x0000D0, "Member 'FCrabAutoSave::GrenadeMods' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumPerkSlots) == 0x0000E0, "Member 'FCrabAutoSave::NumPerkSlots' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Perks) == 0x0000E8, "Member 'FCrabAutoSave::Perks' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Relics) == 0x0000F8, "Member 'FCrabAutoSave::Relics' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumTimesSalvaged) == 0x000108, "Member 'FCrabAutoSave::NumTimesSalvaged' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumShopPurchases) == 0x00010C, "Member 'FCrabAutoSave::NumShopPurchases' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumShopRerolls) == 0x000110, "Member 'FCrabAutoSave::NumShopRerolls' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, NumTotemsDestroyed) == 0x000114, "Member 'FCrabAutoSave::NumTotemsDestroyed' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, Crystals) == 0x000118, "Member 'FCrabAutoSave::Crystals' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, TotalTimeTaken) == 0x00011C, "Member 'FCrabAutoSave::TotalTimeTaken' has a wrong offset!");
static_assert(offsetof(FCrabAutoSave, CompletedChallenges) == 0x000120, "Member 'FCrabAutoSave::CompletedChallenges' has a wrong offset!");

// ScriptStruct CrabChampions.CrabEnemyStats
// 0x0010 (0x0010 - 0x0000)
struct FCrabEnemyStats final
{
public:
	float                                         HealthMultiplier;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedMultiplier;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionSpeedMultiplier;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMultiplier;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabEnemyStats) == 0x000004, "Wrong alignment on FCrabEnemyStats");
static_assert(sizeof(FCrabEnemyStats) == 0x000010, "Wrong size on FCrabEnemyStats");
static_assert(offsetof(FCrabEnemyStats, HealthMultiplier) == 0x000000, "Member 'FCrabEnemyStats::HealthMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, MovementSpeedMultiplier) == 0x000004, "Member 'FCrabEnemyStats::MovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, ActionSpeedMultiplier) == 0x000008, "Member 'FCrabEnemyStats::ActionSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabEnemyStats, DamageMultiplier) == 0x00000C, "Member 'FCrabEnemyStats::DamageMultiplier' has a wrong offset!");

// ScriptStruct CrabChampions.CrabAISettings
// 0x0028 (0x0028 - 0x0000)
struct FCrabAISettings final
{
public:
	ECrabEnemyMovementType                        MovementType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D4[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenMoves;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpProbability;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashProbability;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActionsMin;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActionsMax;                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEnvQuery*>                      RangedActionEnvQueries;                            // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabAISettings) == 0x000008, "Wrong alignment on FCrabAISettings");
static_assert(sizeof(FCrabAISettings) == 0x000028, "Wrong size on FCrabAISettings");
static_assert(offsetof(FCrabAISettings, MovementType) == 0x000000, "Member 'FCrabAISettings::MovementType' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenMoves) == 0x000004, "Member 'FCrabAISettings::TimeBetweenMoves' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, JumpProbability) == 0x000008, "Member 'FCrabAISettings::JumpProbability' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, DashProbability) == 0x00000C, "Member 'FCrabAISettings::DashProbability' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenActionsMin) == 0x000010, "Member 'FCrabAISettings::TimeBetweenActionsMin' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, TimeBetweenActionsMax) == 0x000014, "Member 'FCrabAISettings::TimeBetweenActionsMax' has a wrong offset!");
static_assert(offsetof(FCrabAISettings, RangedActionEnvQueries) == 0x000018, "Member 'FCrabAISettings::RangedActionEnvQueries' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPortalInfo
// 0x0020 (0x0020 - 0x0000)
struct FCrabPortalInfo final
{
public:
	bool                                          bIsInited;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECrabBlessing                                 Blessing;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 RewardLootPool;                                    // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D6[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabPortalInfo) == 0x000008, "Wrong alignment on FCrabPortalInfo");
static_assert(sizeof(FCrabPortalInfo) == 0x000020, "Wrong size on FCrabPortalInfo");
static_assert(offsetof(FCrabPortalInfo, bIsInited) == 0x000000, "Member 'FCrabPortalInfo::bIsInited' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, ChallengeModifiers) == 0x000008, "Member 'FCrabPortalInfo::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, Blessing) == 0x000018, "Member 'FCrabPortalInfo::Blessing' has a wrong offset!");
static_assert(offsetof(FCrabPortalInfo, RewardLootPool) == 0x000019, "Member 'FCrabPortalInfo::RewardLootPool' has a wrong offset!");

// ScriptStruct CrabChampions.CrabIsland
// 0x000C (0x000C - 0x0000)
struct FCrabIsland final
{
public:
	class FName                                   IslandName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnWeight;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabIsland) == 0x000004, "Wrong alignment on FCrabIsland");
static_assert(sizeof(FCrabIsland) == 0x00000C, "Wrong size on FCrabIsland");
static_assert(offsetof(FCrabIsland, IslandName) == 0x000000, "Member 'FCrabIsland::IslandName' has a wrong offset!");
static_assert(offsetof(FCrabIsland, SpawnWeight) == 0x000008, "Member 'FCrabIsland::SpawnWeight' has a wrong offset!");

// ScriptStruct CrabChampions.CrabRankedWeapon
// 0x0010 (0x0010 - 0x0000)
struct FCrabRankedWeapon final
{
public:
	class UCrabPickupDA*                          Weapon;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabRank                                     Rank;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D7[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabRankedWeapon) == 0x000008, "Wrong alignment on FCrabRankedWeapon");
static_assert(sizeof(FCrabRankedWeapon) == 0x000010, "Wrong size on FCrabRankedWeapon");
static_assert(offsetof(FCrabRankedWeapon, Weapon) == 0x000000, "Member 'FCrabRankedWeapon::Weapon' has a wrong offset!");
static_assert(offsetof(FCrabRankedWeapon, Rank) == 0x000008, "Member 'FCrabRankedWeapon::Rank' has a wrong offset!");

// ScriptStruct CrabChampions.CrabInventoryCooldown
// 0x0010 (0x0010 - 0x0000)
struct FCrabInventoryCooldown final
{
public:
	class UCrabInventoryDA*                       InventoryDA;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentCooldown;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D8[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabInventoryCooldown) == 0x000008, "Wrong alignment on FCrabInventoryCooldown");
static_assert(sizeof(FCrabInventoryCooldown) == 0x000010, "Wrong size on FCrabInventoryCooldown");
static_assert(offsetof(FCrabInventoryCooldown, InventoryDA) == 0x000000, "Member 'FCrabInventoryCooldown::InventoryDA' has a wrong offset!");
static_assert(offsetof(FCrabInventoryCooldown, CurrentCooldown) == 0x000008, "Member 'FCrabInventoryCooldown::CurrentCooldown' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPedestalInfo
// 0x000C (0x000C - 0x0000)
struct FCrabPedestalInfo final
{
public:
	ECrabCurrencyType                             CurrencyType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D9[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabPedestalInfo) == 0x000004, "Wrong alignment on FCrabPedestalInfo");
static_assert(sizeof(FCrabPedestalInfo) == 0x00000C, "Wrong size on FCrabPedestalInfo");
static_assert(offsetof(FCrabPedestalInfo, CurrencyType) == 0x000000, "Member 'FCrabPedestalInfo::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCrabPedestalInfo, Cost) == 0x000004, "Member 'FCrabPedestalInfo::Cost' has a wrong offset!");
static_assert(offsetof(FCrabPedestalInfo, DiscountPercentage) == 0x000008, "Member 'FCrabPedestalInfo::DiscountPercentage' has a wrong offset!");

// ScriptStruct CrabChampions.CrabPickupInfo
// 0x0058 (0x0058 - 0x0000)
struct FCrabPickupInfo final
{
public:
	struct FVector_NetQuantize                    CosmeticSpawnLoc;                                  // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DA[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabPickupDA*                          PickupDA;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         MaxPickups;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabCurrencyType                             CurrencyType;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DB[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SalvageReward;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DC[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabPS*                                OwningPS;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLocationUI;                                   // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoLootPickup;                                 // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DD[0x6];                                     // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabPickupInfo) == 0x000008, "Wrong alignment on FCrabPickupInfo");
static_assert(sizeof(FCrabPickupInfo) == 0x000058, "Wrong size on FCrabPickupInfo");
static_assert(offsetof(FCrabPickupInfo, CosmeticSpawnLoc) == 0x000000, "Member 'FCrabPickupInfo::CosmeticSpawnLoc' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, PickupDA) == 0x000010, "Member 'FCrabPickupInfo::PickupDA' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, InventoryInfo) == 0x000018, "Member 'FCrabPickupInfo::InventoryInfo' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, MaxPickups) == 0x000038, "Member 'FCrabPickupInfo::MaxPickups' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, CurrencyType) == 0x000039, "Member 'FCrabPickupInfo::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, Cost) == 0x00003C, "Member 'FCrabPickupInfo::Cost' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, SalvageReward) == 0x000040, "Member 'FCrabPickupInfo::SalvageReward' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, OwningPS) == 0x000048, "Member 'FCrabPickupInfo::OwningPS' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, bShowLocationUI) == 0x000050, "Member 'FCrabPickupInfo::bShowLocationUI' has a wrong offset!");
static_assert(offsetof(FCrabPickupInfo, bIsAutoLootPickup) == 0x000051, "Member 'FCrabPickupInfo::bIsAutoLootPickup' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDebuffState
// 0x0020 (0x0020 - 0x0000)
struct FCrabDebuffState final
{
public:
	int32                                         ConfusionStack;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeakStack;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlowStack;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceStack;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireStack;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningStack;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoisonStack;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneStack;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDebuffState) == 0x000004, "Wrong alignment on FCrabDebuffState");
static_assert(sizeof(FCrabDebuffState) == 0x000020, "Wrong size on FCrabDebuffState");
static_assert(offsetof(FCrabDebuffState, ConfusionStack) == 0x000000, "Member 'FCrabDebuffState::ConfusionStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, WeakStack) == 0x000004, "Member 'FCrabDebuffState::WeakStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, SlowStack) == 0x000008, "Member 'FCrabDebuffState::SlowStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, IceStack) == 0x00000C, "Member 'FCrabDebuffState::IceStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, FireStack) == 0x000010, "Member 'FCrabDebuffState::FireStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, LightningStack) == 0x000014, "Member 'FCrabDebuffState::LightningStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, PoisonStack) == 0x000018, "Member 'FCrabDebuffState::PoisonStack' has a wrong offset!");
static_assert(offsetof(FCrabDebuffState, ArcaneStack) == 0x00001C, "Member 'FCrabDebuffState::ArcaneStack' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDebuff
// 0x0008 (0x0008 - 0x0000)
struct FCrabDebuff final
{
public:
	ECrabDebuffType                               DebuffType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DE[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebuffStack;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDebuff) == 0x000004, "Wrong alignment on FCrabDebuff");
static_assert(sizeof(FCrabDebuff) == 0x000008, "Wrong size on FCrabDebuff");
static_assert(offsetof(FCrabDebuff, DebuffType) == 0x000000, "Member 'FCrabDebuff::DebuffType' has a wrong offset!");
static_assert(offsetof(FCrabDebuff, DebuffStack) == 0x000004, "Member 'FCrabDebuff::DebuffStack' has a wrong offset!");

// ScriptStruct CrabChampions.CrabDamageInfo
// 0x0038 (0x0038 - 0x0000)
struct FCrabDamageInfo final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrit;                                             // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDOT;                                              // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDamageType                               CrabDamageType;                                    // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13DF[0x1];                                     // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabDebuff>                    Debuffs;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageLoc;                                         // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackStrength;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 DamagingC;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabDamageInfo) == 0x000008, "Wrong alignment on FCrabDamageInfo");
static_assert(sizeof(FCrabDamageInfo) == 0x000038, "Wrong size on FCrabDamageInfo");
static_assert(offsetof(FCrabDamageInfo, DamagedActor) == 0x000000, "Member 'FCrabDamageInfo::DamagedActor' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, Damage) == 0x000008, "Member 'FCrabDamageInfo::Damage' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, bCrit) == 0x00000C, "Member 'FCrabDamageInfo::bCrit' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, bDOT) == 0x00000D, "Member 'FCrabDamageInfo::bDOT' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, CrabDamageType) == 0x00000E, "Member 'FCrabDamageInfo::CrabDamageType' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, Debuffs) == 0x000010, "Member 'FCrabDamageInfo::Debuffs' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamageLoc) == 0x000020, "Member 'FCrabDamageInfo::DamageLoc' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, KnockbackStrength) == 0x00002C, "Member 'FCrabDamageInfo::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(FCrabDamageInfo, DamagingC) == 0x000030, "Member 'FCrabDamageInfo::DamagingC' has a wrong offset!");

// ScriptStruct CrabChampions.CrabExplosionFX
// 0x0048 (0x0048 - 0x0000)
struct FCrabExplosionFX final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E0[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Sound;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabExplosionFX) == 0x000008, "Wrong alignment on FCrabExplosionFX");
static_assert(sizeof(FCrabExplosionFX) == 0x000048, "Wrong size on FCrabExplosionFX");
static_assert(offsetof(FCrabExplosionFX, Loc) == 0x000000, "Member 'FCrabExplosionFX::Loc' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, ImpactNormal) == 0x00000C, "Member 'FCrabExplosionFX::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Radius) == 0x000018, "Member 'FCrabExplosionFX::Radius' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, FX) == 0x000020, "Member 'FCrabExplosionFX::FX' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Tint) == 0x000028, "Member 'FCrabExplosionFX::Tint' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, Sound) == 0x000038, "Member 'FCrabExplosionFX::Sound' has a wrong offset!");
static_assert(offsetof(FCrabExplosionFX, CameraShake) == 0x000040, "Member 'FCrabExplosionFX::CameraShake' has a wrong offset!");

// ScriptStruct CrabChampions.CrabVideoSettings
// 0x0110 (0x0110 - 0x0000)
struct FCrabVideoSettings final
{
public:
	class FString                                 DisplayMode;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Resolution;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResolutionQuality;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FPSLimit;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VSync;                                             // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldOfView;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GraphicsQuality;                                   // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponEffects;                                     // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AntiAliasingType;                                  // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sharpening;                                        // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MotionBlur;                                        // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShake;                                       // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hitmarkers;                                        // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageNumbers;                                     // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextChatVisibility;                                // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShowFPS;                                           // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PauseWhenLosingFocus;                              // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabVideoSettings) == 0x000008, "Wrong alignment on FCrabVideoSettings");
static_assert(sizeof(FCrabVideoSettings) == 0x000110, "Wrong size on FCrabVideoSettings");
static_assert(offsetof(FCrabVideoSettings, DisplayMode) == 0x000000, "Member 'FCrabVideoSettings::DisplayMode' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Resolution) == 0x000010, "Member 'FCrabVideoSettings::Resolution' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, ResolutionQuality) == 0x000020, "Member 'FCrabVideoSettings::ResolutionQuality' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, FPSLimit) == 0x000030, "Member 'FCrabVideoSettings::FPSLimit' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, VSync) == 0x000040, "Member 'FCrabVideoSettings::VSync' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, FieldOfView) == 0x000050, "Member 'FCrabVideoSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, GraphicsQuality) == 0x000060, "Member 'FCrabVideoSettings::GraphicsQuality' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, WeaponEffects) == 0x000070, "Member 'FCrabVideoSettings::WeaponEffects' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, AntiAliasingType) == 0x000080, "Member 'FCrabVideoSettings::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Sharpening) == 0x000090, "Member 'FCrabVideoSettings::Sharpening' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, MotionBlur) == 0x0000A0, "Member 'FCrabVideoSettings::MotionBlur' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, CameraShake) == 0x0000B0, "Member 'FCrabVideoSettings::CameraShake' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, Hitmarkers) == 0x0000C0, "Member 'FCrabVideoSettings::Hitmarkers' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, DamageNumbers) == 0x0000D0, "Member 'FCrabVideoSettings::DamageNumbers' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, TextChatVisibility) == 0x0000E0, "Member 'FCrabVideoSettings::TextChatVisibility' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, ShowFPS) == 0x0000F0, "Member 'FCrabVideoSettings::ShowFPS' has a wrong offset!");
static_assert(offsetof(FCrabVideoSettings, PauseWhenLosingFocus) == 0x000100, "Member 'FCrabVideoSettings::PauseWhenLosingFocus' has a wrong offset!");

// ScriptStruct CrabChampions.CrabKeyBind
// 0x0070 (0x0070 - 0x0000)
struct FCrabKeyBind final
{
public:
	class FName                                   MappingName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyBindTitle;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAxisMapping;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E1[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   KeyboardKey;                                       // 0x0020(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyboardKeyFriendlyName;                           // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ControllerKey;                                     // 0x0048(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ControllerIcon;                                    // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeRemapped;                                    // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E2[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabKeyBind) == 0x000008, "Wrong alignment on FCrabKeyBind");
static_assert(sizeof(FCrabKeyBind) == 0x000070, "Wrong size on FCrabKeyBind");
static_assert(offsetof(FCrabKeyBind, MappingName) == 0x000000, "Member 'FCrabKeyBind::MappingName' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyBindTitle) == 0x000008, "Member 'FCrabKeyBind::KeyBindTitle' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, bAxisMapping) == 0x000018, "Member 'FCrabKeyBind::bAxisMapping' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyboardKey) == 0x000020, "Member 'FCrabKeyBind::KeyboardKey' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, KeyboardKeyFriendlyName) == 0x000038, "Member 'FCrabKeyBind::KeyboardKeyFriendlyName' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, ControllerKey) == 0x000048, "Member 'FCrabKeyBind::ControllerKey' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, ControllerIcon) == 0x000060, "Member 'FCrabKeyBind::ControllerIcon' has a wrong offset!");
static_assert(offsetof(FCrabKeyBind, bCanBeRemapped) == 0x000068, "Member 'FCrabKeyBind::bCanBeRemapped' has a wrong offset!");

// ScriptStruct CrabChampions.CrabProjectileModInfo
// 0x0024 (0x0024 - 0x0000)
struct FCrabProjectileModInfo final
{
public:
	float                                         DamageMultiplier;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlatDamageBonus;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifetimeMultiplier;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeMultiplier;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationBonus;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityMultiplier;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingMultiplier;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBounces;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabProjectileModInfo) == 0x000004, "Wrong alignment on FCrabProjectileModInfo");
static_assert(sizeof(FCrabProjectileModInfo) == 0x000024, "Wrong size on FCrabProjectileModInfo");
static_assert(offsetof(FCrabProjectileModInfo, DamageMultiplier) == 0x000000, "Member 'FCrabProjectileModInfo::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, FlatDamageBonus) == 0x000004, "Member 'FCrabProjectileModInfo::FlatDamageBonus' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, LifetimeMultiplier) == 0x000008, "Member 'FCrabProjectileModInfo::LifetimeMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, SizeMultiplier) == 0x00000C, "Member 'FCrabProjectileModInfo::SizeMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, SpeedMultiplier) == 0x000010, "Member 'FCrabProjectileModInfo::SpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, AccelerationBonus) == 0x000014, "Member 'FCrabProjectileModInfo::AccelerationBonus' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, GravityMultiplier) == 0x000018, "Member 'FCrabProjectileModInfo::GravityMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, HomingMultiplier) == 0x00001C, "Member 'FCrabProjectileModInfo::HomingMultiplier' has a wrong offset!");
static_assert(offsetof(FCrabProjectileModInfo, NumBounces) == 0x000020, "Member 'FCrabProjectileModInfo::NumBounces' has a wrong offset!");

// ScriptStruct CrabChampions.CrabWeaponInfo
// 0x0018 (0x0018 - 0x0000)
struct FCrabWeaponInfo final
{
public:
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 OwningC;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDualWieldWeapon;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E3[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrabWeaponInfo) == 0x000008, "Wrong alignment on FCrabWeaponInfo");
static_assert(sizeof(FCrabWeaponInfo) == 0x000018, "Wrong size on FCrabWeaponInfo");
static_assert(offsetof(FCrabWeaponInfo, WeaponDA) == 0x000000, "Member 'FCrabWeaponInfo::WeaponDA' has a wrong offset!");
static_assert(offsetof(FCrabWeaponInfo, OwningC) == 0x000008, "Member 'FCrabWeaponInfo::OwningC' has a wrong offset!");
static_assert(offsetof(FCrabWeaponInfo, bIsDualWieldWeapon) == 0x000010, "Member 'FCrabWeaponInfo::bIsDualWieldWeapon' has a wrong offset!");

// ScriptStruct CrabChampions.CrabLightingPreset
// 0x00A0 (0x00A0 - 0x0000)
struct FCrabLightingPreset final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E4[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SkydomeMI;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkydomeRotation;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLHeight;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLRotation;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLIntensity;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DLTint;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SLIntensity;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SLTint;                                            // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SLHemisphereTint;                                  // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SLMinOcclusion;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SLOcclusionTint;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PPTemperature;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFDensity;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFHeightFalloff;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HFTint;                                            // 0x0068(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFStartDistance;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E5[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OceanMI;                                           // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnderwaterPPTint;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabBiomeDA*                           BiomeDA;                                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrabLightingPreset) == 0x000008, "Wrong alignment on FCrabLightingPreset");
static_assert(sizeof(FCrabLightingPreset) == 0x0000A0, "Wrong size on FCrabLightingPreset");
static_assert(offsetof(FCrabLightingPreset, Weight) == 0x000000, "Member 'FCrabLightingPreset::Weight' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SkydomeMI) == 0x000008, "Member 'FCrabLightingPreset::SkydomeMI' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SkydomeRotation) == 0x000010, "Member 'FCrabLightingPreset::SkydomeRotation' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLHeight) == 0x000014, "Member 'FCrabLightingPreset::DLHeight' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLRotation) == 0x000018, "Member 'FCrabLightingPreset::DLRotation' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLIntensity) == 0x00001C, "Member 'FCrabLightingPreset::DLIntensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, DLTint) == 0x000020, "Member 'FCrabLightingPreset::DLTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLIntensity) == 0x000030, "Member 'FCrabLightingPreset::SLIntensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLTint) == 0x000034, "Member 'FCrabLightingPreset::SLTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLHemisphereTint) == 0x000044, "Member 'FCrabLightingPreset::SLHemisphereTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLMinOcclusion) == 0x000054, "Member 'FCrabLightingPreset::SLMinOcclusion' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, SLOcclusionTint) == 0x000058, "Member 'FCrabLightingPreset::SLOcclusionTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, PPTemperature) == 0x00005C, "Member 'FCrabLightingPreset::PPTemperature' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFDensity) == 0x000060, "Member 'FCrabLightingPreset::HFDensity' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFHeightFalloff) == 0x000064, "Member 'FCrabLightingPreset::HFHeightFalloff' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFTint) == 0x000068, "Member 'FCrabLightingPreset::HFTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, HFStartDistance) == 0x000078, "Member 'FCrabLightingPreset::HFStartDistance' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, OceanMI) == 0x000080, "Member 'FCrabLightingPreset::OceanMI' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, UnderwaterPPTint) == 0x000088, "Member 'FCrabLightingPreset::UnderwaterPPTint' has a wrong offset!");
static_assert(offsetof(FCrabLightingPreset, BiomeDA) == 0x000098, "Member 'FCrabLightingPreset::BiomeDA' has a wrong offset!");

}

