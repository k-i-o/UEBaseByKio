#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CrabChampions

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CrabChampions_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class CrabChampions.CrabUI
// 0x0058 (0x02B8 - 0x0260)
class UCrabUI : public UUserWidget
{
public:
	uint8                                         Pad_13E6[0x58];                                    // 0x0260(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabUI">();
	}
	static class UCrabUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabUI>();
	}
};
static_assert(alignof(UCrabUI) == 0x000008, "Wrong alignment on UCrabUI");
static_assert(sizeof(UCrabUI) == 0x0002B8, "Wrong size on UCrabUI");

// Class CrabChampions.CrabChatEntryRowUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabChatEntryRowUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChatMessageText;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabChatEntryRowUI">();
	}
	static class UCrabChatEntryRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabChatEntryRowUI>();
	}
};
static_assert(alignof(UCrabChatEntryRowUI) == 0x000008, "Wrong alignment on UCrabChatEntryRowUI");
static_assert(sizeof(UCrabChatEntryRowUI) == 0x0002C8, "Wrong size on UCrabChatEntryRowUI");
static_assert(offsetof(UCrabChatEntryRowUI, PlayerNameText) == 0x0002B8, "Member 'UCrabChatEntryRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabChatEntryRowUI, ChatMessageText) == 0x0002C0, "Member 'UCrabChatEntryRowUI::ChatMessageText' has a wrong offset!");

// Class CrabChampions.CrabActionDA
// 0x0038 (0x0068 - 0x0030)
class UCrabActionDA : public UDataAsset
{
public:
	float                                         Range;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresLOS;                                      // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeGrounded;                                   // 0x0035(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E7[0x2];                                     // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMovementDuringAction;                         // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E8[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopingActionInterval;                             // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E9[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXSocketName;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FX;                                                // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Sound;                                             // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabActionDA">();
	}
	static class UCrabActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabActionDA>();
	}
};
static_assert(alignof(UCrabActionDA) == 0x000008, "Wrong alignment on UCrabActionDA");
static_assert(sizeof(UCrabActionDA) == 0x000068, "Wrong size on UCrabActionDA");
static_assert(offsetof(UCrabActionDA, Range) == 0x000030, "Member 'UCrabActionDA::Range' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bRequiresLOS) == 0x000034, "Member 'UCrabActionDA::bRequiresLOS' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bMustBeGrounded) == 0x000035, "Member 'UCrabActionDA::bMustBeGrounded' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, Weight) == 0x000038, "Member 'UCrabActionDA::Weight' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, bStopMovementDuringAction) == 0x00003C, "Member 'UCrabActionDA::bStopMovementDuringAction' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, LoopingActionInterval) == 0x000040, "Member 'UCrabActionDA::LoopingActionInterval' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, Montage) == 0x000048, "Member 'UCrabActionDA::Montage' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, FXSocketName) == 0x000050, "Member 'UCrabActionDA::FXSocketName' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, FX) == 0x000058, "Member 'UCrabActionDA::FX' has a wrong offset!");
static_assert(offsetof(UCrabActionDA, Sound) == 0x000060, "Member 'UCrabActionDA::Sound' has a wrong offset!");

// Class CrabChampions.CrabTurret
// 0x0118 (0x0338 - 0x0220)
class ACrabTurret : public AActor
{
public:
	uint8                                         Pad_13EA[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   TurretMesh;                                        // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TurretNC;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabHC*                                HC;                                                // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       HealthBarWC;                                       // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleSocketName;                                  // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MuzzleFlashNC;                                     // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        GunshotAC;                                         // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BaseMeshToSpawn;                                   // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            TurretMeshToSpawn;                                 // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0290(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchFrequency;                                   // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireRate;                                          // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13EB[0x8];                                     // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCrabHealthBarUI>           HealthBarUIToSpawn;                                // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarHeightOffset;                             // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13EC[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TurretName;                                        // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MuzzleFlashFX;                                     // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              GunshotSound;                                      // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurretRotationSpeed;                               // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13ED[0xC];                                     // 0x02DC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 BestEnemyC;                                        // 0x02E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchRange;                                       // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13EE[0x14];                                    // 0x02F4(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabDebuff                            Debuff;                                            // 0x0310(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsExploded;                                       // 0x0318(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13EF[0x7];                                     // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_IsExploded();
	void OnRep_OwningC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabTurret">();
	}
	static class ACrabTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabTurret>();
	}
};
static_assert(alignof(ACrabTurret) == 0x000008, "Wrong alignment on ACrabTurret");
static_assert(sizeof(ACrabTurret) == 0x000338, "Wrong size on ACrabTurret");
static_assert(offsetof(ACrabTurret, BaseMesh) == 0x000228, "Member 'ACrabTurret::BaseMesh' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretMesh) == 0x000230, "Member 'ACrabTurret::TurretMesh' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretNC) == 0x000238, "Member 'ACrabTurret::TurretNC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HC) == 0x000240, "Member 'ACrabTurret::HC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthBarWC) == 0x000248, "Member 'ACrabTurret::HealthBarWC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, MuzzleSocketName) == 0x000250, "Member 'ACrabTurret::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(ACrabTurret, MuzzleFlashNC) == 0x000258, "Member 'ACrabTurret::MuzzleFlashNC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, GunshotAC) == 0x000260, "Member 'ACrabTurret::GunshotAC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, Tint) == 0x000268, "Member 'ACrabTurret::Tint' has a wrong offset!");
static_assert(offsetof(ACrabTurret, BaseMeshToSpawn) == 0x000278, "Member 'ACrabTurret::BaseMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretMeshToSpawn) == 0x000280, "Member 'ACrabTurret::TurretMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabTurret, FX) == 0x000288, "Member 'ACrabTurret::FX' has a wrong offset!");
static_assert(offsetof(ACrabTurret, OwningC) == 0x000290, "Member 'ACrabTurret::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, SearchFrequency) == 0x000298, "Member 'ACrabTurret::SearchFrequency' has a wrong offset!");
static_assert(offsetof(ACrabTurret, FireRate) == 0x00029C, "Member 'ACrabTurret::FireRate' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthBarUIToSpawn) == 0x0002A8, "Member 'ACrabTurret::HealthBarUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabTurret, HealthBarHeightOffset) == 0x0002B0, "Member 'ACrabTurret::HealthBarHeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretName) == 0x0002B8, "Member 'ACrabTurret::TurretName' has a wrong offset!");
static_assert(offsetof(ACrabTurret, MuzzleFlashFX) == 0x0002C8, "Member 'ACrabTurret::MuzzleFlashFX' has a wrong offset!");
static_assert(offsetof(ACrabTurret, GunshotSound) == 0x0002D0, "Member 'ACrabTurret::GunshotSound' has a wrong offset!");
static_assert(offsetof(ACrabTurret, TurretRotationSpeed) == 0x0002D8, "Member 'ACrabTurret::TurretRotationSpeed' has a wrong offset!");
static_assert(offsetof(ACrabTurret, BestEnemyC) == 0x0002E8, "Member 'ACrabTurret::BestEnemyC' has a wrong offset!");
static_assert(offsetof(ACrabTurret, SearchRange) == 0x0002F0, "Member 'ACrabTurret::SearchRange' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ProjectileDA) == 0x000308, "Member 'ACrabTurret::ProjectileDA' has a wrong offset!");
static_assert(offsetof(ACrabTurret, Debuff) == 0x000310, "Member 'ACrabTurret::Debuff' has a wrong offset!");
static_assert(offsetof(ACrabTurret, bIsExploded) == 0x000318, "Member 'ACrabTurret::bIsExploded' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ExplosionFX) == 0x000320, "Member 'ACrabTurret::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ExplosionSound) == 0x000328, "Member 'ACrabTurret::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabTurret, ExplosionCameraShake) == 0x000330, "Member 'ACrabTurret::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabAOEActionDA
// 0x0008 (0x0070 - 0x0068)
class UCrabAOEActionDA final : public UCrabActionDA
{
public:
	class UCrabAOEDA*                             AOEDA;                                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAOEActionDA">();
	}
	static class UCrabAOEActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAOEActionDA>();
	}
};
static_assert(alignof(UCrabAOEActionDA) == 0x000008, "Wrong alignment on UCrabAOEActionDA");
static_assert(sizeof(UCrabAOEActionDA) == 0x000070, "Wrong size on UCrabAOEActionDA");
static_assert(offsetof(UCrabAOEActionDA, AOEDA) == 0x000068, "Member 'UCrabAOEActionDA::AOEDA' has a wrong offset!");

// Class CrabChampions.CrabCosmeticSlotUI
// 0x0078 (0x0330 - 0x02B8)
class UCrabCosmeticSlotUI : public UCrabUI
{
public:
	struct FCrabChallenge                         ChallengeToUnlock;                                 // 0x02B8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UCrabCosmeticsMenuUI*                   OwningCosmeticsMenuUI;                             // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SlotButton;                                        // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotIconImage;                                     // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SlotLockedOverlay;                                 // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                SlotSelectedBorder;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredSlotButton();
	void OnPressedSlotButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticSlotUI">();
	}
	static class UCrabCosmeticSlotUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCosmeticSlotUI>();
	}
};
static_assert(alignof(UCrabCosmeticSlotUI) == 0x000008, "Wrong alignment on UCrabCosmeticSlotUI");
static_assert(sizeof(UCrabCosmeticSlotUI) == 0x000330, "Wrong size on UCrabCosmeticSlotUI");
static_assert(offsetof(UCrabCosmeticSlotUI, ChallengeToUnlock) == 0x0002B8, "Member 'UCrabCosmeticSlotUI::ChallengeToUnlock' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, OwningCosmeticsMenuUI) == 0x000308, "Member 'UCrabCosmeticSlotUI::OwningCosmeticsMenuUI' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotButton) == 0x000310, "Member 'UCrabCosmeticSlotUI::SlotButton' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotIconImage) == 0x000318, "Member 'UCrabCosmeticSlotUI::SlotIconImage' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotLockedOverlay) == 0x000320, "Member 'UCrabCosmeticSlotUI::SlotLockedOverlay' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticSlotUI, SlotSelectedBorder) == 0x000328, "Member 'UCrabCosmeticSlotUI::SlotSelectedBorder' has a wrong offset!");

// Class CrabChampions.CrabLaunchActionDA
// 0x0010 (0x0078 - 0x0068)
class UCrabLaunchActionDA final : public UCrabActionDA
{
public:
	float                                         PreLaunchHeight;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchSpeed;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabAOEDA*                             LandAOEDA;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabLaunchActionDA">();
	}
	static class UCrabLaunchActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabLaunchActionDA>();
	}
};
static_assert(alignof(UCrabLaunchActionDA) == 0x000008, "Wrong alignment on UCrabLaunchActionDA");
static_assert(sizeof(UCrabLaunchActionDA) == 0x000078, "Wrong size on UCrabLaunchActionDA");
static_assert(offsetof(UCrabLaunchActionDA, PreLaunchHeight) == 0x000068, "Member 'UCrabLaunchActionDA::PreLaunchHeight' has a wrong offset!");
static_assert(offsetof(UCrabLaunchActionDA, LaunchSpeed) == 0x00006C, "Member 'UCrabLaunchActionDA::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(UCrabLaunchActionDA, LandAOEDA) == 0x000070, "Member 'UCrabLaunchActionDA::LandAOEDA' has a wrong offset!");

// Class CrabChampions.CrabControlsMenuUI
// 0x0060 (0x0318 - 0x02B8)
class UCrabControlsMenuUI : public UCrabUI
{
public:
	TArray<class UWidget*>                        ControlsMenuFocusableWidgetArray;                  // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          LookSensitivitySlider;                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          AimingSensitivityMultiplierSlider;                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  VerticalLookInversionAS;                           // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  AimAssistStrengthAS;                               // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabKeyBindRowUI>          KeyBindRowUIToSpawn;                               // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ControlsVerticalBox;                               // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabKeyBind>                   CurrentKeyBinds;                                   // 0x02F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UCrabKeyBindRowUI*>              KeyBindRows;                                       // 0x0308(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabControlsMenuUI">();
	}
	static class UCrabControlsMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabControlsMenuUI>();
	}
};
static_assert(alignof(UCrabControlsMenuUI) == 0x000008, "Wrong alignment on UCrabControlsMenuUI");
static_assert(sizeof(UCrabControlsMenuUI) == 0x000318, "Wrong size on UCrabControlsMenuUI");
static_assert(offsetof(UCrabControlsMenuUI, ControlsMenuFocusableWidgetArray) == 0x0002B8, "Member 'UCrabControlsMenuUI::ControlsMenuFocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, LookSensitivitySlider) == 0x0002C8, "Member 'UCrabControlsMenuUI::LookSensitivitySlider' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, AimingSensitivityMultiplierSlider) == 0x0002D0, "Member 'UCrabControlsMenuUI::AimingSensitivityMultiplierSlider' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, VerticalLookInversionAS) == 0x0002D8, "Member 'UCrabControlsMenuUI::VerticalLookInversionAS' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, AimAssistStrengthAS) == 0x0002E0, "Member 'UCrabControlsMenuUI::AimAssistStrengthAS' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, KeyBindRowUIToSpawn) == 0x0002E8, "Member 'UCrabControlsMenuUI::KeyBindRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, ControlsVerticalBox) == 0x0002F0, "Member 'UCrabControlsMenuUI::ControlsVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, CurrentKeyBinds) == 0x0002F8, "Member 'UCrabControlsMenuUI::CurrentKeyBinds' has a wrong offset!");
static_assert(offsetof(UCrabControlsMenuUI, KeyBindRows) == 0x000308, "Member 'UCrabControlsMenuUI::KeyBindRows' has a wrong offset!");

// Class CrabChampions.CrabSpawnActionDA
// 0x0018 (0x0080 - 0x0068)
class UCrabSpawnActionDA final : public UCrabActionDA
{
public:
	TArray<TSubclassOf<class ACrabEnemyC>>        LesserEnemiesToSpawn;                              // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnedLesserEnemies;                           // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F0[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpawnActionDA">();
	}
	static class UCrabSpawnActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSpawnActionDA>();
	}
};
static_assert(alignof(UCrabSpawnActionDA) == 0x000008, "Wrong alignment on UCrabSpawnActionDA");
static_assert(sizeof(UCrabSpawnActionDA) == 0x000080, "Wrong size on UCrabSpawnActionDA");
static_assert(offsetof(UCrabSpawnActionDA, LesserEnemiesToSpawn) == 0x000068, "Member 'UCrabSpawnActionDA::LesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabSpawnActionDA, MaxSpawnedLesserEnemies) == 0x000078, "Member 'UCrabSpawnActionDA::MaxSpawnedLesserEnemies' has a wrong offset!");

// Class CrabChampions.CrabCrosshairUI
// 0x0058 (0x0310 - 0x02B8)
class UCrabCrosshairUI : public UCrabUI
{
public:
	class ACrabPlayerC*                           OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabWeapon*                            EquippedWeapon;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrosshairImage;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CrosshairMI;                                       // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F1[0x10];                                    // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FireAnim;                                          // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HitmarkerImage;                                    // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       GenericHitmarkerAnim;                              // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ArmorBreakHitmarkerAnim;                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       EliminationHitmarkerAnim;                          // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCrosshairUI">();
	}
	static class UCrabCrosshairUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCrosshairUI>();
	}
};
static_assert(alignof(UCrabCrosshairUI) == 0x000008, "Wrong alignment on UCrabCrosshairUI");
static_assert(sizeof(UCrabCrosshairUI) == 0x000310, "Wrong size on UCrabCrosshairUI");
static_assert(offsetof(UCrabCrosshairUI, OwningC) == 0x0002B8, "Member 'UCrabCrosshairUI::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, EquippedWeapon) == 0x0002C0, "Member 'UCrabCrosshairUI::EquippedWeapon' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, CrosshairImage) == 0x0002C8, "Member 'UCrabCrosshairUI::CrosshairImage' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, CrosshairMI) == 0x0002D0, "Member 'UCrabCrosshairUI::CrosshairMI' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, FireAnim) == 0x0002E8, "Member 'UCrabCrosshairUI::FireAnim' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, HitmarkerImage) == 0x0002F0, "Member 'UCrabCrosshairUI::HitmarkerImage' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, GenericHitmarkerAnim) == 0x0002F8, "Member 'UCrabCrosshairUI::GenericHitmarkerAnim' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, ArmorBreakHitmarkerAnim) == 0x000300, "Member 'UCrabCrosshairUI::ArmorBreakHitmarkerAnim' has a wrong offset!");
static_assert(offsetof(UCrabCrosshairUI, EliminationHitmarkerAnim) == 0x000308, "Member 'UCrabCrosshairUI::EliminationHitmarkerAnim' has a wrong offset!");

// Class CrabChampions.CrabProximityExplodeActionDA
// 0x0008 (0x0070 - 0x0068)
class UCrabProximityExplodeActionDA final : public UCrabActionDA
{
public:
	class UCrabAOEDA*                             ExplosionAOEDA;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProximityExplodeActionDA">();
	}
	static class UCrabProximityExplodeActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabProximityExplodeActionDA>();
	}
};
static_assert(alignof(UCrabProximityExplodeActionDA) == 0x000008, "Wrong alignment on UCrabProximityExplodeActionDA");
static_assert(sizeof(UCrabProximityExplodeActionDA) == 0x000070, "Wrong size on UCrabProximityExplodeActionDA");
static_assert(offsetof(UCrabProximityExplodeActionDA, ExplosionAOEDA) == 0x000068, "Member 'UCrabProximityExplodeActionDA::ExplosionAOEDA' has a wrong offset!");

// Class CrabChampions.CrabDifficultyModifierUI
// 0x0040 (0x02F8 - 0x02B8)
class UCrabDifficultyModifierUI : public UCrabUI
{
public:
	class UCrabDifficultyMenuUI*                  OwningDifficultyMenuUI;                            // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F2[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               DifficultyModifierOverlay;                         // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                DifficultyModifierButton;                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyModifierNameText;                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyModifierDescriptionText;                 // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ChallengeLevelOverlay;                             // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeLevelText;                                // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredDifficultyModifierButton();
	void OnPressedDifficultyModifierButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDifficultyModifierUI">();
	}
	static class UCrabDifficultyModifierUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabDifficultyModifierUI>();
	}
};
static_assert(alignof(UCrabDifficultyModifierUI) == 0x000008, "Wrong alignment on UCrabDifficultyModifierUI");
static_assert(sizeof(UCrabDifficultyModifierUI) == 0x0002F8, "Wrong size on UCrabDifficultyModifierUI");
static_assert(offsetof(UCrabDifficultyModifierUI, OwningDifficultyMenuUI) == 0x0002B8, "Member 'UCrabDifficultyModifierUI::OwningDifficultyMenuUI' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierOverlay) == 0x0002C8, "Member 'UCrabDifficultyModifierUI::DifficultyModifierOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierButton) == 0x0002D0, "Member 'UCrabDifficultyModifierUI::DifficultyModifierButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierNameText) == 0x0002D8, "Member 'UCrabDifficultyModifierUI::DifficultyModifierNameText' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, DifficultyModifierDescriptionText) == 0x0002E0, "Member 'UCrabDifficultyModifierUI::DifficultyModifierDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, ChallengeLevelOverlay) == 0x0002E8, "Member 'UCrabDifficultyModifierUI::ChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyModifierUI, ChallengeLevelText) == 0x0002F0, "Member 'UCrabDifficultyModifierUI::ChallengeLevelText' has a wrong offset!");

// Class CrabChampions.CrabStrikeActionDA
// 0x0028 (0x0090 - 0x0068)
class UCrabStrikeActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F3[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACrabStrike>                StrikeToSpawn;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumLineStrikesToSpawn;                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineStrikeSpawnFrequency;                          // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFormationType                            FormationType;                                     // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F4[0x3];                                     // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FormationSpacing;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spread;                                            // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F5[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStrikeActionDA">();
	}
	static class UCrabStrikeActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabStrikeActionDA>();
	}
};
static_assert(alignof(UCrabStrikeActionDA) == 0x000008, "Wrong alignment on UCrabStrikeActionDA");
static_assert(sizeof(UCrabStrikeActionDA) == 0x000090, "Wrong size on UCrabStrikeActionDA");
static_assert(offsetof(UCrabStrikeActionDA, TargetType) == 0x000068, "Member 'UCrabStrikeActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, StrikeToSpawn) == 0x000070, "Member 'UCrabStrikeActionDA::StrikeToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, NumLineStrikesToSpawn) == 0x000078, "Member 'UCrabStrikeActionDA::NumLineStrikesToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, LineStrikeSpawnFrequency) == 0x00007C, "Member 'UCrabStrikeActionDA::LineStrikeSpawnFrequency' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, FormationType) == 0x000080, "Member 'UCrabStrikeActionDA::FormationType' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, FormationSpacing) == 0x000084, "Member 'UCrabStrikeActionDA::FormationSpacing' has a wrong offset!");
static_assert(offsetof(UCrabStrikeActionDA, Spread) == 0x000088, "Member 'UCrabStrikeActionDA::Spread' has a wrong offset!");

// Class CrabChampions.CrabFocusMenuUI
// 0x0118 (0x03D0 - 0x02B8)
class UCrabFocusMenuUI : public UCrabUI
{
public:
	class UWidgetSwitcher*                        MenuWidgetSwitcher;                                // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        FocusableWidgetArray;                              // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ACrabPC*                                OwningPC;                                          // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F6[0x70];                                    // 0x02D8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                PreviouslyFocusedWidget;                           // 0x0348(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MenuCanvasPanel;                                   // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ResetFocusButton;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HoverSound;                                        // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PressSound;                                        // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MenuActionKeyText;                                 // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MenuActionControllerIcon;                          // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MenuBackKeyText;                                   // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MenuBackControllerIcon;                            // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NextSubmenuKeyText;                                // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NextSubmenuIcon;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PreviousSubmenuKeyText;                            // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PreviousSubmenuIcon;                               // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SubmenuHorizontalBox;                              // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F7[0x8];                                     // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                ActionButton;                                      // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BackButton;                                        // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedActionButton();
	void OnPressedBackButton();
	void OnPressedResetFocusButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabFocusMenuUI">();
	}
	static class UCrabFocusMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabFocusMenuUI>();
	}
};
static_assert(alignof(UCrabFocusMenuUI) == 0x000008, "Wrong alignment on UCrabFocusMenuUI");
static_assert(sizeof(UCrabFocusMenuUI) == 0x0003D0, "Wrong size on UCrabFocusMenuUI");
static_assert(offsetof(UCrabFocusMenuUI, MenuWidgetSwitcher) == 0x0002B8, "Member 'UCrabFocusMenuUI::MenuWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, FocusableWidgetArray) == 0x0002C0, "Member 'UCrabFocusMenuUI::FocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, OwningPC) == 0x0002D0, "Member 'UCrabFocusMenuUI::OwningPC' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PreviouslyFocusedWidget) == 0x000348, "Member 'UCrabFocusMenuUI::PreviouslyFocusedWidget' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuCanvasPanel) == 0x000350, "Member 'UCrabFocusMenuUI::MenuCanvasPanel' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, ResetFocusButton) == 0x000358, "Member 'UCrabFocusMenuUI::ResetFocusButton' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, HoverSound) == 0x000360, "Member 'UCrabFocusMenuUI::HoverSound' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PressSound) == 0x000368, "Member 'UCrabFocusMenuUI::PressSound' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuActionKeyText) == 0x000370, "Member 'UCrabFocusMenuUI::MenuActionKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuActionControllerIcon) == 0x000378, "Member 'UCrabFocusMenuUI::MenuActionControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuBackKeyText) == 0x000380, "Member 'UCrabFocusMenuUI::MenuBackKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, MenuBackControllerIcon) == 0x000388, "Member 'UCrabFocusMenuUI::MenuBackControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, NextSubmenuKeyText) == 0x000390, "Member 'UCrabFocusMenuUI::NextSubmenuKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, NextSubmenuIcon) == 0x000398, "Member 'UCrabFocusMenuUI::NextSubmenuIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PreviousSubmenuKeyText) == 0x0003A0, "Member 'UCrabFocusMenuUI::PreviousSubmenuKeyText' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, PreviousSubmenuIcon) == 0x0003A8, "Member 'UCrabFocusMenuUI::PreviousSubmenuIcon' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, SubmenuHorizontalBox) == 0x0003B0, "Member 'UCrabFocusMenuUI::SubmenuHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, ActionButton) == 0x0003C0, "Member 'UCrabFocusMenuUI::ActionButton' has a wrong offset!");
static_assert(offsetof(UCrabFocusMenuUI, BackButton) == 0x0003C8, "Member 'UCrabFocusMenuUI::BackButton' has a wrong offset!");

// Class CrabChampions.CrabAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UCrabAnimInstance : public UAnimInstance
{
public:
	class ACrabC*                                 OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Pitch;                                             // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Direction;                                         // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFalling;                                        // 0x02CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKnockedBack;                                    // 0x02CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F8[0x2];                                     // 0x02CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAnimInstance">();
	}
	static class UCrabAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAnimInstance>();
	}
};
static_assert(alignof(UCrabAnimInstance) == 0x000010, "Wrong alignment on UCrabAnimInstance");
static_assert(sizeof(UCrabAnimInstance) == 0x0002D0, "Wrong size on UCrabAnimInstance");
static_assert(offsetof(UCrabAnimInstance, OwningC) == 0x0002B8, "Member 'UCrabAnimInstance::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, Pitch) == 0x0002C0, "Member 'UCrabAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, Direction) == 0x0002C4, "Member 'UCrabAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, Speed) == 0x0002C8, "Member 'UCrabAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, bIsFalling) == 0x0002CC, "Member 'UCrabAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UCrabAnimInstance, bIsKnockedBack) == 0x0002CD, "Member 'UCrabAnimInstance::bIsKnockedBack' has a wrong offset!");

// Class CrabChampions.CrabConfirmationPromptUI
// 0x0030 (0x0400 - 0x03D0)
class UCrabConfirmationPromptUI : public UCrabFocusMenuUI
{
public:
	class UTextBlock*                             ConfirmationPromptMessageText;                     // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                YesButton;                                         // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NoButton;                                          // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F9[0x18];                                    // 0x03E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredNoButton();
	void OnHoveredYesButton();
	void OnPressedNoButton();
	void OnPressedYesButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabConfirmationPromptUI">();
	}
	static class UCrabConfirmationPromptUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabConfirmationPromptUI>();
	}
};
static_assert(alignof(UCrabConfirmationPromptUI) == 0x000008, "Wrong alignment on UCrabConfirmationPromptUI");
static_assert(sizeof(UCrabConfirmationPromptUI) == 0x000400, "Wrong size on UCrabConfirmationPromptUI");
static_assert(offsetof(UCrabConfirmationPromptUI, ConfirmationPromptMessageText) == 0x0003D0, "Member 'UCrabConfirmationPromptUI::ConfirmationPromptMessageText' has a wrong offset!");
static_assert(offsetof(UCrabConfirmationPromptUI, YesButton) == 0x0003D8, "Member 'UCrabConfirmationPromptUI::YesButton' has a wrong offset!");
static_assert(offsetof(UCrabConfirmationPromptUI, NoButton) == 0x0003E0, "Member 'UCrabConfirmationPromptUI::NoButton' has a wrong offset!");

// Class CrabChampions.CrabAOEDA
// 0x0038 (0x0068 - 0x0030)
class UCrabAOEDA final : public UDataAsset
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDamageType                               DamageType;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FA[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockbackStrength;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawn;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         AOEFX;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AOESound;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAOEDA">();
	}
	static class UCrabAOEDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAOEDA>();
	}
};
static_assert(alignof(UCrabAOEDA) == 0x000008, "Wrong alignment on UCrabAOEDA");
static_assert(sizeof(UCrabAOEDA) == 0x000068, "Wrong size on UCrabAOEDA");
static_assert(offsetof(UCrabAOEDA, SocketName) == 0x000030, "Member 'UCrabAOEDA::SocketName' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, Radius) == 0x000038, "Member 'UCrabAOEDA::Radius' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, Damage) == 0x00003C, "Member 'UCrabAOEDA::Damage' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, DamageType) == 0x000040, "Member 'UCrabAOEDA::DamageType' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, KnockbackStrength) == 0x000044, "Member 'UCrabAOEDA::KnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, DamageAreaToSpawn) == 0x000048, "Member 'UCrabAOEDA::DamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, AOEFX) == 0x000050, "Member 'UCrabAOEDA::AOEFX' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, AOESound) == 0x000058, "Member 'UCrabAOEDA::AOESound' has a wrong offset!");
static_assert(offsetof(UCrabAOEDA, CameraShake) == 0x000060, "Member 'UCrabAOEDA::CameraShake' has a wrong offset!");

// Class CrabChampions.CrabBiomeDA
// 0x0100 (0x0130 - 0x0030)
class UCrabBiomeDA final : public UDataAsset
{
public:
	ECrabBiome                                    Biome;                                             // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FB[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabIsland>                    ArenaIslands;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    HordeIslands;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    LargeIslands;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    ParkourIslands;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    ShopIslands;                                       // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCrabIsland>                    BossIslands;                                       // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabEnemyC>>        Enemies;                                           // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  CombatDestructibles;                               // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  RewardDestructibles;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  PhysicsDestructibles;                              // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         AmbienceFX;                                        // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AmbienceSound;                                     // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         UnderwaterFX;                                      // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SmallOceanImpactFX;                                // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SmallOceanImpactSound;                             // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LargeOceanImpactFX;                                // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LargeOceanImpactSound;                             // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderwaterSpeedMultiplier;                         // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabDebuff                            UnderwaterDebuff;                                  // 0x0114(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FC[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              MusicPlaylist;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ShopMusic;                                         // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBiomeDA">();
	}
	static class UCrabBiomeDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabBiomeDA>();
	}
};
static_assert(alignof(UCrabBiomeDA) == 0x000008, "Wrong alignment on UCrabBiomeDA");
static_assert(sizeof(UCrabBiomeDA) == 0x000130, "Wrong size on UCrabBiomeDA");
static_assert(offsetof(UCrabBiomeDA, Biome) == 0x000030, "Member 'UCrabBiomeDA::Biome' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ArenaIslands) == 0x000038, "Member 'UCrabBiomeDA::ArenaIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, HordeIslands) == 0x000048, "Member 'UCrabBiomeDA::HordeIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, LargeIslands) == 0x000058, "Member 'UCrabBiomeDA::LargeIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ParkourIslands) == 0x000068, "Member 'UCrabBiomeDA::ParkourIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ShopIslands) == 0x000078, "Member 'UCrabBiomeDA::ShopIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, BossIslands) == 0x000088, "Member 'UCrabBiomeDA::BossIslands' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, Enemies) == 0x000098, "Member 'UCrabBiomeDA::Enemies' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, CombatDestructibles) == 0x0000A8, "Member 'UCrabBiomeDA::CombatDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, RewardDestructibles) == 0x0000B8, "Member 'UCrabBiomeDA::RewardDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, PhysicsDestructibles) == 0x0000C8, "Member 'UCrabBiomeDA::PhysicsDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, AmbienceFX) == 0x0000D8, "Member 'UCrabBiomeDA::AmbienceFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, AmbienceSound) == 0x0000E0, "Member 'UCrabBiomeDA::AmbienceSound' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, UnderwaterFX) == 0x0000E8, "Member 'UCrabBiomeDA::UnderwaterFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, SmallOceanImpactFX) == 0x0000F0, "Member 'UCrabBiomeDA::SmallOceanImpactFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, SmallOceanImpactSound) == 0x0000F8, "Member 'UCrabBiomeDA::SmallOceanImpactSound' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, LargeOceanImpactFX) == 0x000100, "Member 'UCrabBiomeDA::LargeOceanImpactFX' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, LargeOceanImpactSound) == 0x000108, "Member 'UCrabBiomeDA::LargeOceanImpactSound' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, UnderwaterSpeedMultiplier) == 0x000110, "Member 'UCrabBiomeDA::UnderwaterSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, UnderwaterDebuff) == 0x000114, "Member 'UCrabBiomeDA::UnderwaterDebuff' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, MusicPlaylist) == 0x000120, "Member 'UCrabBiomeDA::MusicPlaylist' has a wrong offset!");
static_assert(offsetof(UCrabBiomeDA, ShopMusic) == 0x000128, "Member 'UCrabBiomeDA::ShopMusic' has a wrong offset!");

// Class CrabChampions.CrabC
// 0x0260 (0x0720 - 0x04C0)
#pragma pack(push, 0x1)
class alignas(0x10) ACrabC : public ACharacter
{
public:
	class UCrabHC*                                HC;                                                // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      DebuffNC;                                          // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        DebuffAC;                                          // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChainLightningNC;                                  // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          MeshToSpawn;                                       // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshMat;                                           // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              AnimationBlueprintToUse;                           // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x04F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CoreSocketName;                                    // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabLM*                                LM;                                                // 0x0510(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0518(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13FD[0x8];                                     // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabWeapon*>                    Weapons;                                           // 0x0530(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13FE[0x30];                                    // 0x0540(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 UROIntervalPerLOD;                                 // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         UpdateMovementStateFrequency;                      // 0x0580(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13FF[0x10];                                    // 0x0584(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAlignToTerrain;                                   // 0x0594(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1400[0x3];                                     // 0x0595(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AlignToTerrainSocketName;                          // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1401[0x10];                                    // 0x05A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseWalkSpeed;                                     // 0x05B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseGravityScale;                                  // 0x05B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundFriction;                                    // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAcceleration;                                   // 0x05BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AirControl;                                        // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateViewPitch;                               // 0x05C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1402[0x3];                                     // 0x05C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentViewPitch;                                  // 0x05C8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1403[0xC];                                     // 0x05CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              LandSound;                                         // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1404[0x1];                                     // 0x05E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSlowWhenUnderwater;                               // 0x05E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1405[0xE];                                     // 0x05E2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsKnockedBack;                                    // 0x05F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1406[0x7];                                     // 0x05F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 KnockbackDamageCauser;                             // 0x05F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1407[0x4];                                     // 0x0600(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenDamageEvents;                        // 0x0604(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1408[0x8];                                     // 0x0608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsImmuneToKnockbacks;                             // 0x0610(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToKnockbackDamage;                        // 0x0611(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToIce;                                    // 0x0612(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToFire;                                   // 0x0613(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToLightning;                              // 0x0614(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToPoison;                                 // 0x0615(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1409[0x2];                                     // 0x0616(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebuffStackMultiplier;                             // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebuffStackLimit;                                  // 0x061C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsImmuneToSelfDamage;                             // 0x0620(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140A[0x3];                                     // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelfDamageMultiplier;                              // 0x0624(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitIncomingDamage;                              // 0x0628(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInvulnerable;                                   // 0x0629(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140B[0x6];                                     // 0x062A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      InvulnerableNC;                                    // 0x0630(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         InvulnerableFX;                                    // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              InvulnerableSound;                                 // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 LastDamageCauser;                                  // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAwardDamageDealtWhenDamaged;                      // 0x0650(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140C[0x1F];                                    // 0x0651(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEliminated;                                     // 0x0670(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140D[0x7];                                     // 0x0671(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EliminatedMontage;                                 // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeSpanCleanupTime;                               // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140E[0x4];                                     // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 DOTDamageCauser;                                   // 0x0688(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140F[0x4];                                     // 0x0690(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenFreezes;                             // 0x0694(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 IceDamageCauser;                                   // 0x0698(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 FireDamageCauser;                                  // 0x06A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 LightningDamageCauser;                             // 0x06A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 ArcaneDamageCauser;                                // 0x06B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1410[0x28];                                    // 0x06B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuffState                       DebuffState;                                       // 0x06E0(0x0020)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1411[0x8];                                     // 0x0700(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 ChainedToC;                                        // 0x0708(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1412[0x8];                                     // 0x0710(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientKnockback(const struct FVector_NetQuantizeNormal& Dir, float Strength);
	void OnRep_ChainedToC();
	void OnRep_DebuffState(const struct FCrabDebuffState& PreviousDebuffState);
	void OnRep_IsEliminated();
	void OnRep_IsInvulnerable();
	void ServerClientAuthoritativeMove(const struct FClientAuthoritativeMoveData& MoveData);
	void ServerDealDamage(const TArray<struct FCrabDamageInfo>& DamageInfoArray);
	void ServerOnOutOfBounds();
	void ServerSpawnCosmeticProjectile(const struct FCrabProjectileInfo& ProjectileInfo, class AActor* ProjectileOwner, const struct FVector_NetQuantize& StartLoc, bool bExplodeInstantly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabC">();
	}
	static class ACrabC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabC>();
	}
};
#pragma pack(pop)
static_assert(alignof(ACrabC) == 0x000010, "Wrong alignment on ACrabC");
static_assert(sizeof(ACrabC) == 0x000720, "Wrong size on ACrabC");
static_assert(offsetof(ACrabC, HC) == 0x0004C0, "Member 'ACrabC::HC' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffNC) == 0x0004C8, "Member 'ACrabC::DebuffNC' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffAC) == 0x0004D0, "Member 'ACrabC::DebuffAC' has a wrong offset!");
static_assert(offsetof(ACrabC, ChainLightningNC) == 0x0004D8, "Member 'ACrabC::ChainLightningNC' has a wrong offset!");
static_assert(offsetof(ACrabC, MeshToSpawn) == 0x0004E0, "Member 'ACrabC::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabC, MeshMat) == 0x0004E8, "Member 'ACrabC::MeshMat' has a wrong offset!");
static_assert(offsetof(ACrabC, AnimationBlueprintToUse) == 0x0004F0, "Member 'ACrabC::AnimationBlueprintToUse' has a wrong offset!");
static_assert(offsetof(ACrabC, Tint) == 0x0004F8, "Member 'ACrabC::Tint' has a wrong offset!");
static_assert(offsetof(ACrabC, CoreSocketName) == 0x000508, "Member 'ACrabC::CoreSocketName' has a wrong offset!");
static_assert(offsetof(ACrabC, LM) == 0x000510, "Member 'ACrabC::LM' has a wrong offset!");
static_assert(offsetof(ACrabC, ActorsToIgnore) == 0x000518, "Member 'ACrabC::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabC, Weapons) == 0x000530, "Member 'ACrabC::Weapons' has a wrong offset!");
static_assert(offsetof(ACrabC, UROIntervalPerLOD) == 0x000570, "Member 'ACrabC::UROIntervalPerLOD' has a wrong offset!");
static_assert(offsetof(ACrabC, UpdateMovementStateFrequency) == 0x000580, "Member 'ACrabC::UpdateMovementStateFrequency' has a wrong offset!");
static_assert(offsetof(ACrabC, bAlignToTerrain) == 0x000594, "Member 'ACrabC::bAlignToTerrain' has a wrong offset!");
static_assert(offsetof(ACrabC, AlignToTerrainSocketName) == 0x000598, "Member 'ACrabC::AlignToTerrainSocketName' has a wrong offset!");
static_assert(offsetof(ACrabC, BaseWalkSpeed) == 0x0005B0, "Member 'ACrabC::BaseWalkSpeed' has a wrong offset!");
static_assert(offsetof(ACrabC, BaseGravityScale) == 0x0005B4, "Member 'ACrabC::BaseGravityScale' has a wrong offset!");
static_assert(offsetof(ACrabC, GroundFriction) == 0x0005B8, "Member 'ACrabC::GroundFriction' has a wrong offset!");
static_assert(offsetof(ACrabC, MaxAcceleration) == 0x0005BC, "Member 'ACrabC::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(ACrabC, AirControl) == 0x0005C0, "Member 'ACrabC::AirControl' has a wrong offset!");
static_assert(offsetof(ACrabC, bCalculateViewPitch) == 0x0005C4, "Member 'ACrabC::bCalculateViewPitch' has a wrong offset!");
static_assert(offsetof(ACrabC, CurrentViewPitch) == 0x0005C8, "Member 'ACrabC::CurrentViewPitch' has a wrong offset!");
static_assert(offsetof(ACrabC, LandSound) == 0x0005D8, "Member 'ACrabC::LandSound' has a wrong offset!");
static_assert(offsetof(ACrabC, bSlowWhenUnderwater) == 0x0005E1, "Member 'ACrabC::bSlowWhenUnderwater' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsKnockedBack) == 0x0005F0, "Member 'ACrabC::bIsKnockedBack' has a wrong offset!");
static_assert(offsetof(ACrabC, KnockbackDamageCauser) == 0x0005F8, "Member 'ACrabC::KnockbackDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, MinTimeBetweenDamageEvents) == 0x000604, "Member 'ACrabC::MinTimeBetweenDamageEvents' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToKnockbacks) == 0x000610, "Member 'ACrabC::bIsImmuneToKnockbacks' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToKnockbackDamage) == 0x000611, "Member 'ACrabC::bIsImmuneToKnockbackDamage' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToIce) == 0x000612, "Member 'ACrabC::bIsImmuneToIce' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToFire) == 0x000613, "Member 'ACrabC::bIsImmuneToFire' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToLightning) == 0x000614, "Member 'ACrabC::bIsImmuneToLightning' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToPoison) == 0x000615, "Member 'ACrabC::bIsImmuneToPoison' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffStackMultiplier) == 0x000618, "Member 'ACrabC::DebuffStackMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffStackLimit) == 0x00061C, "Member 'ACrabC::DebuffStackLimit' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsImmuneToSelfDamage) == 0x000620, "Member 'ACrabC::bIsImmuneToSelfDamage' has a wrong offset!");
static_assert(offsetof(ACrabC, SelfDamageMultiplier) == 0x000624, "Member 'ACrabC::SelfDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabC, bLimitIncomingDamage) == 0x000628, "Member 'ACrabC::bLimitIncomingDamage' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsInvulnerable) == 0x000629, "Member 'ACrabC::bIsInvulnerable' has a wrong offset!");
static_assert(offsetof(ACrabC, InvulnerableNC) == 0x000630, "Member 'ACrabC::InvulnerableNC' has a wrong offset!");
static_assert(offsetof(ACrabC, InvulnerableFX) == 0x000638, "Member 'ACrabC::InvulnerableFX' has a wrong offset!");
static_assert(offsetof(ACrabC, InvulnerableSound) == 0x000640, "Member 'ACrabC::InvulnerableSound' has a wrong offset!");
static_assert(offsetof(ACrabC, LastDamageCauser) == 0x000648, "Member 'ACrabC::LastDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, bAwardDamageDealtWhenDamaged) == 0x000650, "Member 'ACrabC::bAwardDamageDealtWhenDamaged' has a wrong offset!");
static_assert(offsetof(ACrabC, bIsEliminated) == 0x000670, "Member 'ACrabC::bIsEliminated' has a wrong offset!");
static_assert(offsetof(ACrabC, EliminatedMontage) == 0x000678, "Member 'ACrabC::EliminatedMontage' has a wrong offset!");
static_assert(offsetof(ACrabC, LifeSpanCleanupTime) == 0x000680, "Member 'ACrabC::LifeSpanCleanupTime' has a wrong offset!");
static_assert(offsetof(ACrabC, DOTDamageCauser) == 0x000688, "Member 'ACrabC::DOTDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, MinTimeBetweenFreezes) == 0x000694, "Member 'ACrabC::MinTimeBetweenFreezes' has a wrong offset!");
static_assert(offsetof(ACrabC, IceDamageCauser) == 0x000698, "Member 'ACrabC::IceDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, FireDamageCauser) == 0x0006A0, "Member 'ACrabC::FireDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, LightningDamageCauser) == 0x0006A8, "Member 'ACrabC::LightningDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, ArcaneDamageCauser) == 0x0006B0, "Member 'ACrabC::ArcaneDamageCauser' has a wrong offset!");
static_assert(offsetof(ACrabC, DebuffState) == 0x0006E0, "Member 'ACrabC::DebuffState' has a wrong offset!");
static_assert(offsetof(ACrabC, ChainedToC) == 0x000708, "Member 'ACrabC::ChainedToC' has a wrong offset!");

// Class CrabChampions.CrabEnemyC
// 0x0240 (0x0960 - 0x0720)
class ACrabEnemyC : public ACrabC
{
public:
	class UWidgetComponent*                       HealthBarWC;                                       // 0x0718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleMultiplier;                                   // 0x0720(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1414[0x4];                                     // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MeshDMI;                                           // 0x0728(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1415[0x9];                                     // 0x0730(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCollideWithCharacters;                            // 0x0739(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEliminateIfStuck;                                 // 0x073A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1416[0x1D];                                    // 0x073B(0x001D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabEnemySpawnSettings                EnemySpawnSettings;                                // 0x0758(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ACrabEnemyAIC*                          OwningAIC;                                         // 0x0780(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabEnemyCategory                            EnemyCategory;                                     // 0x0788(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1417[0x7];                                     // 0x0789(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EnemyName;                                         // 0x0790(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarHeightOffset;                             // 0x07A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldFloat;                                      // 0x07A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1418[0x3];                                     // 0x07A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightOffset;                                      // 0x07A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1419[0x14];                                    // 0x07AC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInvulnerableWhenNoActionIsActive;                 // 0x07C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141A[0x7];                                     // 0x07C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabEnemyBuff>                        BannedEnemyBuffs;                                  // 0x07C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ECrabEnemyBuff                                EnemyBuff;                                         // 0x07D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShielded;                                       // 0x07D9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141B[0x6];                                     // 0x07DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ShieldNC;                                          // 0x07E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabAISettings                        AISettings;                                        // 0x07E8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_141C[0x8];                                     // 0x0810(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 BestEnemyC;                                        // 0x0818(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCrabActionDA*>                  ActionDAs;                                         // 0x0820(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         CurrentActionIndex;                                // 0x0830(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141D[0x7];                                     // 0x0831(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabActionDA*                          CurrentActionDA;                                   // 0x0838(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ActionNC;                                          // 0x0840(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ActionAC;                                          // 0x0848(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141E[0x20];                                    // 0x0850(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        PendingLesserEnemiesToSpawn;                       // 0x0870(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_141F[0x18];                                    // 0x0880(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpSpeed;                                         // 0x0898(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpHeight;                                        // 0x089C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashSpeed;                                         // 0x08A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashHeight;                                        // 0x08A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabDebuff                            EnemyDebuff;                                       // 0x08A8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawnWhileMoving;                      // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabHealthBarUI>           HealthBarUIToSpawn;                                // 0x08B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           EnemySpawnMontage;                                 // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         EnemySpawnFX;                                      // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              EnemySpawnSound;                                   // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MeshNC;                                            // 0x08E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MeshFX;                                            // 0x08E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        MeshAC;                                            // 0x08F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MeshSound;                                         // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeshFXSocketName;                                  // 0x0900(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLesserEnemy;                                    // 0x0908(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1420[0x7];                                     // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasBeenDamagedPastMaxHealth;                      // 0x0910(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1421[0xF];                                     // 0x0911(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 EliminatingC;                                      // 0x0920(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1422[0x4];                                     // 0x0928(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToSpawnOnEliminatedEnemies;                  // 0x092C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACrabEnemyC>>        OnEliminatedEnemiesToSpawn;                        // 0x0930(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1423[0x8];                                     // 0x0940(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         GibFX;                                             // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              GibSound;                                          // 0x0950(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1424[0x8];                                     // 0x0958(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastShowHealthBar();
	void MulticastSpawnHomingThornProjectiles();
	void MulticastSpawnMirroredProjectile(class ACrabC* DamagingC);
	void MulticastSpawnShrapnelProjectiles();
	void OnRep_CurrentActionIndex();
	void OnRep_EnemyBuff();
	void OnRep_IsShielded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyC">();
	}
	static class ACrabEnemyC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabEnemyC>();
	}
};
static_assert(alignof(ACrabEnemyC) == 0x000010, "Wrong alignment on ACrabEnemyC");
static_assert(sizeof(ACrabEnemyC) == 0x000960, "Wrong size on ACrabEnemyC");
static_assert(offsetof(ACrabEnemyC, HealthBarWC) == 0x000718, "Member 'ACrabEnemyC::HealthBarWC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ScaleMultiplier) == 0x000720, "Member 'ACrabEnemyC::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshDMI) == 0x000728, "Member 'ACrabEnemyC::MeshDMI' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bCollideWithCharacters) == 0x000739, "Member 'ACrabEnemyC::bCollideWithCharacters' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bEliminateIfStuck) == 0x00073A, "Member 'ACrabEnemyC::bEliminateIfStuck' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnSettings) == 0x000758, "Member 'ACrabEnemyC::EnemySpawnSettings' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, OwningAIC) == 0x000780, "Member 'ACrabEnemyC::OwningAIC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyCategory) == 0x000788, "Member 'ACrabEnemyC::EnemyCategory' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyName) == 0x000790, "Member 'ACrabEnemyC::EnemyName' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HealthBarHeightOffset) == 0x0007A0, "Member 'ACrabEnemyC::HealthBarHeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bShouldFloat) == 0x0007A4, "Member 'ACrabEnemyC::bShouldFloat' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HeightOffset) == 0x0007A8, "Member 'ACrabEnemyC::HeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bInvulnerableWhenNoActionIsActive) == 0x0007C0, "Member 'ACrabEnemyC::bInvulnerableWhenNoActionIsActive' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, BannedEnemyBuffs) == 0x0007C8, "Member 'ACrabEnemyC::BannedEnemyBuffs' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyBuff) == 0x0007D8, "Member 'ACrabEnemyC::EnemyBuff' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bIsShielded) == 0x0007D9, "Member 'ACrabEnemyC::bIsShielded' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ShieldNC) == 0x0007E0, "Member 'ACrabEnemyC::ShieldNC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, AISettings) == 0x0007E8, "Member 'ACrabEnemyC::AISettings' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, BestEnemyC) == 0x000818, "Member 'ACrabEnemyC::BestEnemyC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ActionDAs) == 0x000820, "Member 'ACrabEnemyC::ActionDAs' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, CurrentActionIndex) == 0x000830, "Member 'ACrabEnemyC::CurrentActionIndex' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, CurrentActionDA) == 0x000838, "Member 'ACrabEnemyC::CurrentActionDA' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ActionNC) == 0x000840, "Member 'ACrabEnemyC::ActionNC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ActionAC) == 0x000848, "Member 'ACrabEnemyC::ActionAC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, PendingLesserEnemiesToSpawn) == 0x000870, "Member 'ACrabEnemyC::PendingLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, JumpSpeed) == 0x000898, "Member 'ACrabEnemyC::JumpSpeed' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, JumpHeight) == 0x00089C, "Member 'ACrabEnemyC::JumpHeight' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, DashSpeed) == 0x0008A0, "Member 'ACrabEnemyC::DashSpeed' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, DashHeight) == 0x0008A4, "Member 'ACrabEnemyC::DashHeight' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemyDebuff) == 0x0008A8, "Member 'ACrabEnemyC::EnemyDebuff' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, DamageAreaToSpawnWhileMoving) == 0x0008B0, "Member 'ACrabEnemyC::DamageAreaToSpawnWhileMoving' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, HealthBarUIToSpawn) == 0x0008B8, "Member 'ACrabEnemyC::HealthBarUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, WeaponDA) == 0x0008C0, "Member 'ACrabEnemyC::WeaponDA' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnMontage) == 0x0008C8, "Member 'ACrabEnemyC::EnemySpawnMontage' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnFX) == 0x0008D0, "Member 'ACrabEnemyC::EnemySpawnFX' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EnemySpawnSound) == 0x0008D8, "Member 'ACrabEnemyC::EnemySpawnSound' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshNC) == 0x0008E0, "Member 'ACrabEnemyC::MeshNC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshFX) == 0x0008E8, "Member 'ACrabEnemyC::MeshFX' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshAC) == 0x0008F0, "Member 'ACrabEnemyC::MeshAC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshSound) == 0x0008F8, "Member 'ACrabEnemyC::MeshSound' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, MeshFXSocketName) == 0x000900, "Member 'ACrabEnemyC::MeshFXSocketName' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bIsLesserEnemy) == 0x000908, "Member 'ACrabEnemyC::bIsLesserEnemy' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, bHasBeenDamagedPastMaxHealth) == 0x000910, "Member 'ACrabEnemyC::bHasBeenDamagedPastMaxHealth' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, EliminatingC) == 0x000920, "Member 'ACrabEnemyC::EliminatingC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, ChanceToSpawnOnEliminatedEnemies) == 0x00092C, "Member 'ACrabEnemyC::ChanceToSpawnOnEliminatedEnemies' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, OnEliminatedEnemiesToSpawn) == 0x000930, "Member 'ACrabEnemyC::OnEliminatedEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, GibFX) == 0x000948, "Member 'ACrabEnemyC::GibFX' has a wrong offset!");
static_assert(offsetof(ACrabEnemyC, GibSound) == 0x000950, "Member 'ACrabEnemyC::GibSound' has a wrong offset!");

// Class CrabChampions.CrabBossC
// 0x0050 (0x09B0 - 0x0960)
class ACrabBossC : public ACrabEnemyC
{
public:
	uint8                                         Pad_1425[0x8];                                     // 0x0960(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        PotentialPhaseLesserEnemiesToSpawn;                // 0x0968(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         NumPhaseTwoLesserEnemiesToSpawn;                   // 0x0978(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPhaseThreeLesserEnemiesToSpawn;                 // 0x097C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1426[0x8];                                     // 0x0980(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabPS*>                        BossLootToSpawn;                                   // 0x0988(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1427[0x18];                                    // 0x0998(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBossC">();
	}
	static class ACrabBossC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabBossC>();
	}
};
static_assert(alignof(ACrabBossC) == 0x000010, "Wrong alignment on ACrabBossC");
static_assert(sizeof(ACrabBossC) == 0x0009B0, "Wrong size on ACrabBossC");
static_assert(offsetof(ACrabBossC, PotentialPhaseLesserEnemiesToSpawn) == 0x000968, "Member 'ACrabBossC::PotentialPhaseLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabBossC, NumPhaseTwoLesserEnemiesToSpawn) == 0x000978, "Member 'ACrabBossC::NumPhaseTwoLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabBossC, NumPhaseThreeLesserEnemiesToSpawn) == 0x00097C, "Member 'ACrabBossC::NumPhaseThreeLesserEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabBossC, BossLootToSpawn) == 0x000988, "Member 'ACrabBossC::BossLootToSpawn' has a wrong offset!");

// Class CrabChampions.CrabTargetDummyC
// 0x0030 (0x0990 - 0x0960)
class ACrabTargetDummyC : public ACrabEnemyC
{
public:
	class UWidgetComponent*                       DPSWC;                                             // 0x0960(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCrabDamageTextUI>          DPSWidgetClass;                                    // 0x0968(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DPSInterval;                                       // 0x0970(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1428[0x4];                                     // 0x0974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabDamageTextUI*                      DPSUI;                                             // 0x0978(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1429[0x4];                                     // 0x0980(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DPS;                                               // 0x0984(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142A[0x8];                                     // 0x0988(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DPS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabTargetDummyC">();
	}
	static class ACrabTargetDummyC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabTargetDummyC>();
	}
};
static_assert(alignof(ACrabTargetDummyC) == 0x000010, "Wrong alignment on ACrabTargetDummyC");
static_assert(sizeof(ACrabTargetDummyC) == 0x000990, "Wrong size on ACrabTargetDummyC");
static_assert(offsetof(ACrabTargetDummyC, DPSWC) == 0x000960, "Member 'ACrabTargetDummyC::DPSWC' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPSWidgetClass) == 0x000968, "Member 'ACrabTargetDummyC::DPSWidgetClass' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPSInterval) == 0x000970, "Member 'ACrabTargetDummyC::DPSInterval' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPSUI) == 0x000978, "Member 'ACrabTargetDummyC::DPSUI' has a wrong offset!");
static_assert(offsetof(ACrabTargetDummyC, DPS) == 0x000984, "Member 'ACrabTargetDummyC::DPS' has a wrong offset!");

// Class CrabChampions.CrabCheckpoint
// 0x0030 (0x0250 - 0x0220)
class ACrabCheckpoint final : public AActor
{
public:
	uint8                                         Pad_142B[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CheckpointCollision;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CheckpointNC;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         CheckpointFX;                                      // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFinalCheckpoint;                                // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142C[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              CheckpointActiveSound;                             // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCheckpoint">();
	}
	static class ACrabCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCheckpoint>();
	}
};
static_assert(alignof(ACrabCheckpoint) == 0x000008, "Wrong alignment on ACrabCheckpoint");
static_assert(sizeof(ACrabCheckpoint) == 0x000250, "Wrong size on ACrabCheckpoint");
static_assert(offsetof(ACrabCheckpoint, CheckpointCollision) == 0x000228, "Member 'ACrabCheckpoint::CheckpointCollision' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, CheckpointNC) == 0x000230, "Member 'ACrabCheckpoint::CheckpointNC' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, CheckpointFX) == 0x000238, "Member 'ACrabCheckpoint::CheckpointFX' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, bIsFinalCheckpoint) == 0x000240, "Member 'ACrabCheckpoint::bIsFinalCheckpoint' has a wrong offset!");
static_assert(offsetof(ACrabCheckpoint, CheckpointActiveSound) == 0x000248, "Member 'ACrabCheckpoint::CheckpointActiveSound' has a wrong offset!");

// Class CrabChampions.CrabCosmeticC
// 0x0048 (0x0268 - 0x0220)
class ACrabCosmeticC : public AActor
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WeaponMesh;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          MeshToSpawn;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              AnimationBlueprintToUse;                           // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            WeaponMeshToSpawn;                                 // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           OnEquippedNewCrabSkinMontage;                      // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CrabSkin;                                          // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           OnEquippedNewWeaponSkinMontage;                    // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     WeaponSkin;                                        // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticC">();
	}
	static class ACrabCosmeticC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCosmeticC>();
	}
};
static_assert(alignof(ACrabCosmeticC) == 0x000008, "Wrong alignment on ACrabCosmeticC");
static_assert(sizeof(ACrabCosmeticC) == 0x000268, "Wrong size on ACrabCosmeticC");
static_assert(offsetof(ACrabCosmeticC, Mesh) == 0x000220, "Member 'ACrabCosmeticC::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, WeaponMesh) == 0x000228, "Member 'ACrabCosmeticC::WeaponMesh' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, MeshToSpawn) == 0x000230, "Member 'ACrabCosmeticC::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, AnimationBlueprintToUse) == 0x000238, "Member 'ACrabCosmeticC::AnimationBlueprintToUse' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, WeaponMeshToSpawn) == 0x000240, "Member 'ACrabCosmeticC::WeaponMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, OnEquippedNewCrabSkinMontage) == 0x000248, "Member 'ACrabCosmeticC::OnEquippedNewCrabSkinMontage' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, CrabSkin) == 0x000250, "Member 'ACrabCosmeticC::CrabSkin' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, OnEquippedNewWeaponSkinMontage) == 0x000258, "Member 'ACrabCosmeticC::OnEquippedNewWeaponSkinMontage' has a wrong offset!");
static_assert(offsetof(ACrabCosmeticC, WeaponSkin) == 0x000260, "Member 'ACrabCosmeticC::WeaponSkin' has a wrong offset!");

// Class CrabChampions.CrabCosmeticsDA
// 0x0010 (0x0040 - 0x0030)
class UCrabCosmeticsDA final : public UDataAsset
{
public:
	TArray<struct FCrabCosmetic>                  CrabSkins;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticsDA">();
	}
	static class UCrabCosmeticsDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCosmeticsDA>();
	}
};
static_assert(alignof(UCrabCosmeticsDA) == 0x000008, "Wrong alignment on UCrabCosmeticsDA");
static_assert(sizeof(UCrabCosmeticsDA) == 0x000040, "Wrong size on UCrabCosmeticsDA");
static_assert(offsetof(UCrabCosmeticsDA, CrabSkins) == 0x000030, "Member 'UCrabCosmeticsDA::CrabSkins' has a wrong offset!");

// Class CrabChampions.CrabDamageTextUI
// 0x0018 (0x0278 - 0x0260)
class UCrabDamageTextUI : public UUserWidget
{
public:
	class UScaleBox*                              DamageTextScaleBox;                                // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DamageText;                                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       DamageTextAnim;                                    // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageTextUI">();
	}
	static class UCrabDamageTextUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabDamageTextUI>();
	}
};
static_assert(alignof(UCrabDamageTextUI) == 0x000008, "Wrong alignment on UCrabDamageTextUI");
static_assert(sizeof(UCrabDamageTextUI) == 0x000278, "Wrong size on UCrabDamageTextUI");
static_assert(offsetof(UCrabDamageTextUI, DamageTextScaleBox) == 0x000260, "Member 'UCrabDamageTextUI::DamageTextScaleBox' has a wrong offset!");
static_assert(offsetof(UCrabDamageTextUI, DamageText) == 0x000268, "Member 'UCrabDamageTextUI::DamageText' has a wrong offset!");
static_assert(offsetof(UCrabDamageTextUI, DamageTextAnim) == 0x000270, "Member 'UCrabDamageTextUI::DamageTextAnim' has a wrong offset!");

// Class CrabChampions.CrabEnemyAIC
// 0x0098 (0x03C0 - 0x0328)
class ACrabEnemyAIC final : public AAIController
{
public:
	struct FCrabAISettings                        AISettings;                                        // 0x0328(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_142D[0x8];                                     // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabEnemyC*                            OwnedC;                                            // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142E[0x8];                                     // 0x0360(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 BestEnemyC;                                        // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142F[0x38];                                    // 0x0370(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              RangedActionEnvQuery;                              // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1430[0x10];                                    // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyAIC">();
	}
	static class ACrabEnemyAIC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabEnemyAIC>();
	}
};
static_assert(alignof(ACrabEnemyAIC) == 0x000008, "Wrong alignment on ACrabEnemyAIC");
static_assert(sizeof(ACrabEnemyAIC) == 0x0003C0, "Wrong size on ACrabEnemyAIC");
static_assert(offsetof(ACrabEnemyAIC, AISettings) == 0x000328, "Member 'ACrabEnemyAIC::AISettings' has a wrong offset!");
static_assert(offsetof(ACrabEnemyAIC, OwnedC) == 0x000358, "Member 'ACrabEnemyAIC::OwnedC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyAIC, BestEnemyC) == 0x000368, "Member 'ACrabEnemyAIC::BestEnemyC' has a wrong offset!");
static_assert(offsetof(ACrabEnemyAIC, RangedActionEnvQuery) == 0x0003A8, "Member 'ACrabEnemyAIC::RangedActionEnvQuery' has a wrong offset!");

// Class CrabChampions.CrabDamageArea
// 0x00E8 (0x0308 - 0x0220)
class ACrabDamageArea : public AActor
{
public:
	class UNiagaraComponent*                      DamageAreaNC;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        DamageAreaAC;                                      // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignToGround;                                    // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageAreaType                           DamageAreaType;                                    // 0x0231(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1432[0x2];                                     // 0x0232(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0234(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1433[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMat;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0258(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1434[0x8];                                     // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0268(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FCrabDamageInfo                        DamageInfo;                                        // 0x0278(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               DamageType;                                        // 0x02B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1435[0x3];                                     // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            Debuff;                                            // 0x02B8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DamageInterval;                                    // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1436[0xC];                                     // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabPlayerC*>                   DamagedPlayers;                                    // 0x02D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1437[0x8];                                     // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabC*>                         OverlappingCharacters;                             // 0x02E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         EnergyRingSpeed;                                   // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1438[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuctionForce;                                      // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1439[0x4];                                     // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Radius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageArea">();
	}
	static class ACrabDamageArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabDamageArea>();
	}
};
static_assert(alignof(ACrabDamageArea) == 0x000008, "Wrong alignment on ACrabDamageArea");
static_assert(sizeof(ACrabDamageArea) == 0x000308, "Wrong size on ACrabDamageArea");
static_assert(offsetof(ACrabDamageArea, DamageAreaNC) == 0x000220, "Member 'ACrabDamageArea::DamageAreaNC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageAreaAC) == 0x000228, "Member 'ACrabDamageArea::DamageAreaAC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, bAlignToGround) == 0x000230, "Member 'ACrabDamageArea::bAlignToGround' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageAreaType) == 0x000231, "Member 'ACrabDamageArea::DamageAreaType' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Radius) == 0x000234, "Member 'ACrabDamageArea::Radius' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, LifeTime) == 0x000238, "Member 'ACrabDamageArea::LifeTime' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, FX) == 0x000240, "Member 'ACrabDamageArea::FX' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Sound) == 0x000248, "Member 'ACrabDamageArea::Sound' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DecalMat) == 0x000250, "Member 'ACrabDamageArea::DecalMat' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, OwningC) == 0x000258, "Member 'ACrabDamageArea::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, ActorsToIgnore) == 0x000268, "Member 'ACrabDamageArea::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageInfo) == 0x000278, "Member 'ACrabDamageArea::DamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Damage) == 0x0002B0, "Member 'ACrabDamageArea::Damage' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageType) == 0x0002B4, "Member 'ACrabDamageArea::DamageType' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, Debuff) == 0x0002B8, "Member 'ACrabDamageArea::Debuff' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamageInterval) == 0x0002C0, "Member 'ACrabDamageArea::DamageInterval' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, DamagedPlayers) == 0x0002D0, "Member 'ACrabDamageArea::DamagedPlayers' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, OverlappingCharacters) == 0x0002E8, "Member 'ACrabDamageArea::OverlappingCharacters' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, EnergyRingSpeed) == 0x0002F8, "Member 'ACrabDamageArea::EnergyRingSpeed' has a wrong offset!");
static_assert(offsetof(ACrabDamageArea, SuctionForce) == 0x000300, "Member 'ACrabDamageArea::SuctionForce' has a wrong offset!");

// Class CrabChampions.CrabEnemyEQC
// 0x0008 (0x0030 - 0x0028)
class UCrabEnemyEQC : public UEnvQueryContext
{
public:
	ECrabEQCType                                  EQCType;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143A[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyEQC">();
	}
	static class UCrabEnemyEQC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabEnemyEQC>();
	}
};
static_assert(alignof(UCrabEnemyEQC) == 0x000008, "Wrong alignment on UCrabEnemyEQC");
static_assert(sizeof(UCrabEnemyEQC) == 0x000030, "Wrong size on UCrabEnemyEQC");
static_assert(offsetof(UCrabEnemyEQC, EQCType) == 0x000028, "Member 'UCrabEnemyEQC::EQCType' has a wrong offset!");

// Class CrabChampions.CrabPlayerC
// 0x03A0 (0x0AC0 - 0x0720)
class ACrabPlayerC : public ACrabC
{
public:
	class USpringArmComponent*                    CameraSpringArm;                                   // 0x0718(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera;                                            // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeleeMesh;                                         // 0x0728(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CosmeticMesh;                                      // 0x0730(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PlayerNameWC;                                      // 0x0738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PingWC;                                            // 0x0740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      SlideNC;                                           // 0x0748(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        SlideAC;                                           // 0x0750(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      AmbienceNC;                                        // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      UnderwaterNC;                                      // 0x0760(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143B[0x48];                                    // 0x0768(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBananaActive;                                   // 0x07B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143C[0x7];                                     // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x07B8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x07C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CrabSkin;                                          // 0x07C8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CosmeticToSpawn;                                   // 0x07D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143D[0x8];                                     // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOverlapResult>                 NearbyActors;                                      // 0x07E0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         OverlapSearchRadius;                               // 0x07F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143E[0x4];                                     // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabInteractable*                      BestInteractable;                                  // 0x07F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143F[0x8];                                     // 0x0800(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCrabPlayerNameUI>          PlayerNameUIToSpawn;                               // 0x0808(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabPingUI>                PingUIToSpawn;                                     // 0x0810(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         AmbientFX;                                         // 0x0818(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPC*                                OwningPC;                                          // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1440[0x10];                                    // 0x0828(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             InteractControllerIcon;                            // 0x0838(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1441[0x10];                                    // 0x0840(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SalvageControllerIcon;                             // 0x0850(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1442[0xC];                                     // 0x0858(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultSpringArmOffset;                            // 0x0864(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1443[0xC];                                     // 0x0870(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingSpringArmZOffset;                           // 0x087C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1444[0xC];                                     // 0x0880(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistRadius;                                   // 0x088C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistSpeed;                                    // 0x0890(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1445[0x4];                                     // 0x0894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AimAssistTarget;                                   // 0x0898(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1446[0x10];                                    // 0x08A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FlipMontageF;                                      // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlipMontageB;                                      // 0x08B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlipMontageR;                                      // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FlipMontageL;                                      // 0x08C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlipSpeed;                                         // 0x08D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlipHeight;                                        // 0x08D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1447[0x8];                                     // 0x08D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopFlipDelay;                                     // 0x08E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostFlipVelocityMultiplier;                        // 0x08E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1448[0xC];                                     // 0x08E8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDashCooldown;                                  // 0x08F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageF;                                      // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageB;                                      // 0x0900(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageR;                                      // 0x0908(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DashMontageL;                                      // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashSpeed;                                         // 0x0918(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashHeight;                                        // 0x091C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostDashVelocityMultiplier;                        // 0x0920(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1449[0x4];                                     // 0x0924(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         DashBlockedDamageFX;                               // 0x0928(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DashBlockedDamageSound;                            // 0x0930(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144A[0x19];                                    // 0x0938(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSliding;                                        // 0x0951(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144B[0x6];                                     // 0x0952(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SlideSpeedCurve;                                   // 0x0958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144C[0x8];                                     // 0x0960(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         IceSlideFX;                                        // 0x0968(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              IceSlideSound;                                     // 0x0970(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         RockSlideFX;                                       // 0x0978(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              RockSlideSound;                                    // 0x0980(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         SandSlideFX;                                       // 0x0988(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SandSlideSound;                                    // 0x0990(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideMaxAcceleration;                              // 0x0998(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideBrakingFrictionFactor;                        // 0x099C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideGroundFriction;                               // 0x09A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144D[0xC];                                     // 0x09A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlideDamageIteration;                              // 0x09B0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAiming;                                         // 0x09B4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144E[0xB];                                     // 0x09B5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AimingMontage;                                     // 0x09C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              StartAimSound;                                     // 0x09C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              StopAimSound;                                      // 0x09D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144F[0x30];                                    // 0x09D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           InteractMontage;                                   // 0x0A08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              InteractFailureSound;                              // 0x0A10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabInteractPickup*                    PendingPickupToSalvage;                            // 0x0A18(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1450[0x10];                                    // 0x0A20(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabChest*>                     ChestsToAutoLoot;                                  // 0x0A30(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1451[0x8];                                     // 0x0A40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    PingLoc;                                           // 0x0A48(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1452[0x4];                                     // 0x0A54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              PingSound;                                         // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1453[0x10];                                    // 0x0A60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PrePortalFX;                                       // 0x0A70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PrePortalSound;                                    // 0x0A78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PostPortalFX;                                      // 0x0A80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              PostPortalSound;                                   // 0x0A88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1454[0x14];                                    // 0x0A90(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	ECrabPerkType                                 CurrentTriggeredPerk;                              // 0x0AA4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1455[0x1B];                                    // 0x0AA5(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientDashBlockedDamage();
	void ClientOnTriggeredRingOfDestruction();
	void ClientPostPortal();
	void ClientPrePortal(class ACrabPortal* Portal);
	void ClientTeleport(const struct FVector_NetQuantize& Loc, float Yaw);
	void MulticastDash(ECrabInputDir DashDir);
	void MulticastFlip(ECrabInputDir FlipDir);
	void MulticastHideStalePing();
	void MulticastInteract();
	void MulticastMelee();
	void MulticastThrowGrenade();
	void OnRep_AbilityDA();
	void OnRep_CrabSkin();
	void OnRep_CurrentTriggeredPerk();
	void OnRep_IsAiming();
	void OnRep_IsBananaActive();
	void OnRep_IsSliding();
	void OnRep_MeleeDA();
	void OnRep_PingLoc(const struct FVector_NetQuantize& PreviousPingLoc);
	void OnRep_SlideDamageIteration();
	void ServerAutoLoot();
	void ServerDash(ECrabInputDir DashDir);
	void ServerDealFallDamage();
	void ServerDropPickup(class UCrabPickupDA* PickupDA, const struct FCrabInventoryInfo& InventoryInfo);
	void ServerFlip(ECrabInputDir FlipDir);
	void ServerInteract(class ACrabInteractable* ActorToInteractWith);
	void ServerMelee();
	void ServerPing(const struct FVector_NetQuantize& InPingLoc);
	void ServerSalvage(class ACrabInteractPickup* PickupToSalvage);
	void ServerStartAim();
	void ServerStartSlide();
	void ServerStopAim();
	void ServerStopSlide();
	void ServerThrowGrenade();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerC">();
	}
	static class ACrabPlayerC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPlayerC>();
	}
};
static_assert(alignof(ACrabPlayerC) == 0x000010, "Wrong alignment on ACrabPlayerC");
static_assert(sizeof(ACrabPlayerC) == 0x000AC0, "Wrong size on ACrabPlayerC");
static_assert(offsetof(ACrabPlayerC, CameraSpringArm) == 0x000718, "Member 'ACrabPlayerC::CameraSpringArm' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, Camera) == 0x000720, "Member 'ACrabPlayerC::Camera' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, MeleeMesh) == 0x000728, "Member 'ACrabPlayerC::MeleeMesh' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CosmeticMesh) == 0x000730, "Member 'ACrabPlayerC::CosmeticMesh' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PlayerNameWC) == 0x000738, "Member 'ACrabPlayerC::PlayerNameWC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingWC) == 0x000740, "Member 'ACrabPlayerC::PingWC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideNC) == 0x000748, "Member 'ACrabPlayerC::SlideNC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideAC) == 0x000750, "Member 'ACrabPlayerC::SlideAC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AmbienceNC) == 0x000758, "Member 'ACrabPlayerC::AmbienceNC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, UnderwaterNC) == 0x000760, "Member 'ACrabPlayerC::UnderwaterNC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, bIsBananaActive) == 0x0007B0, "Member 'ACrabPlayerC::bIsBananaActive' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AbilityDA) == 0x0007B8, "Member 'ACrabPlayerC::AbilityDA' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, MeleeDA) == 0x0007C0, "Member 'ACrabPlayerC::MeleeDA' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CrabSkin) == 0x0007C8, "Member 'ACrabPlayerC::CrabSkin' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CosmeticToSpawn) == 0x0007D0, "Member 'ACrabPlayerC::CosmeticToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, NearbyActors) == 0x0007E0, "Member 'ACrabPlayerC::NearbyActors' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, OverlapSearchRadius) == 0x0007F0, "Member 'ACrabPlayerC::OverlapSearchRadius' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, BestInteractable) == 0x0007F8, "Member 'ACrabPlayerC::BestInteractable' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PlayerNameUIToSpawn) == 0x000808, "Member 'ACrabPlayerC::PlayerNameUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingUIToSpawn) == 0x000810, "Member 'ACrabPlayerC::PingUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AmbientFX) == 0x000818, "Member 'ACrabPlayerC::AmbientFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, OwningPC) == 0x000820, "Member 'ACrabPlayerC::OwningPC' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, InteractControllerIcon) == 0x000838, "Member 'ACrabPlayerC::InteractControllerIcon' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SalvageControllerIcon) == 0x000850, "Member 'ACrabPlayerC::SalvageControllerIcon' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DefaultSpringArmOffset) == 0x000864, "Member 'ACrabPlayerC::DefaultSpringArmOffset' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FallingSpringArmZOffset) == 0x00087C, "Member 'ACrabPlayerC::FallingSpringArmZOffset' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimAssistRadius) == 0x00088C, "Member 'ACrabPlayerC::AimAssistRadius' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimAssistSpeed) == 0x000890, "Member 'ACrabPlayerC::AimAssistSpeed' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimAssistTarget) == 0x000898, "Member 'ACrabPlayerC::AimAssistTarget' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageF) == 0x0008B0, "Member 'ACrabPlayerC::FlipMontageF' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageB) == 0x0008B8, "Member 'ACrabPlayerC::FlipMontageB' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageR) == 0x0008C0, "Member 'ACrabPlayerC::FlipMontageR' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipMontageL) == 0x0008C8, "Member 'ACrabPlayerC::FlipMontageL' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipSpeed) == 0x0008D0, "Member 'ACrabPlayerC::FlipSpeed' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, FlipHeight) == 0x0008D4, "Member 'ACrabPlayerC::FlipHeight' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, StopFlipDelay) == 0x0008E0, "Member 'ACrabPlayerC::StopFlipDelay' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostFlipVelocityMultiplier) == 0x0008E4, "Member 'ACrabPlayerC::PostFlipVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, BaseDashCooldown) == 0x0008F4, "Member 'ACrabPlayerC::BaseDashCooldown' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageF) == 0x0008F8, "Member 'ACrabPlayerC::DashMontageF' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageB) == 0x000900, "Member 'ACrabPlayerC::DashMontageB' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageR) == 0x000908, "Member 'ACrabPlayerC::DashMontageR' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashMontageL) == 0x000910, "Member 'ACrabPlayerC::DashMontageL' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashSpeed) == 0x000918, "Member 'ACrabPlayerC::DashSpeed' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashHeight) == 0x00091C, "Member 'ACrabPlayerC::DashHeight' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostDashVelocityMultiplier) == 0x000920, "Member 'ACrabPlayerC::PostDashVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashBlockedDamageFX) == 0x000928, "Member 'ACrabPlayerC::DashBlockedDamageFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, DashBlockedDamageSound) == 0x000930, "Member 'ACrabPlayerC::DashBlockedDamageSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, bIsSliding) == 0x000951, "Member 'ACrabPlayerC::bIsSliding' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideSpeedCurve) == 0x000958, "Member 'ACrabPlayerC::SlideSpeedCurve' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, IceSlideFX) == 0x000968, "Member 'ACrabPlayerC::IceSlideFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, IceSlideSound) == 0x000970, "Member 'ACrabPlayerC::IceSlideSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, RockSlideFX) == 0x000978, "Member 'ACrabPlayerC::RockSlideFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, RockSlideSound) == 0x000980, "Member 'ACrabPlayerC::RockSlideSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SandSlideFX) == 0x000988, "Member 'ACrabPlayerC::SandSlideFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SandSlideSound) == 0x000990, "Member 'ACrabPlayerC::SandSlideSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideMaxAcceleration) == 0x000998, "Member 'ACrabPlayerC::SlideMaxAcceleration' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideBrakingFrictionFactor) == 0x00099C, "Member 'ACrabPlayerC::SlideBrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideGroundFriction) == 0x0009A0, "Member 'ACrabPlayerC::SlideGroundFriction' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, SlideDamageIteration) == 0x0009B0, "Member 'ACrabPlayerC::SlideDamageIteration' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, bIsAiming) == 0x0009B4, "Member 'ACrabPlayerC::bIsAiming' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, AimingMontage) == 0x0009C0, "Member 'ACrabPlayerC::AimingMontage' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, StartAimSound) == 0x0009C8, "Member 'ACrabPlayerC::StartAimSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, StopAimSound) == 0x0009D0, "Member 'ACrabPlayerC::StopAimSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, InteractMontage) == 0x000A08, "Member 'ACrabPlayerC::InteractMontage' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, InteractFailureSound) == 0x000A10, "Member 'ACrabPlayerC::InteractFailureSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PendingPickupToSalvage) == 0x000A18, "Member 'ACrabPlayerC::PendingPickupToSalvage' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, ChestsToAutoLoot) == 0x000A30, "Member 'ACrabPlayerC::ChestsToAutoLoot' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingLoc) == 0x000A48, "Member 'ACrabPlayerC::PingLoc' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PingSound) == 0x000A58, "Member 'ACrabPlayerC::PingSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PrePortalFX) == 0x000A70, "Member 'ACrabPlayerC::PrePortalFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PrePortalSound) == 0x000A78, "Member 'ACrabPlayerC::PrePortalSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostPortalFX) == 0x000A80, "Member 'ACrabPlayerC::PostPortalFX' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, PostPortalSound) == 0x000A88, "Member 'ACrabPlayerC::PostPortalSound' has a wrong offset!");
static_assert(offsetof(ACrabPlayerC, CurrentTriggeredPerk) == 0x000AA4, "Member 'ACrabPlayerC::CurrentTriggeredPerk' has a wrong offset!");

// Class CrabChampions.CrabDestructible
// 0x01C0 (0x03E0 - 0x0220)
class ACrabDestructible : public AActor
{
public:
	uint8                                         Pad_1456[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LeakAC;                                            // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabHC*                                HC;                                                // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ECrabIslandType>                       BannedIslandTypes;                                 // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpawnWeight;                                       // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1457[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            MeshToSpawn;                                       // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshMat;                                           // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MeshFX;                                            // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MeshNC;                                            // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       HealthBarWC;                                       // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabHealthBarUI>           HealthBarUIToSpawn;                                // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreCharacterCollision;                         // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               ImmuneDamageType;                                  // 0x0299(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleMaxHealthByIsland;                           // 0x029A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1458[0x1];                                     // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinScale;                                          // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScale;                                          // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleMultiplier;                                   // 0x02A4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1459[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProximityExplosionOverlapRadius;                   // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProximityExplosionDelay;                           // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsProximityExplosionTriggered;                    // 0x02C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145A[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ProximityExplosionTriggeredFX;                     // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ProximityExplosionTriggeredSound;                  // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145B[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPhysicallySimulated;                            // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145C[0x3];                                     // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsMassScale;                                  // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsLinearDamping;                              // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PhysicsImpulseMultiplier;                          // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChaoticPhysicsMovement;                           // 0x02F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145D[0x3];                                     // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicsHomingScale;                                // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 HomingTarget;                                      // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145E[0x10];                                    // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 DamagingC;                                         // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_145F[0x8];                                     // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        PotentialNestEnemiesToSpawn;                       // 0x0320(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1460[0x4];                                     // 0x0330(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanLeak;                                          // 0x0334(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1461[0xB];                                     // 0x0335(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         LeakFX;                                            // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LeakSound;                                         // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              Leaks;                                             // 0x0350(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1462[0x14];                                    // 0x0360(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionRadius;                                   // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScaleExplosionDamageByIsland;                     // 0x0378(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1463[0x3];                                     // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDamage;                                   // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               ExplosionDamageType;                               // 0x0380(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1464[0x3];                                     // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            ExplosionDebuff;                                   // 0x0384(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ExplosionKnockbackStrength;                        // 0x038C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawn;                                 // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabRarity                                   CrystalsToSpawnRarity;                             // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1465[0x3];                                     // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToSpawnRandomPickup;                         // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACrabEnemyC>>        PotentialChallengeEnemiesToSpawn;                  // 0x03A0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         ChanceToSpawnChallengeEnemies;                     // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinChallengeEnemiesToSpawn;                        // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxChallengeEnemiesToSpawn;                        // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1466[0x4];                                     // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabProjectileDA*                      SecondaryProjectileToSpawn;                        // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSecondaryProjectilesToSpawn;                    // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1467[0x4];                                     // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastAddLeak(const struct FVector_NetQuantize& DamageLoc);
	void MulticastExplode(class ACrabC* ExplodingC);
	void OnRep_IsProximityExplosionTriggered();
	void OnRep_ScaleMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDestructible">();
	}
	static class ACrabDestructible* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabDestructible>();
	}
};
static_assert(alignof(ACrabDestructible) == 0x000008, "Wrong alignment on ACrabDestructible");
static_assert(sizeof(ACrabDestructible) == 0x0003E0, "Wrong size on ACrabDestructible");
static_assert(offsetof(ACrabDestructible, Mesh) == 0x000228, "Member 'ACrabDestructible::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, LeakAC) == 0x000230, "Member 'ACrabDestructible::LeakAC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HC) == 0x000238, "Member 'ACrabDestructible::HC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, BannedIslandTypes) == 0x000240, "Member 'ACrabDestructible::BannedIslandTypes' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, SpawnWeight) == 0x000250, "Member 'ACrabDestructible::SpawnWeight' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshToSpawn) == 0x000258, "Member 'ACrabDestructible::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshMat) == 0x000260, "Member 'ACrabDestructible::MeshMat' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshFX) == 0x000268, "Member 'ACrabDestructible::MeshFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MeshNC) == 0x000270, "Member 'ACrabDestructible::MeshNC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, Tint) == 0x000278, "Member 'ACrabDestructible::Tint' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HealthBarWC) == 0x000288, "Member 'ACrabDestructible::HealthBarWC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HealthBarUIToSpawn) == 0x000290, "Member 'ACrabDestructible::HealthBarUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bIgnoreCharacterCollision) == 0x000298, "Member 'ACrabDestructible::bIgnoreCharacterCollision' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ImmuneDamageType) == 0x000299, "Member 'ACrabDestructible::ImmuneDamageType' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bScaleMaxHealthByIsland) == 0x00029A, "Member 'ACrabDestructible::bScaleMaxHealthByIsland' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MinScale) == 0x00029C, "Member 'ACrabDestructible::MinScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MaxScale) == 0x0002A0, "Member 'ACrabDestructible::MaxScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ScaleMultiplier) == 0x0002A4, "Member 'ACrabDestructible::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionOverlapRadius) == 0x0002B8, "Member 'ACrabDestructible::ProximityExplosionOverlapRadius' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionDelay) == 0x0002BC, "Member 'ACrabDestructible::ProximityExplosionDelay' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bIsProximityExplosionTriggered) == 0x0002C0, "Member 'ACrabDestructible::bIsProximityExplosionTriggered' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionTriggeredFX) == 0x0002C8, "Member 'ACrabDestructible::ProximityExplosionTriggeredFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ProximityExplosionTriggeredSound) == 0x0002D0, "Member 'ACrabDestructible::ProximityExplosionTriggeredSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bIsPhysicallySimulated) == 0x0002E0, "Member 'ACrabDestructible::bIsPhysicallySimulated' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsMassScale) == 0x0002E4, "Member 'ACrabDestructible::PhysicsMassScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsLinearDamping) == 0x0002E8, "Member 'ACrabDestructible::PhysicsLinearDamping' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsImpulseMultiplier) == 0x0002EC, "Member 'ACrabDestructible::PhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bChaoticPhysicsMovement) == 0x0002F0, "Member 'ACrabDestructible::bChaoticPhysicsMovement' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PhysicsHomingScale) == 0x0002F4, "Member 'ACrabDestructible::PhysicsHomingScale' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, HomingTarget) == 0x0002F8, "Member 'ACrabDestructible::HomingTarget' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, DamagingC) == 0x000310, "Member 'ACrabDestructible::DamagingC' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PotentialNestEnemiesToSpawn) == 0x000320, "Member 'ACrabDestructible::PotentialNestEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bCanLeak) == 0x000334, "Member 'ACrabDestructible::bCanLeak' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, LeakFX) == 0x000340, "Member 'ACrabDestructible::LeakFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, LeakSound) == 0x000348, "Member 'ACrabDestructible::LeakSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, Leaks) == 0x000350, "Member 'ACrabDestructible::Leaks' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionRadius) == 0x000374, "Member 'ACrabDestructible::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, bScaleExplosionDamageByIsland) == 0x000378, "Member 'ACrabDestructible::bScaleExplosionDamageByIsland' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionDamage) == 0x00037C, "Member 'ACrabDestructible::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionDamageType) == 0x000380, "Member 'ACrabDestructible::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionDebuff) == 0x000384, "Member 'ACrabDestructible::ExplosionDebuff' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionKnockbackStrength) == 0x00038C, "Member 'ACrabDestructible::ExplosionKnockbackStrength' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, DamageAreaToSpawn) == 0x000390, "Member 'ACrabDestructible::DamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, CrystalsToSpawnRarity) == 0x000398, "Member 'ACrabDestructible::CrystalsToSpawnRarity' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ChanceToSpawnRandomPickup) == 0x00039C, "Member 'ACrabDestructible::ChanceToSpawnRandomPickup' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, PotentialChallengeEnemiesToSpawn) == 0x0003A0, "Member 'ACrabDestructible::PotentialChallengeEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ChanceToSpawnChallengeEnemies) == 0x0003B0, "Member 'ACrabDestructible::ChanceToSpawnChallengeEnemies' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MinChallengeEnemiesToSpawn) == 0x0003B4, "Member 'ACrabDestructible::MinChallengeEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, MaxChallengeEnemiesToSpawn) == 0x0003B8, "Member 'ACrabDestructible::MaxChallengeEnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionFX) == 0x0003C0, "Member 'ACrabDestructible::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, ExplosionSound) == 0x0003C8, "Member 'ACrabDestructible::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, SecondaryProjectileToSpawn) == 0x0003D0, "Member 'ACrabDestructible::SecondaryProjectileToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabDestructible, NumSecondaryProjectilesToSpawn) == 0x0003D8, "Member 'ACrabDestructible::NumSecondaryProjectilesToSpawn' has a wrong offset!");

// Class CrabChampions.CrabHarvestArea
// 0x0058 (0x0278 - 0x0220)
class ACrabHarvestArea : public AActor
{
public:
	class USphereComponent*                       HarvestAreaCollision;                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      HarvestAreaNC;                                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HarvestAreaFX;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialCountdown;                                  // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1468[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabPlayerC*                           OverlappingPlayerC;                                // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1469[0x8];                                     // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         HarvestCountdownFX;                                // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HarvestCountdownSound;                             // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         HarvestClearFX;                                    // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              HarvestClearSound;                                 // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MulticastOnCountdownDecremented();
	void MulticastOnHarvestAreaCleared();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHarvestArea">();
	}
	static class ACrabHarvestArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabHarvestArea>();
	}
};
static_assert(alignof(ACrabHarvestArea) == 0x000008, "Wrong alignment on ACrabHarvestArea");
static_assert(sizeof(ACrabHarvestArea) == 0x000278, "Wrong size on ACrabHarvestArea");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaCollision) == 0x000220, "Member 'ACrabHarvestArea::HarvestAreaCollision' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaNC) == 0x000228, "Member 'ACrabHarvestArea::HarvestAreaNC' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestAreaFX) == 0x000230, "Member 'ACrabHarvestArea::HarvestAreaFX' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, Radius) == 0x000238, "Member 'ACrabHarvestArea::Radius' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, InitialCountdown) == 0x00023C, "Member 'ACrabHarvestArea::InitialCountdown' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, OverlappingPlayerC) == 0x000248, "Member 'ACrabHarvestArea::OverlappingPlayerC' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestCountdownFX) == 0x000258, "Member 'ACrabHarvestArea::HarvestCountdownFX' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestCountdownSound) == 0x000260, "Member 'ACrabHarvestArea::HarvestCountdownSound' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestClearFX) == 0x000268, "Member 'ACrabHarvestArea::HarvestClearFX' has a wrong offset!");
static_assert(offsetof(ACrabHarvestArea, HarvestClearSound) == 0x000270, "Member 'ACrabHarvestArea::HarvestClearSound' has a wrong offset!");

// Class CrabChampions.CrabInteractable
// 0x0058 (0x0278 - 0x0220)
class ACrabInteractable : public AActor
{
public:
	class USphereComponent*                       InteractableCollision;                             // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       InteractWC;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInteractUI>            InteractUIToSpawn;                                 // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInteractUI*                        InteractUI;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractUIHeightOffset;                            // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146A[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractMessage;                                   // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146B[0x4];                                     // 0x0258(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractCooldown;                                  // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146C[0x18];                                    // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInteractable">();
	}
	static class ACrabInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabInteractable>();
	}
};
static_assert(alignof(ACrabInteractable) == 0x000008, "Wrong alignment on ACrabInteractable");
static_assert(sizeof(ACrabInteractable) == 0x000278, "Wrong size on ACrabInteractable");
static_assert(offsetof(ACrabInteractable, InteractableCollision) == 0x000220, "Member 'ACrabInteractable::InteractableCollision' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractWC) == 0x000228, "Member 'ACrabInteractable::InteractWC' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractUIToSpawn) == 0x000230, "Member 'ACrabInteractable::InteractUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractUI) == 0x000238, "Member 'ACrabInteractable::InteractUI' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractUIHeightOffset) == 0x000240, "Member 'ACrabInteractable::InteractUIHeightOffset' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractMessage) == 0x000248, "Member 'ACrabInteractable::InteractMessage' has a wrong offset!");
static_assert(offsetof(ACrabInteractable, InteractCooldown) == 0x00025C, "Member 'ACrabInteractable::InteractCooldown' has a wrong offset!");

// Class CrabChampions.CrabCrown
// 0x0030 (0x02A8 - 0x0278)
class ACrabCrown final : public ACrabInteractable
{
public:
	class UStaticMeshComponent*                   CrownMesh;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CrownNC;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CrownAC;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Mesh;                                              // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCrown">();
	}
	static class ACrabCrown* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCrown>();
	}
};
static_assert(alignof(ACrabCrown) == 0x000008, "Wrong alignment on ACrabCrown");
static_assert(sizeof(ACrabCrown) == 0x0002A8, "Wrong size on ACrabCrown");
static_assert(offsetof(ACrabCrown, CrownMesh) == 0x000278, "Member 'ACrabCrown::CrownMesh' has a wrong offset!");
static_assert(offsetof(ACrabCrown, CrownNC) == 0x000280, "Member 'ACrabCrown::CrownNC' has a wrong offset!");
static_assert(offsetof(ACrabCrown, CrownAC) == 0x000288, "Member 'ACrabCrown::CrownAC' has a wrong offset!");
static_assert(offsetof(ACrabCrown, Mesh) == 0x000290, "Member 'ACrabCrown::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabCrown, FX) == 0x000298, "Member 'ACrabCrown::FX' has a wrong offset!");
static_assert(offsetof(ACrabCrown, Sound) == 0x0002A0, "Member 'ACrabCrown::Sound' has a wrong offset!");

// Class CrabChampions.CrabInteractPickup
// 0x0098 (0x0310 - 0x0278)
class ACrabInteractPickup : public ACrabInteractable
{
public:
	class UNiagaraComponent*                      PickupPrimaryNC;                                   // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PickupSecondaryNC;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PickupLocationWC;                                  // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabPickupInfo                        PickupInfo;                                        // 0x0290(0x0058)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_146D[0x20];                                    // 0x02E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         NumTimesPickedUp;                                  // 0x0308(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPickupDeactivated;                              // 0x0309(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146E[0x6];                                     // 0x030A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsPickupDeactivated();
	void OnRep_NumTimesPickedUp();
	void OnRep_PickupInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInteractPickup">();
	}
	static class ACrabInteractPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabInteractPickup>();
	}
};
static_assert(alignof(ACrabInteractPickup) == 0x000008, "Wrong alignment on ACrabInteractPickup");
static_assert(sizeof(ACrabInteractPickup) == 0x000310, "Wrong size on ACrabInteractPickup");
static_assert(offsetof(ACrabInteractPickup, PickupPrimaryNC) == 0x000278, "Member 'ACrabInteractPickup::PickupPrimaryNC' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, PickupSecondaryNC) == 0x000280, "Member 'ACrabInteractPickup::PickupSecondaryNC' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, PickupLocationWC) == 0x000288, "Member 'ACrabInteractPickup::PickupLocationWC' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, PickupInfo) == 0x000290, "Member 'ACrabInteractPickup::PickupInfo' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, NumTimesPickedUp) == 0x000308, "Member 'ACrabInteractPickup::NumTimesPickedUp' has a wrong offset!");
static_assert(offsetof(ACrabInteractPickup, bIsPickupDeactivated) == 0x000309, "Member 'ACrabInteractPickup::bIsPickupDeactivated' has a wrong offset!");

// Class CrabChampions.CrabPortal
// 0x0080 (0x02F8 - 0x0278)
class ACrabPortal : public ACrabInteractable
{
public:
	class UStaticMeshComponent*                   PortalMesh;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PortalNC;                                          // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PortalAC;                                          // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabIslandType                               IslandType;                                        // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146F[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Description;                                       // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            Mesh;                                              // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabPortalInfo                        PortalInfo;                                        // 0x02D8(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_PortalInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPortal">();
	}
	static class ACrabPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPortal>();
	}
};
static_assert(alignof(ACrabPortal) == 0x000008, "Wrong alignment on ACrabPortal");
static_assert(sizeof(ACrabPortal) == 0x0002F8, "Wrong size on ACrabPortal");
static_assert(offsetof(ACrabPortal, PortalMesh) == 0x000278, "Member 'ACrabPortal::PortalMesh' has a wrong offset!");
static_assert(offsetof(ACrabPortal, PortalNC) == 0x000280, "Member 'ACrabPortal::PortalNC' has a wrong offset!");
static_assert(offsetof(ACrabPortal, PortalAC) == 0x000288, "Member 'ACrabPortal::PortalAC' has a wrong offset!");
static_assert(offsetof(ACrabPortal, IslandType) == 0x000290, "Member 'ACrabPortal::IslandType' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Icon) == 0x000298, "Member 'ACrabPortal::Icon' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Description) == 0x0002A0, "Member 'ACrabPortal::Description' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Tint) == 0x0002B0, "Member 'ACrabPortal::Tint' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Mesh) == 0x0002C0, "Member 'ACrabPortal::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabPortal, FX) == 0x0002C8, "Member 'ACrabPortal::FX' has a wrong offset!");
static_assert(offsetof(ACrabPortal, Sound) == 0x0002D0, "Member 'ACrabPortal::Sound' has a wrong offset!");
static_assert(offsetof(ACrabPortal, PortalInfo) == 0x0002D8, "Member 'ACrabPortal::PortalInfo' has a wrong offset!");

// Class CrabChampions.CrabChest
// 0x00C8 (0x0340 - 0x0278)
class ACrabChest : public ACrabInteractable
{
public:
	class USkeletalMeshComponent*                 ChestMesh;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ChestNC;                                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ChestAC;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       ChestLocationWC;                                   // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Name_CrabChest;                                    // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabLootPool                                 LootPool;                                          // 0x02A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabRarity                                   Rarity;                                            // 0x02A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1470[0x2];                                     // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPickupsToSpawn;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabCurrencyType                             CurrencyType;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1471[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          ChestMeshToSpawn;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ChestSound;                                        // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              OpenSound;                                         // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         OpenFX;                                            // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                ChestLocationUI;                                   // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          SpawnAnim;                                         // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          OpenAnim;                                          // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x02F0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsChestOpened;                                    // 0x02F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1472[0x7];                                     // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabPickupsSpawnInfo                  PickupsSpawnInfo;                                  // 0x0300(0x0020)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1473[0x8];                                     // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabInteractPickup*>            SpawnedPickups;                                    // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1474[0x8];                                     // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsChestOpened();
	void OnRep_OwningPS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabChest">();
	}
	static class ACrabChest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabChest>();
	}
};
static_assert(alignof(ACrabChest) == 0x000008, "Wrong alignment on ACrabChest");
static_assert(sizeof(ACrabChest) == 0x000340, "Wrong size on ACrabChest");
static_assert(offsetof(ACrabChest, ChestMesh) == 0x000278, "Member 'ACrabChest::ChestMesh' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestNC) == 0x000280, "Member 'ACrabChest::ChestNC' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestAC) == 0x000288, "Member 'ACrabChest::ChestAC' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestLocationWC) == 0x000290, "Member 'ACrabChest::ChestLocationWC' has a wrong offset!");
static_assert(offsetof(ACrabChest, Name_CrabChest) == 0x000298, "Member 'ACrabChest::Name_CrabChest' has a wrong offset!");
static_assert(offsetof(ACrabChest, LootPool) == 0x0002A8, "Member 'ACrabChest::LootPool' has a wrong offset!");
static_assert(offsetof(ACrabChest, Rarity) == 0x0002A9, "Member 'ACrabChest::Rarity' has a wrong offset!");
static_assert(offsetof(ACrabChest, NumPickupsToSpawn) == 0x0002AC, "Member 'ACrabChest::NumPickupsToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabChest, CurrencyType) == 0x0002B0, "Member 'ACrabChest::CurrencyType' has a wrong offset!");
static_assert(offsetof(ACrabChest, Cost) == 0x0002B4, "Member 'ACrabChest::Cost' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestMeshToSpawn) == 0x0002B8, "Member 'ACrabChest::ChestMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestSound) == 0x0002C0, "Member 'ACrabChest::ChestSound' has a wrong offset!");
static_assert(offsetof(ACrabChest, OpenSound) == 0x0002C8, "Member 'ACrabChest::OpenSound' has a wrong offset!");
static_assert(offsetof(ACrabChest, OpenFX) == 0x0002D0, "Member 'ACrabChest::OpenFX' has a wrong offset!");
static_assert(offsetof(ACrabChest, ChestLocationUI) == 0x0002D8, "Member 'ACrabChest::ChestLocationUI' has a wrong offset!");
static_assert(offsetof(ACrabChest, SpawnAnim) == 0x0002E0, "Member 'ACrabChest::SpawnAnim' has a wrong offset!");
static_assert(offsetof(ACrabChest, OpenAnim) == 0x0002E8, "Member 'ACrabChest::OpenAnim' has a wrong offset!");
static_assert(offsetof(ACrabChest, OwningPS) == 0x0002F0, "Member 'ACrabChest::OwningPS' has a wrong offset!");
static_assert(offsetof(ACrabChest, bIsChestOpened) == 0x0002F8, "Member 'ACrabChest::bIsChestOpened' has a wrong offset!");
static_assert(offsetof(ACrabChest, PickupsSpawnInfo) == 0x000300, "Member 'ACrabChest::PickupsSpawnInfo' has a wrong offset!");
static_assert(offsetof(ACrabChest, SpawnedPickups) == 0x000328, "Member 'ACrabChest::SpawnedPickups' has a wrong offset!");

// Class CrabChampions.CrabLaunchPad
// 0x0048 (0x0268 - 0x0220)
class ACrabLaunchPad : public AActor
{
public:
	class UNiagaraComponent*                      LaunchPadNC;                                       // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LaunchPadAC;                                       // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1475[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchCollisionRadius;                             // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LaunchSpeed;                                       // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideXYVelocity;                               // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1476[0x7];                                     // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         LaunchFX;                                          // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LaunchSound;                                       // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabLaunchPad">();
	}
	static class ACrabLaunchPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabLaunchPad>();
	}
};
static_assert(alignof(ACrabLaunchPad) == 0x000008, "Wrong alignment on ACrabLaunchPad");
static_assert(sizeof(ACrabLaunchPad) == 0x000268, "Wrong size on ACrabLaunchPad");
static_assert(offsetof(ACrabLaunchPad, LaunchPadNC) == 0x000220, "Member 'ACrabLaunchPad::LaunchPadNC' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchPadAC) == 0x000228, "Member 'ACrabLaunchPad::LaunchPadAC' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, FX) == 0x000230, "Member 'ACrabLaunchPad::FX' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, Sound) == 0x000238, "Member 'ACrabLaunchPad::Sound' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchCollisionRadius) == 0x000248, "Member 'ACrabLaunchPad::LaunchCollisionRadius' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchSpeed) == 0x00024C, "Member 'ACrabLaunchPad::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, bOverrideXYVelocity) == 0x000250, "Member 'ACrabLaunchPad::bOverrideXYVelocity' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchFX) == 0x000258, "Member 'ACrabLaunchPad::LaunchFX' has a wrong offset!");
static_assert(offsetof(ACrabLaunchPad, LaunchSound) == 0x000260, "Member 'ACrabLaunchPad::LaunchSound' has a wrong offset!");

// Class CrabChampions.CrabTotem
// 0x00B0 (0x0328 - 0x0278)
class ACrabTotem : public ACrabInteractable
{
public:
	uint8                                         Pad_1477[0x8];                                     // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   TotemMesh;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      TotemNC;                                           // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        TotemAC;                                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabTotemType                                TotemType;                                         // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1478[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnWeight;                                       // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChanceToExplode;                                   // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Tint;                                              // 0x02A4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1479[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         FX;                                                // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              Sound;                                             // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Cost;                                              // 0x02D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147A[0x4];                                     // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumBuffs;                                          // 0x02D8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147B[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              BuffSound;                                         // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDebuffs;                                        // 0x02E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147C[0x4];                                     // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              DebuffSound;                                       // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147D[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsExploded;                                       // 0x0300(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147E[0x7];                                     // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DestroyedMesh;                                     // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Cost();
	void OnRep_IsExploded();
	void OnRep_NumBuffs();
	void OnRep_NumDebuffs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabTotem">();
	}
	static class ACrabTotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabTotem>();
	}
};
static_assert(alignof(ACrabTotem) == 0x000008, "Wrong alignment on ACrabTotem");
static_assert(sizeof(ACrabTotem) == 0x000328, "Wrong size on ACrabTotem");
static_assert(offsetof(ACrabTotem, TotemMesh) == 0x000280, "Member 'ACrabTotem::TotemMesh' has a wrong offset!");
static_assert(offsetof(ACrabTotem, TotemNC) == 0x000288, "Member 'ACrabTotem::TotemNC' has a wrong offset!");
static_assert(offsetof(ACrabTotem, TotemAC) == 0x000290, "Member 'ACrabTotem::TotemAC' has a wrong offset!");
static_assert(offsetof(ACrabTotem, TotemType) == 0x000298, "Member 'ACrabTotem::TotemType' has a wrong offset!");
static_assert(offsetof(ACrabTotem, SpawnWeight) == 0x00029C, "Member 'ACrabTotem::SpawnWeight' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ChanceToExplode) == 0x0002A0, "Member 'ACrabTotem::ChanceToExplode' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Tint) == 0x0002A4, "Member 'ACrabTotem::Tint' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Mesh) == 0x0002B8, "Member 'ACrabTotem::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabTotem, FX) == 0x0002C0, "Member 'ACrabTotem::FX' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Sound) == 0x0002C8, "Member 'ACrabTotem::Sound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, Cost) == 0x0002D0, "Member 'ACrabTotem::Cost' has a wrong offset!");
static_assert(offsetof(ACrabTotem, NumBuffs) == 0x0002D8, "Member 'ACrabTotem::NumBuffs' has a wrong offset!");
static_assert(offsetof(ACrabTotem, BuffSound) == 0x0002E0, "Member 'ACrabTotem::BuffSound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, NumDebuffs) == 0x0002E8, "Member 'ACrabTotem::NumDebuffs' has a wrong offset!");
static_assert(offsetof(ACrabTotem, DebuffSound) == 0x0002F0, "Member 'ACrabTotem::DebuffSound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, bIsExploded) == 0x000300, "Member 'ACrabTotem::bIsExploded' has a wrong offset!");
static_assert(offsetof(ACrabTotem, DestroyedMesh) == 0x000308, "Member 'ACrabTotem::DestroyedMesh' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ExplosionFX) == 0x000310, "Member 'ACrabTotem::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ExplosionSound) == 0x000318, "Member 'ACrabTotem::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabTotem, ExplosionCameraShake) == 0x000320, "Member 'ACrabTotem::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabOverlapPickup
// 0x0048 (0x0268 - 0x0220)
class ACrabOverlapPickup : public AActor
{
public:
	uint8                                         Pad_147F[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      PickupNC;                                          // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       PickupCollision;                                   // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapRadius;                                     // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeTime;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PickupFX;                                          // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           PickedUpByC;                                       // 0x0248(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1480[0x10];                                    // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              OnPickedUpSound;                                   // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_PickedUpByC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabOverlapPickup">();
	}
	static class ACrabOverlapPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabOverlapPickup>();
	}
};
static_assert(alignof(ACrabOverlapPickup) == 0x000008, "Wrong alignment on ACrabOverlapPickup");
static_assert(sizeof(ACrabOverlapPickup) == 0x000268, "Wrong size on ACrabOverlapPickup");
static_assert(offsetof(ACrabOverlapPickup, PickupNC) == 0x000228, "Member 'ACrabOverlapPickup::PickupNC' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, PickupCollision) == 0x000230, "Member 'ACrabOverlapPickup::PickupCollision' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, OverlapRadius) == 0x000238, "Member 'ACrabOverlapPickup::OverlapRadius' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, LifeTime) == 0x00023C, "Member 'ACrabOverlapPickup::LifeTime' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, PickupFX) == 0x000240, "Member 'ACrabOverlapPickup::PickupFX' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, PickedUpByC) == 0x000248, "Member 'ACrabOverlapPickup::PickedUpByC' has a wrong offset!");
static_assert(offsetof(ACrabOverlapPickup, OnPickedUpSound) == 0x000260, "Member 'ACrabOverlapPickup::OnPickedUpSound' has a wrong offset!");

// Class CrabChampions.CrabBananaPickup
// 0x0000 (0x0268 - 0x0268)
class ACrabBananaPickup final : public ACrabOverlapPickup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabBananaPickup">();
	}
	static class ACrabBananaPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabBananaPickup>();
	}
};
static_assert(alignof(ACrabBananaPickup) == 0x000008, "Wrong alignment on ACrabBananaPickup");
static_assert(sizeof(ACrabBananaPickup) == 0x000268, "Wrong size on ACrabBananaPickup");

// Class CrabChampions.CrabCrystalPickup
// 0x0008 (0x0270 - 0x0268)
class ACrabCrystalPickup : public ACrabOverlapPickup
{
public:
	uint8                                         Pad_1481[0x4];                                     // 0x0268(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrystalsMultiplier;                                // 0x026C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_CrystalsMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCrystalPickup">();
	}
	static class ACrabCrystalPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabCrystalPickup>();
	}
};
static_assert(alignof(ACrabCrystalPickup) == 0x000008, "Wrong alignment on ACrabCrystalPickup");
static_assert(sizeof(ACrabCrystalPickup) == 0x000270, "Wrong size on ACrabCrystalPickup");
static_assert(offsetof(ACrabCrystalPickup, CrystalsMultiplier) == 0x00026C, "Member 'ACrabCrystalPickup::CrystalsMultiplier' has a wrong offset!");

// Class CrabChampions.CrabHealthPickup
// 0x0008 (0x0270 - 0x0268)
class ACrabHealthPickup : public ACrabOverlapPickup
{
public:
	float                                         HealthToGive;                                      // 0x0268(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1482[0x4];                                     // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HealthToGive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHealthPickup">();
	}
	static class ACrabHealthPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabHealthPickup>();
	}
};
static_assert(alignof(ACrabHealthPickup) == 0x000008, "Wrong alignment on ACrabHealthPickup");
static_assert(sizeof(ACrabHealthPickup) == 0x000270, "Wrong size on ACrabHealthPickup");
static_assert(offsetof(ACrabHealthPickup, HealthToGive) == 0x000268, "Member 'ACrabHealthPickup::HealthToGive' has a wrong offset!");

// Class CrabChampions.CrabPhysicsActor
// 0x0048 (0x0268 - 0x0220)
class ACrabPhysicsActor : public AActor
{
public:
	uint8                                         Pad_1483[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MeshToSpawn;                                       // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScale;                                          // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScale;                                          // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomizeInitialRotation;                         // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1484[0xF];                                     // 0x0241(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExplodeWhenTakingDamage;                          // 0x0250(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExploded;                                       // 0x0251(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1485[0x6];                                     // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_IsExploded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPhysicsActor">();
	}
	static class ACrabPhysicsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPhysicsActor>();
	}
};
static_assert(alignof(ACrabPhysicsActor) == 0x000008, "Wrong alignment on ACrabPhysicsActor");
static_assert(sizeof(ACrabPhysicsActor) == 0x000268, "Wrong size on ACrabPhysicsActor");
static_assert(offsetof(ACrabPhysicsActor, Mesh) == 0x000228, "Member 'ACrabPhysicsActor::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, MeshToSpawn) == 0x000230, "Member 'ACrabPhysicsActor::MeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, MinScale) == 0x000238, "Member 'ACrabPhysicsActor::MinScale' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, MaxScale) == 0x00023C, "Member 'ACrabPhysicsActor::MaxScale' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, bRandomizeInitialRotation) == 0x000240, "Member 'ACrabPhysicsActor::bRandomizeInitialRotation' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, bExplodeWhenTakingDamage) == 0x000250, "Member 'ACrabPhysicsActor::bExplodeWhenTakingDamage' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, bIsExploded) == 0x000251, "Member 'ACrabPhysicsActor::bIsExploded' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, ExplosionFX) == 0x000258, "Member 'ACrabPhysicsActor::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ACrabPhysicsActor, ExplosionSound) == 0x000260, "Member 'ACrabPhysicsActor::ExplosionSound' has a wrong offset!");

// Class CrabChampions.CrabPickupDA
// 0x0070 (0x00A0 - 0x0030)
class UCrabPickupDA : public UDataAsset
{
public:
	bool                                          bRequiresUnlock;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1486[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_CrabPickupDA;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabPickupType                               PickupType;                                        // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabLootPool                                 LootPool;                                          // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabRarity                                   Rarity;                                            // 0x0062(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabPickupTag                                PickupTag;                                         // 0x0063(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresMatchingPickupTag;                        // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1487[0x3];                                     // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnWeight;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1488[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         PrimaryFX;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SecondaryFX;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCrabInteractUI>            InteractUI;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                LocationUI;                                        // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         OnPickedUpFX;                                      // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnPickedUpSound;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPickupDA">();
	}
	static class UCrabPickupDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPickupDA>();
	}
};
static_assert(alignof(UCrabPickupDA) == 0x000008, "Wrong alignment on UCrabPickupDA");
static_assert(sizeof(UCrabPickupDA) == 0x0000A0, "Wrong size on UCrabPickupDA");
static_assert(offsetof(UCrabPickupDA, bRequiresUnlock) == 0x000030, "Member 'UCrabPickupDA::bRequiresUnlock' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Name_CrabPickupDA) == 0x000038, "Member 'UCrabPickupDA::Name_CrabPickupDA' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Description) == 0x000048, "Member 'UCrabPickupDA::Description' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Icon) == 0x000058, "Member 'UCrabPickupDA::Icon' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, PickupType) == 0x000060, "Member 'UCrabPickupDA::PickupType' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, LootPool) == 0x000061, "Member 'UCrabPickupDA::LootPool' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, Rarity) == 0x000062, "Member 'UCrabPickupDA::Rarity' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, PickupTag) == 0x000063, "Member 'UCrabPickupDA::PickupTag' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, bRequiresMatchingPickupTag) == 0x000064, "Member 'UCrabPickupDA::bRequiresMatchingPickupTag' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, SpawnWeight) == 0x000068, "Member 'UCrabPickupDA::SpawnWeight' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, PrimaryFX) == 0x000070, "Member 'UCrabPickupDA::PrimaryFX' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, SecondaryFX) == 0x000078, "Member 'UCrabPickupDA::SecondaryFX' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, InteractUI) == 0x000080, "Member 'UCrabPickupDA::InteractUI' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, LocationUI) == 0x000088, "Member 'UCrabPickupDA::LocationUI' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, OnPickedUpFX) == 0x000090, "Member 'UCrabPickupDA::OnPickedUpFX' has a wrong offset!");
static_assert(offsetof(UCrabPickupDA, OnPickedUpSound) == 0x000098, "Member 'UCrabPickupDA::OnPickedUpSound' has a wrong offset!");

// Class CrabChampions.CrabGameplayUI
// 0x01A8 (0x0460 - 0x02B8)
class UCrabGameplayUI : public UCrabUI
{
public:
	class ACrabPlayerC*                           OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCrosshairUI*                       CrosshairUI;                                       // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabHealthBarUI*                       HealthBarUI;                                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PointsText;                                        // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ComboText;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedComboSmallAnim;                           // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedComboLargeAnim;                           // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1489[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CrystalsText;                                      // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CrystalsDifferenceText;                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedCrystalsAnim;                             // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148A[0x8];                                     // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             KeysText;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KeysDifferenceText;                                // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedKeysAnim;                                 // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnArmorBreakAnim;                                  // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnTookDamageAnim;                                  // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148B[0x8];                                     // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CrabChampionsVersionText;                          // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           FPSVerticalBox;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FPSText;                                           // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PingText;                                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EliminatedByText;                                  // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       EliminatedByAnim;                                  // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabWeapon*                            EquippedWeapon;                                    // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ScopeImage;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnStartedScopeAimingAnim;                          // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnStoppedScopeAimingAnim;                          // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentAmmoText;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponNameText;                                    // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityKeyText;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AbilityControllerIcon;                             // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AbilityIcon;                                       // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityCooldownText;                               // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnAbilityCooldownExpiredAnim;                      // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityStackText;                                  // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeKeyText;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MeleeControllerIcon;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MeleeIcon;                                         // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeCooldownText;                                 // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnMeleeCooldownExpiredAnim;                        // 0x0400(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InventoryKeyText;                                  // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 InventoryControllerIcon;                           // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                NewPickupBorder;                                   // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupNameText;                                 // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NewPickupIcon;                                     // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupDescriptionText;                          // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupTypeText;                                 // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewPickupLevelText;                                // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NewPickupAnim;                                     // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           InventoryEventVerticalBox;                         // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInventoryEventUI>      InventoryEventUIToSpawn;                           // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameplayUI">();
	}
	static class UCrabGameplayUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameplayUI>();
	}
};
static_assert(alignof(UCrabGameplayUI) == 0x000008, "Wrong alignment on UCrabGameplayUI");
static_assert(sizeof(UCrabGameplayUI) == 0x000460, "Wrong size on UCrabGameplayUI");
static_assert(offsetof(UCrabGameplayUI, OwningC) == 0x0002B8, "Member 'UCrabGameplayUI::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OwningPS) == 0x0002C0, "Member 'UCrabGameplayUI::OwningPS' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrosshairUI) == 0x0002C8, "Member 'UCrabGameplayUI::CrosshairUI' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, HealthBarUI) == 0x0002D0, "Member 'UCrabGameplayUI::HealthBarUI' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, PointsText) == 0x0002D8, "Member 'UCrabGameplayUI::PointsText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ComboText) == 0x0002E0, "Member 'UCrabGameplayUI::ComboText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedComboSmallAnim) == 0x0002E8, "Member 'UCrabGameplayUI::OnUpdatedComboSmallAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedComboLargeAnim) == 0x0002F0, "Member 'UCrabGameplayUI::OnUpdatedComboLargeAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrystalsText) == 0x000300, "Member 'UCrabGameplayUI::CrystalsText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrystalsDifferenceText) == 0x000308, "Member 'UCrabGameplayUI::CrystalsDifferenceText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedCrystalsAnim) == 0x000310, "Member 'UCrabGameplayUI::OnUpdatedCrystalsAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, KeysText) == 0x000320, "Member 'UCrabGameplayUI::KeysText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, KeysDifferenceText) == 0x000328, "Member 'UCrabGameplayUI::KeysDifferenceText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnUpdatedKeysAnim) == 0x000330, "Member 'UCrabGameplayUI::OnUpdatedKeysAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnArmorBreakAnim) == 0x000338, "Member 'UCrabGameplayUI::OnArmorBreakAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnTookDamageAnim) == 0x000340, "Member 'UCrabGameplayUI::OnTookDamageAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CrabChampionsVersionText) == 0x000350, "Member 'UCrabGameplayUI::CrabChampionsVersionText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, FPSVerticalBox) == 0x000358, "Member 'UCrabGameplayUI::FPSVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, FPSText) == 0x000360, "Member 'UCrabGameplayUI::FPSText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, PingText) == 0x000368, "Member 'UCrabGameplayUI::PingText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, EliminatedByText) == 0x000370, "Member 'UCrabGameplayUI::EliminatedByText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, EliminatedByAnim) == 0x000378, "Member 'UCrabGameplayUI::EliminatedByAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, EquippedWeapon) == 0x000380, "Member 'UCrabGameplayUI::EquippedWeapon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, ScopeImage) == 0x000388, "Member 'UCrabGameplayUI::ScopeImage' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnStartedScopeAimingAnim) == 0x000390, "Member 'UCrabGameplayUI::OnStartedScopeAimingAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnStoppedScopeAimingAnim) == 0x000398, "Member 'UCrabGameplayUI::OnStoppedScopeAimingAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, CurrentAmmoText) == 0x0003A0, "Member 'UCrabGameplayUI::CurrentAmmoText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, WeaponNameText) == 0x0003A8, "Member 'UCrabGameplayUI::WeaponNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityKeyText) == 0x0003B0, "Member 'UCrabGameplayUI::AbilityKeyText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityControllerIcon) == 0x0003B8, "Member 'UCrabGameplayUI::AbilityControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityIcon) == 0x0003C0, "Member 'UCrabGameplayUI::AbilityIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityCooldownText) == 0x0003C8, "Member 'UCrabGameplayUI::AbilityCooldownText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnAbilityCooldownExpiredAnim) == 0x0003D0, "Member 'UCrabGameplayUI::OnAbilityCooldownExpiredAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, AbilityStackText) == 0x0003D8, "Member 'UCrabGameplayUI::AbilityStackText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeKeyText) == 0x0003E0, "Member 'UCrabGameplayUI::MeleeKeyText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeControllerIcon) == 0x0003E8, "Member 'UCrabGameplayUI::MeleeControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeIcon) == 0x0003F0, "Member 'UCrabGameplayUI::MeleeIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, MeleeCooldownText) == 0x0003F8, "Member 'UCrabGameplayUI::MeleeCooldownText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, OnMeleeCooldownExpiredAnim) == 0x000400, "Member 'UCrabGameplayUI::OnMeleeCooldownExpiredAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryKeyText) == 0x000408, "Member 'UCrabGameplayUI::InventoryKeyText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryControllerIcon) == 0x000410, "Member 'UCrabGameplayUI::InventoryControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupBorder) == 0x000418, "Member 'UCrabGameplayUI::NewPickupBorder' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupNameText) == 0x000420, "Member 'UCrabGameplayUI::NewPickupNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupIcon) == 0x000428, "Member 'UCrabGameplayUI::NewPickupIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupDescriptionText) == 0x000430, "Member 'UCrabGameplayUI::NewPickupDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupTypeText) == 0x000438, "Member 'UCrabGameplayUI::NewPickupTypeText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupLevelText) == 0x000440, "Member 'UCrabGameplayUI::NewPickupLevelText' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, NewPickupAnim) == 0x000448, "Member 'UCrabGameplayUI::NewPickupAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryEventVerticalBox) == 0x000450, "Member 'UCrabGameplayUI::InventoryEventVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameplayUI, InventoryEventUIToSpawn) == 0x000458, "Member 'UCrabGameplayUI::InventoryEventUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabAbilityDA
// 0x0018 (0x00B8 - 0x00A0)
class UCrabAbilityDA final : public UCrabPickupDA
{
public:
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabHitmarkerType                            HitmarkerType;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148C[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabAbilityDA">();
	}
	static class UCrabAbilityDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabAbilityDA>();
	}
};
static_assert(alignof(UCrabAbilityDA) == 0x000008, "Wrong alignment on UCrabAbilityDA");
static_assert(sizeof(UCrabAbilityDA) == 0x0000B8, "Wrong size on UCrabAbilityDA");
static_assert(offsetof(UCrabAbilityDA, ProjectileDA) == 0x0000A0, "Member 'UCrabAbilityDA::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, HitmarkerType) == 0x0000A8, "Member 'UCrabAbilityDA::HitmarkerType' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, Cooldown) == 0x0000AC, "Member 'UCrabAbilityDA::Cooldown' has a wrong offset!");
static_assert(offsetof(UCrabAbilityDA, Montage) == 0x0000B0, "Member 'UCrabAbilityDA::Montage' has a wrong offset!");

// Class CrabChampions.CrabConsumableDA
// 0x0008 (0x00A8 - 0x00A0)
class UCrabConsumableDA final : public UCrabPickupDA
{
public:
	ECrabConsumableType                           ConsumableType;                                    // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148D[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Buff;                                              // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabConsumableDA">();
	}
	static class UCrabConsumableDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabConsumableDA>();
	}
};
static_assert(alignof(UCrabConsumableDA) == 0x000008, "Wrong alignment on UCrabConsumableDA");
static_assert(sizeof(UCrabConsumableDA) == 0x0000A8, "Wrong size on UCrabConsumableDA");
static_assert(offsetof(UCrabConsumableDA, ConsumableType) == 0x0000A0, "Member 'UCrabConsumableDA::ConsumableType' has a wrong offset!");
static_assert(offsetof(UCrabConsumableDA, Buff) == 0x0000A4, "Member 'UCrabConsumableDA::Buff' has a wrong offset!");

// Class CrabChampions.CrabInventoryDA
// 0x0028 (0x00C8 - 0x00A0)
class UCrabInventoryDA : public UCrabPickupDA
{
public:
	bool                                          bCanBeEnhanced;                                    // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148E[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelDescription;                                  // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseBuff;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHyperbolicBuff;                                   // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetBuffAsMultiplier;                              // 0x00BD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148F[0x2];                                     // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDebuff;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHyperbolicDebuff;                                 // 0x00C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetDebuffAsMultiplier;                            // 0x00C5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Cooldown;                                          // 0x00C6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1490[0x1];                                     // 0x00C7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventoryDA">();
	}
	static class UCrabInventoryDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventoryDA>();
	}
};
static_assert(alignof(UCrabInventoryDA) == 0x000008, "Wrong alignment on UCrabInventoryDA");
static_assert(sizeof(UCrabInventoryDA) == 0x0000C8, "Wrong size on UCrabInventoryDA");
static_assert(offsetof(UCrabInventoryDA, bCanBeEnhanced) == 0x0000A0, "Member 'UCrabInventoryDA::bCanBeEnhanced' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, LevelDescription) == 0x0000A8, "Member 'UCrabInventoryDA::LevelDescription' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, BaseBuff) == 0x0000B8, "Member 'UCrabInventoryDA::BaseBuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bHyperbolicBuff) == 0x0000BC, "Member 'UCrabInventoryDA::bHyperbolicBuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bGetBuffAsMultiplier) == 0x0000BD, "Member 'UCrabInventoryDA::bGetBuffAsMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, BaseDebuff) == 0x0000C0, "Member 'UCrabInventoryDA::BaseDebuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bHyperbolicDebuff) == 0x0000C4, "Member 'UCrabInventoryDA::bHyperbolicDebuff' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, bGetDebuffAsMultiplier) == 0x0000C5, "Member 'UCrabInventoryDA::bGetDebuffAsMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabInventoryDA, Cooldown) == 0x0000C6, "Member 'UCrabInventoryDA::Cooldown' has a wrong offset!");

// Class CrabChampions.CrabGrenadeModDA
// 0x0008 (0x00D0 - 0x00C8)
class UCrabGrenadeModDA final : public UCrabInventoryDA
{
public:
	ECrabGrenadeModType                           GrenadeModType;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1491[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGrenadeModDA">();
	}
	static class UCrabGrenadeModDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGrenadeModDA>();
	}
};
static_assert(alignof(UCrabGrenadeModDA) == 0x000008, "Wrong alignment on UCrabGrenadeModDA");
static_assert(sizeof(UCrabGrenadeModDA) == 0x0000D0, "Wrong size on UCrabGrenadeModDA");
static_assert(offsetof(UCrabGrenadeModDA, GrenadeModType) == 0x0000C8, "Member 'UCrabGrenadeModDA::GrenadeModType' has a wrong offset!");

// Class CrabChampions.CrabPerkDA
// 0x0008 (0x00D0 - 0x00C8)
class UCrabPerkDA final : public UCrabInventoryDA
{
public:
	ECrabPerkType                                 PerkType;                                          // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1492[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPerkDA">();
	}
	static class UCrabPerkDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPerkDA>();
	}
};
static_assert(alignof(UCrabPerkDA) == 0x000008, "Wrong alignment on UCrabPerkDA");
static_assert(sizeof(UCrabPerkDA) == 0x0000D0, "Wrong size on UCrabPerkDA");
static_assert(offsetof(UCrabPerkDA, PerkType) == 0x0000C8, "Member 'UCrabPerkDA::PerkType' has a wrong offset!");

// Class CrabChampions.CrabRelicDA
// 0x0008 (0x00D0 - 0x00C8)
class UCrabRelicDA final : public UCrabInventoryDA
{
public:
	ECrabRelicType                                RelicType;                                         // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1493[0x7];                                     // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabRelicDA">();
	}
	static class UCrabRelicDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabRelicDA>();
	}
};
static_assert(alignof(UCrabRelicDA) == 0x000008, "Wrong alignment on UCrabRelicDA");
static_assert(sizeof(UCrabRelicDA) == 0x0000D0, "Wrong size on UCrabRelicDA");
static_assert(offsetof(UCrabRelicDA, RelicType) == 0x0000C8, "Member 'UCrabRelicDA::RelicType' has a wrong offset!");

// Class CrabChampions.CrabWeaponModDA
// 0x0008 (0x00D0 - 0x00C8)
class UCrabWeaponModDA final : public UCrabInventoryDA
{
public:
	ECrabWeaponModType                            WeaponModType;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChanceBased;                                      // 0x00C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1494[0x6];                                     // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabWeaponModDA">();
	}
	static class UCrabWeaponModDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabWeaponModDA>();
	}
};
static_assert(alignof(UCrabWeaponModDA) == 0x000008, "Wrong alignment on UCrabWeaponModDA");
static_assert(sizeof(UCrabWeaponModDA) == 0x0000D0, "Wrong size on UCrabWeaponModDA");
static_assert(offsetof(UCrabWeaponModDA, WeaponModType) == 0x0000C8, "Member 'UCrabWeaponModDA::WeaponModType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponModDA, bChanceBased) == 0x0000C9, "Member 'UCrabWeaponModDA::bChanceBased' has a wrong offset!");

// Class CrabChampions.CrabMeleeDA
// 0x0028 (0x00C8 - 0x00A0)
class UCrabMeleeDA final : public UCrabPickupDA
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabHitmarkerType                            HitmarkerType;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1495[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchHeight;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackStrength;                                 // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMeleeDA">();
	}
	static class UCrabMeleeDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMeleeDA>();
	}
};
static_assert(alignof(UCrabMeleeDA) == 0x000008, "Wrong alignment on UCrabMeleeDA");
static_assert(sizeof(UCrabMeleeDA) == 0x0000C8, "Wrong size on UCrabMeleeDA");
static_assert(offsetof(UCrabMeleeDA, Mesh) == 0x0000A0, "Member 'UCrabMeleeDA::Mesh' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, HitmarkerType) == 0x0000A8, "Member 'UCrabMeleeDA::HitmarkerType' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Cooldown) == 0x0000AC, "Member 'UCrabMeleeDA::Cooldown' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Montage) == 0x0000B0, "Member 'UCrabMeleeDA::Montage' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, LaunchHeight) == 0x0000B8, "Member 'UCrabMeleeDA::LaunchHeight' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Range) == 0x0000BC, "Member 'UCrabMeleeDA::Range' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, Damage) == 0x0000C0, "Member 'UCrabMeleeDA::Damage' has a wrong offset!");
static_assert(offsetof(UCrabMeleeDA, KnockbackStrength) == 0x0000C4, "Member 'UCrabMeleeDA::KnockbackStrength' has a wrong offset!");

// Class CrabChampions.CrabProjectile
// 0x0208 (0x0428 - 0x0220)
class ACrabProjectile final : public AActor
{
public:
	class USphereComponent*                       ProjectileCollision;                               // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabPMC*                               ProjectilePMC;                                     // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ProjectileNC;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ProjectileTrailNC;                                 // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ProjectileAC;                                      // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1496[0x8];                                     // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabProjectileInfo                    ProjectileInfo;                                    // 0x0250(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1497[0x28];                                    // 0x0280(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabEnhancementType>                  Enhancements;                                      // 0x02A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x02B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabGrenadeMod>                GrenadeMods;                                       // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabPerk>                      Perks;                                             // 0x02D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1498[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x02F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1499[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDamageInfo                        ProximityDamageInfo;                               // 0x0308(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_149A[0x8];                                     // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDamageInfo                        AuraDamageInfo;                                    // 0x0348(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_149B[0x10];                                    // 0x0380(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDamageInfo                        ExplosionDamageInfo;                               // 0x0390(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_149C[0x60];                                    // 0x03C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProjectile">();
	}
	static class ACrabProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabProjectile>();
	}
};
static_assert(alignof(ACrabProjectile) == 0x000008, "Wrong alignment on ACrabProjectile");
static_assert(sizeof(ACrabProjectile) == 0x000428, "Wrong size on ACrabProjectile");
static_assert(offsetof(ACrabProjectile, ProjectileCollision) == 0x000220, "Member 'ACrabProjectile::ProjectileCollision' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectilePMC) == 0x000228, "Member 'ACrabProjectile::ProjectilePMC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileNC) == 0x000230, "Member 'ACrabProjectile::ProjectileNC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileTrailNC) == 0x000238, "Member 'ACrabProjectile::ProjectileTrailNC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileAC) == 0x000240, "Member 'ACrabProjectile::ProjectileAC' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProjectileInfo) == 0x000250, "Member 'ACrabProjectile::ProjectileInfo' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, Enhancements) == 0x0002A8, "Member 'ACrabProjectile::Enhancements' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, WeaponMods) == 0x0002B8, "Member 'ACrabProjectile::WeaponMods' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, GrenadeMods) == 0x0002C8, "Member 'ACrabProjectile::GrenadeMods' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, Perks) == 0x0002D8, "Member 'ACrabProjectile::Perks' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ActorsToIgnore) == 0x0002F0, "Member 'ACrabProjectile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ProximityDamageInfo) == 0x000308, "Member 'ACrabProjectile::ProximityDamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, AuraDamageInfo) == 0x000348, "Member 'ACrabProjectile::AuraDamageInfo' has a wrong offset!");
static_assert(offsetof(ACrabProjectile, ExplosionDamageInfo) == 0x000390, "Member 'ACrabProjectile::ExplosionDamageInfo' has a wrong offset!");

// Class CrabChampions.CrabWeaponDA
// 0x0130 (0x01D0 - 0x00A0)
class UCrabWeaponDA final : public UCrabPickupDA
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDualWield;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149D[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabWeaponMod                         StartingWeaponMod;                                 // 0x00B8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AimingFOVMultiplier;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimingSpringArmOffset;                             // 0x00E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabCrosshairType                            CrosshairType;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabHitmarkerType                            HitmarkerType;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFireMode                                 FireMode;                                          // 0x00F2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFormationType                            FormationType;                                     // 0x00F3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationSpacing;                                  // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationExpansionDampening;                       // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdditiveFormations;                               // 0x00FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149E[0x3];                                     // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShotsPerBurst;                                     // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenBurstShots;                             // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseFireRate;                                      // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponModTriggerRollMultiplier;                    // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpread;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringSpreadIncrement;                             // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpread;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadRecovery;                                    // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingSpreadMultiplier;                            // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoil;                                    // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRecoil;                                  // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilInterpSpeed;                                 // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRecoveryInterpSpeed;                         // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfKnockbackStrength;                             // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseClipSize;                                      // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfiniteClipSize;                                 // 0x013C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149F[0x3];                                     // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadDuration;                                    // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A0[0x4];                                     // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EquipMontage;                                      // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EquipSound;                                        // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CosmeticFX;                                        // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireMontage;                                       // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DualWieldFireMontage;                              // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         MuzzleFlashFX;                                     // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GunshotSound;                                      // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostFireClearChamberDelay;                         // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A1[0x4];                                     // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PostFireClearChamberMontage;                       // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PostFireClearChamberSound;                         // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EmptyClipSound;                                    // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadMontage;                                     // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DualWieldReloadMontage;                            // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MagOutSound;                                       // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MagInSound;                                        // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabWeaponDA">();
	}
	static class UCrabWeaponDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabWeaponDA>();
	}
};
static_assert(alignof(UCrabWeaponDA) == 0x000008, "Wrong alignment on UCrabWeaponDA");
static_assert(sizeof(UCrabWeaponDA) == 0x0001D0, "Wrong size on UCrabWeaponDA");
static_assert(offsetof(UCrabWeaponDA, Mesh) == 0x0000A0, "Member 'UCrabWeaponDA::Mesh' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bDualWield) == 0x0000A8, "Member 'UCrabWeaponDA::bDualWield' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ProjectileDA) == 0x0000B0, "Member 'UCrabWeaponDA::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, StartingWeaponMod) == 0x0000B8, "Member 'UCrabWeaponDA::StartingWeaponMod' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, AimingFOVMultiplier) == 0x0000E0, "Member 'UCrabWeaponDA::AimingFOVMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, AimingSpringArmOffset) == 0x0000E4, "Member 'UCrabWeaponDA::AimingSpringArmOffset' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, CrosshairType) == 0x0000F0, "Member 'UCrabWeaponDA::CrosshairType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, HitmarkerType) == 0x0000F1, "Member 'UCrabWeaponDA::HitmarkerType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FireMode) == 0x0000F2, "Member 'UCrabWeaponDA::FireMode' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FormationType) == 0x0000F3, "Member 'UCrabWeaponDA::FormationType' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FormationSpacing) == 0x0000F4, "Member 'UCrabWeaponDA::FormationSpacing' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FormationExpansionDampening) == 0x0000F8, "Member 'UCrabWeaponDA::FormationExpansionDampening' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bAdditiveFormations) == 0x0000FC, "Member 'UCrabWeaponDA::bAdditiveFormations' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ShotsPerBurst) == 0x000100, "Member 'UCrabWeaponDA::ShotsPerBurst' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, TimeBetweenBurstShots) == 0x000104, "Member 'UCrabWeaponDA::TimeBetweenBurstShots' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, BaseFireRate) == 0x000108, "Member 'UCrabWeaponDA::BaseFireRate' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, WeaponModTriggerRollMultiplier) == 0x00010C, "Member 'UCrabWeaponDA::WeaponModTriggerRollMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, BaseSpread) == 0x000110, "Member 'UCrabWeaponDA::BaseSpread' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FiringSpreadIncrement) == 0x000114, "Member 'UCrabWeaponDA::FiringSpreadIncrement' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MaxSpread) == 0x000118, "Member 'UCrabWeaponDA::MaxSpread' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, SpreadRecovery) == 0x00011C, "Member 'UCrabWeaponDA::SpreadRecovery' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, AimingSpreadMultiplier) == 0x000120, "Member 'UCrabWeaponDA::AimingSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, VerticalRecoil) == 0x000124, "Member 'UCrabWeaponDA::VerticalRecoil' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, HorizontalRecoil) == 0x000128, "Member 'UCrabWeaponDA::HorizontalRecoil' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, RecoilInterpSpeed) == 0x00012C, "Member 'UCrabWeaponDA::RecoilInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, RecoilRecoveryInterpSpeed) == 0x000130, "Member 'UCrabWeaponDA::RecoilRecoveryInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, SelfKnockbackStrength) == 0x000134, "Member 'UCrabWeaponDA::SelfKnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, BaseClipSize) == 0x000138, "Member 'UCrabWeaponDA::BaseClipSize' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, bInfiniteClipSize) == 0x00013C, "Member 'UCrabWeaponDA::bInfiniteClipSize' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ReloadDuration) == 0x000140, "Member 'UCrabWeaponDA::ReloadDuration' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, EquipMontage) == 0x000148, "Member 'UCrabWeaponDA::EquipMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, EquipSound) == 0x000150, "Member 'UCrabWeaponDA::EquipSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, Tint) == 0x000158, "Member 'UCrabWeaponDA::Tint' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, CosmeticFX) == 0x000168, "Member 'UCrabWeaponDA::CosmeticFX' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, FireMontage) == 0x000170, "Member 'UCrabWeaponDA::FireMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, DualWieldFireMontage) == 0x000178, "Member 'UCrabWeaponDA::DualWieldFireMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MuzzleFlashFX) == 0x000180, "Member 'UCrabWeaponDA::MuzzleFlashFX' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, GunshotSound) == 0x000188, "Member 'UCrabWeaponDA::GunshotSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, PostFireClearChamberDelay) == 0x000190, "Member 'UCrabWeaponDA::PostFireClearChamberDelay' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, PostFireClearChamberMontage) == 0x000198, "Member 'UCrabWeaponDA::PostFireClearChamberMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, PostFireClearChamberSound) == 0x0001A0, "Member 'UCrabWeaponDA::PostFireClearChamberSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, EmptyClipSound) == 0x0001A8, "Member 'UCrabWeaponDA::EmptyClipSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, ReloadMontage) == 0x0001B0, "Member 'UCrabWeaponDA::ReloadMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, DualWieldReloadMontage) == 0x0001B8, "Member 'UCrabWeaponDA::DualWieldReloadMontage' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MagOutSound) == 0x0001C0, "Member 'UCrabWeaponDA::MagOutSound' has a wrong offset!");
static_assert(offsetof(UCrabWeaponDA, MagInSound) == 0x0001C8, "Member 'UCrabWeaponDA::MagInSound' has a wrong offset!");

// Class CrabChampions.CrabProjectileDA
// 0x00C8 (0x00F8 - 0x0030)
class UCrabProjectileDA final : public UDataAsset
{
public:
	float                                         LifeTime;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDelay;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationScale;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZigZagScale;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpiralScale;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnakeScale;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaoticScale;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoomerangScale;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrbitingScale;                                     // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingScale;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrapplingScale;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPiercings;                                      // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBounces;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityScale;                               // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlueToHitCharacters;                              // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A2[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProximityDamageRadius;                             // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProximityDamageMultiplier;                         // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeAfterLifetime;                             // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A3[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDelay;                                    // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDamage;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionKnockbackStrength;                        // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          ExplosionDestructibleToSpawn;                      // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDestructiblePhysicsImpulse;               // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDamageAreaSpawnChance;                    // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            ExplosionDamageAreaToSpawn;                        // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ProjectileFX;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ProjectileTrailFX;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ProjectileSound;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeTint;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A4[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         ExplosionFX;                                       // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ExplosionSound;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ExplosionDecalMat;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDecalSize;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A5[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProjectileDA">();
	}
	static class UCrabProjectileDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabProjectileDA>();
	}
};
static_assert(alignof(UCrabProjectileDA) == 0x000008, "Wrong alignment on UCrabProjectileDA");
static_assert(sizeof(UCrabProjectileDA) == 0x0000F8, "Wrong size on UCrabProjectileDA");
static_assert(offsetof(UCrabProjectileDA, LifeTime) == 0x000030, "Member 'UCrabProjectileDA::LifeTime' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, CollisionRadius) == 0x000034, "Member 'UCrabProjectileDA::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, StartDelay) == 0x000038, "Member 'UCrabProjectileDA::StartDelay' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, Speed) == 0x00003C, "Member 'UCrabProjectileDA::Speed' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, MaxSpeed) == 0x000040, "Member 'UCrabProjectileDA::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, AccelerationScale) == 0x000044, "Member 'UCrabProjectileDA::AccelerationScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ZigZagScale) == 0x000048, "Member 'UCrabProjectileDA::ZigZagScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, SpiralScale) == 0x00004C, "Member 'UCrabProjectileDA::SpiralScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, SnakeScale) == 0x000050, "Member 'UCrabProjectileDA::SnakeScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ChaoticScale) == 0x000054, "Member 'UCrabProjectileDA::ChaoticScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, BoomerangScale) == 0x000058, "Member 'UCrabProjectileDA::BoomerangScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, OrbitingScale) == 0x00005C, "Member 'UCrabProjectileDA::OrbitingScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, GravityScale) == 0x000060, "Member 'UCrabProjectileDA::GravityScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, HomingScale) == 0x000064, "Member 'UCrabProjectileDA::HomingScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, GrapplingScale) == 0x000068, "Member 'UCrabProjectileDA::GrapplingScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, MaxPiercings) == 0x00006C, "Member 'UCrabProjectileDA::MaxPiercings' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, MaxBounces) == 0x000070, "Member 'UCrabProjectileDA::MaxBounces' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, BounceVelocityScale) == 0x000074, "Member 'UCrabProjectileDA::BounceVelocityScale' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bGlueToHitCharacters) == 0x000078, "Member 'UCrabProjectileDA::bGlueToHitCharacters' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProximityDamageRadius) == 0x00007C, "Member 'UCrabProjectileDA::ProximityDamageRadius' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProximityDamageMultiplier) == 0x000080, "Member 'UCrabProjectileDA::ProximityDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bExplodeAfterLifetime) == 0x000084, "Member 'UCrabProjectileDA::bExplodeAfterLifetime' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDelay) == 0x000088, "Member 'UCrabProjectileDA::ExplosionDelay' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionRadius) == 0x00008C, "Member 'UCrabProjectileDA::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamage) == 0x000090, "Member 'UCrabProjectileDA::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionKnockbackStrength) == 0x000094, "Member 'UCrabProjectileDA::ExplosionKnockbackStrength' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDestructibleToSpawn) == 0x000098, "Member 'UCrabProjectileDA::ExplosionDestructibleToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDestructiblePhysicsImpulse) == 0x0000A0, "Member 'UCrabProjectileDA::ExplosionDestructiblePhysicsImpulse' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamageAreaSpawnChance) == 0x0000A4, "Member 'UCrabProjectileDA::ExplosionDamageAreaSpawnChance' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDamageAreaToSpawn) == 0x0000A8, "Member 'UCrabProjectileDA::ExplosionDamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProjectileFX) == 0x0000B0, "Member 'UCrabProjectileDA::ProjectileFX' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProjectileTrailFX) == 0x0000B8, "Member 'UCrabProjectileDA::ProjectileTrailFX' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ProjectileSound) == 0x0000C0, "Member 'UCrabProjectileDA::ProjectileSound' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, bRandomizeTint) == 0x0000C8, "Member 'UCrabProjectileDA::bRandomizeTint' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionFX) == 0x0000D0, "Member 'UCrabProjectileDA::ExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionSound) == 0x0000D8, "Member 'UCrabProjectileDA::ExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionCameraShake) == 0x0000E0, "Member 'UCrabProjectileDA::ExplosionCameraShake' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDecalMat) == 0x0000E8, "Member 'UCrabProjectileDA::ExplosionDecalMat' has a wrong offset!");
static_assert(offsetof(UCrabProjectileDA, ExplosionDecalSize) == 0x0000F0, "Member 'UCrabProjectileDA::ExplosionDecalSize' has a wrong offset!");

// Class CrabChampions.CrabSettingsSG
// 0x0140 (0x0168 - 0x0028)
class UCrabSettingsSG final : public USaveGame
{
public:
	class FString                                 DisplayMode;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Resolution;                                        // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResolutionQuality;                                 // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FPSLimit;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VSync;                                             // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FieldOfView;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GraphicsQuality;                                   // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponEffects;                                     // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AntiAliasingType;                                  // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sharpening;                                        // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MotionBlur;                                        // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CameraShake;                                       // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hitmarkers;                                        // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageNumbers;                                     // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextChatVisibility;                                // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShowFPS;                                           // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PauseWhenLosingFocus;                              // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MasterVolume;                                      // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameplayVolume;                                    // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolume;                                       // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookSensitivity;                                   // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingSensitivityMultiplier;                       // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerticalLookInversion;                            // 0x014C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A6[0x3];                                     // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAssistStrength;                                 // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A7[0x4];                                     // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabKeyBind>                   CrabKeyBinds;                                      // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSettingsSG">();
	}
	static class UCrabSettingsSG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSettingsSG>();
	}
};
static_assert(alignof(UCrabSettingsSG) == 0x000008, "Wrong alignment on UCrabSettingsSG");
static_assert(sizeof(UCrabSettingsSG) == 0x000168, "Wrong size on UCrabSettingsSG");
static_assert(offsetof(UCrabSettingsSG, DisplayMode) == 0x000028, "Member 'UCrabSettingsSG::DisplayMode' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, Resolution) == 0x000038, "Member 'UCrabSettingsSG::Resolution' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, ResolutionQuality) == 0x000048, "Member 'UCrabSettingsSG::ResolutionQuality' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, FPSLimit) == 0x000058, "Member 'UCrabSettingsSG::FPSLimit' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, VSync) == 0x000068, "Member 'UCrabSettingsSG::VSync' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, FieldOfView) == 0x000078, "Member 'UCrabSettingsSG::FieldOfView' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, GraphicsQuality) == 0x000088, "Member 'UCrabSettingsSG::GraphicsQuality' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, WeaponEffects) == 0x000098, "Member 'UCrabSettingsSG::WeaponEffects' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, AntiAliasingType) == 0x0000A8, "Member 'UCrabSettingsSG::AntiAliasingType' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, Sharpening) == 0x0000B8, "Member 'UCrabSettingsSG::Sharpening' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, MotionBlur) == 0x0000C8, "Member 'UCrabSettingsSG::MotionBlur' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, CameraShake) == 0x0000D8, "Member 'UCrabSettingsSG::CameraShake' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, Hitmarkers) == 0x0000E8, "Member 'UCrabSettingsSG::Hitmarkers' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, DamageNumbers) == 0x0000F8, "Member 'UCrabSettingsSG::DamageNumbers' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, TextChatVisibility) == 0x000108, "Member 'UCrabSettingsSG::TextChatVisibility' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, ShowFPS) == 0x000118, "Member 'UCrabSettingsSG::ShowFPS' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, PauseWhenLosingFocus) == 0x000128, "Member 'UCrabSettingsSG::PauseWhenLosingFocus' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, MasterVolume) == 0x000138, "Member 'UCrabSettingsSG::MasterVolume' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, GameplayVolume) == 0x00013C, "Member 'UCrabSettingsSG::GameplayVolume' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, MusicVolume) == 0x000140, "Member 'UCrabSettingsSG::MusicVolume' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, LookSensitivity) == 0x000144, "Member 'UCrabSettingsSG::LookSensitivity' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, AimingSensitivityMultiplier) == 0x000148, "Member 'UCrabSettingsSG::AimingSensitivityMultiplier' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, bVerticalLookInversion) == 0x00014C, "Member 'UCrabSettingsSG::bVerticalLookInversion' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, AimAssistStrength) == 0x000150, "Member 'UCrabSettingsSG::AimAssistStrength' has a wrong offset!");
static_assert(offsetof(UCrabSettingsSG, CrabKeyBinds) == 0x000158, "Member 'UCrabSettingsSG::CrabKeyBinds' has a wrong offset!");

// Class CrabChampions.CrabShopPedestal
// 0x0040 (0x0260 - 0x0220)
class ACrabShopPedestal : public AActor
{
public:
	class UStaticMeshComponent*                   PedestalMesh;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       PedestalWC;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PedestalMeshToSpawn;                               // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabShopPedestalUI>        ShopPedestalUIToSpawn;                             // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabLootPool                                 LootPool;                                          // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxPickups;                                        // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabCurrencyType                             CurrencyType;                                      // 0x0242(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A8[0x5];                                     // 0x0243(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabPickupDA*                          PickupToSpawn;                                     // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabPedestalInfo                      PedestalInfo;                                      // 0x0250(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A9[0x4];                                     // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastHidePedestalWC();
	void MulticastInitPedestalInfo(const struct FCrabPedestalInfo& NewPedestalInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabShopPedestal">();
	}
	static class ACrabShopPedestal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabShopPedestal>();
	}
};
static_assert(alignof(ACrabShopPedestal) == 0x000008, "Wrong alignment on ACrabShopPedestal");
static_assert(sizeof(ACrabShopPedestal) == 0x000260, "Wrong size on ACrabShopPedestal");
static_assert(offsetof(ACrabShopPedestal, PedestalMesh) == 0x000220, "Member 'ACrabShopPedestal::PedestalMesh' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PedestalWC) == 0x000228, "Member 'ACrabShopPedestal::PedestalWC' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PedestalMeshToSpawn) == 0x000230, "Member 'ACrabShopPedestal::PedestalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, ShopPedestalUIToSpawn) == 0x000238, "Member 'ACrabShopPedestal::ShopPedestalUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, LootPool) == 0x000240, "Member 'ACrabShopPedestal::LootPool' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, MaxPickups) == 0x000241, "Member 'ACrabShopPedestal::MaxPickups' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, CurrencyType) == 0x000242, "Member 'ACrabShopPedestal::CurrencyType' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PickupToSpawn) == 0x000248, "Member 'ACrabShopPedestal::PickupToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabShopPedestal, PedestalInfo) == 0x000250, "Member 'ACrabShopPedestal::PedestalInfo' has a wrong offset!");

// Class CrabChampions.CrabSpectatorC
// 0x0020 (0x02A0 - 0x0280)
class ACrabSpectatorC final : public APawn
{
public:
	class USpringArmComponent*                    CameraSpringArm;                                   // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       SpectatorCamera;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14AA[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabPlayerC*                           SpectatingPlayer;                                  // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClientInitSpectatorC(class ACrabPlayerC* EliminatedPlayerToSpectate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpectatorC">();
	}
	static class ACrabSpectatorC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabSpectatorC>();
	}
};
static_assert(alignof(ACrabSpectatorC) == 0x000008, "Wrong alignment on ACrabSpectatorC");
static_assert(sizeof(ACrabSpectatorC) == 0x0002A0, "Wrong size on ACrabSpectatorC");
static_assert(offsetof(ACrabSpectatorC, CameraSpringArm) == 0x000280, "Member 'ACrabSpectatorC::CameraSpringArm' has a wrong offset!");
static_assert(offsetof(ACrabSpectatorC, SpectatorCamera) == 0x000288, "Member 'ACrabSpectatorC::SpectatorCamera' has a wrong offset!");
static_assert(offsetof(ACrabSpectatorC, SpectatingPlayer) == 0x000298, "Member 'ACrabSpectatorC::SpectatingPlayer' has a wrong offset!");

// Class CrabChampions.CrabSpawnPoint
// 0x0018 (0x0238 - 0x0220)
class ACrabSpawnPoint : public AActor
{
public:
	class USceneComponent*                        SpawnPointRoot;                                    // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabSpawnPointType                           SpawnPointType;                                    // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14AB[0xF];                                     // 0x0229(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpawnPoint">();
	}
	static class ACrabSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabSpawnPoint>();
	}
};
static_assert(alignof(ACrabSpawnPoint) == 0x000008, "Wrong alignment on ACrabSpawnPoint");
static_assert(sizeof(ACrabSpawnPoint) == 0x000238, "Wrong size on ACrabSpawnPoint");
static_assert(offsetof(ACrabSpawnPoint, SpawnPointRoot) == 0x000220, "Member 'ACrabSpawnPoint::SpawnPointRoot' has a wrong offset!");
static_assert(offsetof(ACrabSpawnPoint, SpawnPointType) == 0x000228, "Member 'ACrabSpawnPoint::SpawnPointType' has a wrong offset!");

// Class CrabChampions.CrabStatics
// 0x0000 (0x0028 - 0x0028)
class UCrabStatics final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStatics">();
	}
	static class UCrabStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabStatics>();
	}
};
static_assert(alignof(UCrabStatics) == 0x000008, "Wrong alignment on UCrabStatics");
static_assert(sizeof(UCrabStatics) == 0x000028, "Wrong size on UCrabStatics");

// Class CrabChampions.CrabStatsPedestal
// 0x0080 (0x02A0 - 0x0220)
class ACrabStatsPedestal : public AActor
{
public:
	class UStaticMeshComponent*                   PedestalMesh;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       StatsWC;                                           // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            PedestalMeshToSpawn;                               // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabStatsUI>               StatsUIToSpawn;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabLobbyStats                        LobbyStats;                                        // 0x0240(0x0058)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14AC[0x8];                                     // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LobbyStats();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStatsPedestal">();
	}
	static class ACrabStatsPedestal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabStatsPedestal>();
	}
};
static_assert(alignof(ACrabStatsPedestal) == 0x000008, "Wrong alignment on ACrabStatsPedestal");
static_assert(sizeof(ACrabStatsPedestal) == 0x0002A0, "Wrong size on ACrabStatsPedestal");
static_assert(offsetof(ACrabStatsPedestal, PedestalMesh) == 0x000220, "Member 'ACrabStatsPedestal::PedestalMesh' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, StatsWC) == 0x000228, "Member 'ACrabStatsPedestal::StatsWC' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, PedestalMeshToSpawn) == 0x000230, "Member 'ACrabStatsPedestal::PedestalMeshToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, StatsUIToSpawn) == 0x000238, "Member 'ACrabStatsPedestal::StatsUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabStatsPedestal, LobbyStats) == 0x000240, "Member 'ACrabStatsPedestal::LobbyStats' has a wrong offset!");

// Class CrabChampions.CrabStrike
// 0x0050 (0x0270 - 0x0220)
class ACrabStrike : public AActor
{
public:
	class ACrabC*                                 OwningC;                                           // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14AD[0x8];                                     // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FX;                                                // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SpawnSound;                                        // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionDelay;                                    // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Damage;                                            // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDamageType                               DamageType;                                        // 0x024C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14AE[0x3];                                     // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabDebuff                            Debuff;                                            // 0x0250(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ACrabDamageArea>            DamageAreaToSpawn;                                 // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ExplosionSound;                                    // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           ExplosionCameraShake;                              // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStrike">();
	}
	static class ACrabStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabStrike>();
	}
};
static_assert(alignof(ACrabStrike) == 0x000008, "Wrong alignment on ACrabStrike");
static_assert(sizeof(ACrabStrike) == 0x000270, "Wrong size on ACrabStrike");
static_assert(offsetof(ACrabStrike, OwningC) == 0x000220, "Member 'ACrabStrike::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabStrike, FX) == 0x000230, "Member 'ACrabStrike::FX' has a wrong offset!");
static_assert(offsetof(ACrabStrike, SpawnSound) == 0x000238, "Member 'ACrabStrike::SpawnSound' has a wrong offset!");
static_assert(offsetof(ACrabStrike, Radius) == 0x000240, "Member 'ACrabStrike::Radius' has a wrong offset!");
static_assert(offsetof(ACrabStrike, ExplosionDelay) == 0x000244, "Member 'ACrabStrike::ExplosionDelay' has a wrong offset!");
static_assert(offsetof(ACrabStrike, Damage) == 0x000248, "Member 'ACrabStrike::Damage' has a wrong offset!");
static_assert(offsetof(ACrabStrike, DamageType) == 0x00024C, "Member 'ACrabStrike::DamageType' has a wrong offset!");
static_assert(offsetof(ACrabStrike, Debuff) == 0x000250, "Member 'ACrabStrike::Debuff' has a wrong offset!");
static_assert(offsetof(ACrabStrike, DamageAreaToSpawn) == 0x000258, "Member 'ACrabStrike::DamageAreaToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabStrike, ExplosionSound) == 0x000260, "Member 'ACrabStrike::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ACrabStrike, ExplosionCameraShake) == 0x000268, "Member 'ACrabStrike::ExplosionCameraShake' has a wrong offset!");

// Class CrabChampions.CrabGameOverUI
// 0x00A8 (0x0478 - 0x03D0)
class UCrabGameOverUI : public UCrabFocusMenuUI
{
public:
	class UTextBlock*                             RunResultText;                                     // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyText;                                    // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ScoreText;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighScoreText;                                     // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AttemptsText;                                      // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinsText;                                          // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinStreakText;                                     // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandsSurvivedText;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighestIslandReachedText;                          // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalTimeTakenText;                                // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           GameOverRowUIVerticalBox;                          // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameOverRowUI>         GameOverRowUIToSpawn;                              // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0430(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14AF[0x8];                                     // 0x0440(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCrabUnlockedCosmeticUI>    UnlockedCosmeticUIToSpawn;                         // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         UnlockedCosmeticsHorizontalBox;                    // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpWeaponText;                                // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RankedUpWeaponMedalIconImage;                      // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankedUpWeaponRankText;                            // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RankedUpWeaponAnim;                                // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameOverUI">();
	}
	static class UCrabGameOverUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameOverUI>();
	}
};
static_assert(alignof(UCrabGameOverUI) == 0x000008, "Wrong alignment on UCrabGameOverUI");
static_assert(sizeof(UCrabGameOverUI) == 0x000478, "Wrong size on UCrabGameOverUI");
static_assert(offsetof(UCrabGameOverUI, RunResultText) == 0x0003D0, "Member 'UCrabGameOverUI::RunResultText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, DifficultyText) == 0x0003D8, "Member 'UCrabGameOverUI::DifficultyText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, ScoreText) == 0x0003E0, "Member 'UCrabGameOverUI::ScoreText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, HighScoreText) == 0x0003E8, "Member 'UCrabGameOverUI::HighScoreText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, AttemptsText) == 0x0003F0, "Member 'UCrabGameOverUI::AttemptsText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, WinsText) == 0x0003F8, "Member 'UCrabGameOverUI::WinsText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, WinStreakText) == 0x000400, "Member 'UCrabGameOverUI::WinStreakText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, IslandsSurvivedText) == 0x000408, "Member 'UCrabGameOverUI::IslandsSurvivedText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, HighestIslandReachedText) == 0x000410, "Member 'UCrabGameOverUI::HighestIslandReachedText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, TotalTimeTakenText) == 0x000418, "Member 'UCrabGameOverUI::TotalTimeTakenText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, GameOverRowUIVerticalBox) == 0x000420, "Member 'UCrabGameOverUI::GameOverRowUIVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, GameOverRowUIToSpawn) == 0x000428, "Member 'UCrabGameOverUI::GameOverRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, CompletedChallenges) == 0x000430, "Member 'UCrabGameOverUI::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, UnlockedCosmeticUIToSpawn) == 0x000448, "Member 'UCrabGameOverUI::UnlockedCosmeticUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, UnlockedCosmeticsHorizontalBox) == 0x000450, "Member 'UCrabGameOverUI::UnlockedCosmeticsHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponText) == 0x000458, "Member 'UCrabGameOverUI::RankedUpWeaponText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponMedalIconImage) == 0x000460, "Member 'UCrabGameOverUI::RankedUpWeaponMedalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponRankText) == 0x000468, "Member 'UCrabGameOverUI::RankedUpWeaponRankText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverUI, RankedUpWeaponAnim) == 0x000470, "Member 'UCrabGameOverUI::RankedUpWeaponAnim' has a wrong offset!");

// Class CrabChampions.CrabInGameMenuUI
// 0x0060 (0x0430 - 0x03D0)
class UCrabInGameMenuUI : public UCrabFocusMenuUI
{
public:
	class UCrabConfirmationPromptUI*              ConfirmationPrompt;                                // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSettingsMenuUI*                    SettingsMenu;                                      // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ResumeButton;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuickRestartButton;                                // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SettingsButton;                                    // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                FeedbackButton;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuitToLobbyButton;                                 // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuitToDesktopButton;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabConfirmationPromptUI*              QuitConfirmationPromptUI;                          // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B0[0x18];                                    // 0x0418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredFeedbackButton();
	void OnHoveredQuickRestartButton();
	void OnHoveredQuitToDesktopButton();
	void OnHoveredQuitToLobbyButton();
	void OnHoveredResumeButton();
	void OnHoveredSettingsButton();
	void OnPressedFeedbackButton();
	void OnPressedQuickRestartButton();
	void OnPressedQuitToDesktopButton();
	void OnPressedQuitToLobbyButton();
	void OnPressedResumeButton();
	void OnPressedSettingsButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInGameMenuUI">();
	}
	static class UCrabInGameMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInGameMenuUI>();
	}
};
static_assert(alignof(UCrabInGameMenuUI) == 0x000008, "Wrong alignment on UCrabInGameMenuUI");
static_assert(sizeof(UCrabInGameMenuUI) == 0x000430, "Wrong size on UCrabInGameMenuUI");
static_assert(offsetof(UCrabInGameMenuUI, ConfirmationPrompt) == 0x0003D0, "Member 'UCrabInGameMenuUI::ConfirmationPrompt' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, SettingsMenu) == 0x0003D8, "Member 'UCrabInGameMenuUI::SettingsMenu' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, ResumeButton) == 0x0003E0, "Member 'UCrabInGameMenuUI::ResumeButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuickRestartButton) == 0x0003E8, "Member 'UCrabInGameMenuUI::QuickRestartButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, SettingsButton) == 0x0003F0, "Member 'UCrabInGameMenuUI::SettingsButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, FeedbackButton) == 0x0003F8, "Member 'UCrabInGameMenuUI::FeedbackButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuitToLobbyButton) == 0x000400, "Member 'UCrabInGameMenuUI::QuitToLobbyButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuitToDesktopButton) == 0x000408, "Member 'UCrabInGameMenuUI::QuitToDesktopButton' has a wrong offset!");
static_assert(offsetof(UCrabInGameMenuUI, QuitConfirmationPromptUI) == 0x000410, "Member 'UCrabInGameMenuUI::QuitConfirmationPromptUI' has a wrong offset!");

// Class CrabChampions.CrabSettingsMenuUI
// 0x0030 (0x0400 - 0x03D0)
class UCrabSettingsMenuUI : public UCrabFocusMenuUI
{
public:
	class UCrabVideoMenuUI*                       VideoMenu;                                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSoundMenuUI*                       SoundMenu;                                         // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabControlsMenuUI*                    ControlsMenu;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                VideoButton;                                       // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SoundButton;                                       // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ControlsButton;                                    // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedControlsButton();
	void OnPressedSoundButton();
	void OnPressedVideoButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSettingsMenuUI">();
	}
	static class UCrabSettingsMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSettingsMenuUI>();
	}
};
static_assert(alignof(UCrabSettingsMenuUI) == 0x000008, "Wrong alignment on UCrabSettingsMenuUI");
static_assert(sizeof(UCrabSettingsMenuUI) == 0x000400, "Wrong size on UCrabSettingsMenuUI");
static_assert(offsetof(UCrabSettingsMenuUI, VideoMenu) == 0x0003D0, "Member 'UCrabSettingsMenuUI::VideoMenu' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, SoundMenu) == 0x0003D8, "Member 'UCrabSettingsMenuUI::SoundMenu' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, ControlsMenu) == 0x0003E0, "Member 'UCrabSettingsMenuUI::ControlsMenu' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, VideoButton) == 0x0003E8, "Member 'UCrabSettingsMenuUI::VideoButton' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, SoundButton) == 0x0003F0, "Member 'UCrabSettingsMenuUI::SoundButton' has a wrong offset!");
static_assert(offsetof(UCrabSettingsMenuUI, ControlsButton) == 0x0003F8, "Member 'UCrabSettingsMenuUI::ControlsButton' has a wrong offset!");

// Class CrabChampions.CrabGameOverRowUI
// 0x0038 (0x02F0 - 0x02B8)
class UCrabGameOverRowUI : public UCrabUI
{
public:
	class UImage*                                 MVPCrownImage;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ScoreText;                                         // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DamageDealtText;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EliminationsText;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DamageTakenText;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FlawlessIslandsText;                               // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameOverRowUI">();
	}
	static class UCrabGameOverRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameOverRowUI>();
	}
};
static_assert(alignof(UCrabGameOverRowUI) == 0x000008, "Wrong alignment on UCrabGameOverRowUI");
static_assert(sizeof(UCrabGameOverRowUI) == 0x0002F0, "Wrong size on UCrabGameOverRowUI");
static_assert(offsetof(UCrabGameOverRowUI, MVPCrownImage) == 0x0002B8, "Member 'UCrabGameOverRowUI::MVPCrownImage' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, PlayerNameText) == 0x0002C0, "Member 'UCrabGameOverRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, ScoreText) == 0x0002C8, "Member 'UCrabGameOverRowUI::ScoreText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, DamageDealtText) == 0x0002D0, "Member 'UCrabGameOverRowUI::DamageDealtText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, EliminationsText) == 0x0002D8, "Member 'UCrabGameOverRowUI::EliminationsText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, DamageTakenText) == 0x0002E0, "Member 'UCrabGameOverRowUI::DamageTakenText' has a wrong offset!");
static_assert(offsetof(UCrabGameOverRowUI, FlawlessIslandsText) == 0x0002E8, "Member 'UCrabGameOverRowUI::FlawlessIslandsText' has a wrong offset!");

// Class CrabChampions.CrabSpawnablesDA
// 0x0670 (0x06A0 - 0x0030)
class UCrabSpawnablesDA final : public UDataAsset
{
public:
	class UNiagaraSystem*                         ShieldFX;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     IceMat;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceFX;                                             // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceSound;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceThawFX;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FireFX;                                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireSound;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightningFX;                                       // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningSound;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ChainLightningFX;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PoisonFX;                                          // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PoisonSound;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ArcaneFX;                                          // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ArcaneSound;                                       // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         GenericExplosionFX;                                // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GenericExplosionSound;                             // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceExplosionFX;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceExplosionSound;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FireExplosionFX;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireExplosionSound;                                // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightningExplosionFX;                              // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningExplosionSound;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PoisonExplosionFX;                                 // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PoisonExplosionSound;                              // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCrabWeaponDA*>                  Weapons;                                           // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabAbilityDA*>                 Abilities;                                         // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabMeleeDA*>                   MeleeWeapons;                                      // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabWeaponModDA*>               WeaponMods;                                        // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabGrenadeModDA*>              GrenadeMods;                                       // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabPerkDA*>                    Perks;                                             // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabRelicDA*>                   Relics;                                            // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UCrabConsumableDA*>              Consumables;                                       // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabHealthPickup>          HealthPickup;                                      // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabCrystalPickup>         CrystalPickup;                                     // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BananaAmbienceFX;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CriticalBlastFX;                                   // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CriticalBlastSound;                                // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      TimeBoltDA;                                        // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      UltraShotDA;                                       // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ReloadArcDA;                                       // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      LinkDA;                                            // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      DrillDA;                                           // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      BubbleDA;                                          // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      DaggerDA;                                          // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ScytheDA;                                          // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      PiercingWaveDA;                                    // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ArcaneBlastDA;                                     // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ShotgunDA;                                         // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      MaceBallDA;                                        // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      FireworkDA;                                        // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ThornDA;                                           // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      SparkDA;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ProximityBarrageDA;                                // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      HomingBladeDA;                                     // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      BombDA;                                            // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      TorpedoDA;                                         // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      FireballDA;                                        // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      SharpenedAxeDA;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      TriangleDA;                                        // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      SpinningBladeDA;                                   // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          Landmine;                                          // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          HomingBarrel;                                      // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          SporeMushroom;                                     // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          UltraMushroom;                                     // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            CrimsonHazeDamageArea;                             // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            GiantDrillDamageArea;                              // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            ScytheVortexDamageArea;                            // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            CrystalBarrageDamageArea;                          // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnergyRingDamageArea;                              // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            BlackHoleDamageArea;                               // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            IceStormDamageArea;                                // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            FireStormDamageArea;                               // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            LightningStormDamageArea;                          // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            PoisonStormDamageArea;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            IceExplosionDamageArea;                            // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            FireExplosionDamageArea;                           // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            LightningExplosionDamageArea;                      // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            PoisonExplosionDamageArea;                         // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                CriticalArrow;                                     // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                IceStrike;                                         // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                FireStrike;                                        // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                LightningStrike;                                   // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                PoisonStrike;                                      // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                SpikeStrike;                                       // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                CrystalStrike;                                     // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                CriticalLightning;                                 // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SonicBoomFX;                                       // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SonicBoomSound;                                    // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         HealFX;                                            // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HealSound;                                         // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ShockwaveFX;                                       // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ShockwaveSound;                                    // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BulletproofFX;                                     // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BulletproofSound;                                  // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceAuraFX;                                         // 0x0360(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceAuraSound;                                      // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         FireAuraFX;                                        // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireAuraSound;                                     // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         LightningAuraFX;                                   // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LightningAuraSound;                                // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PoisonAuraFX;                                      // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PoisonAuraSound;                                   // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         RareTreasureFX;                                    // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              RareTreasureSound;                                 // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ExplodingEnemiesFX;                                // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ExplodingEnemiesSound;                             // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PowerslideFX;                                      // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PowerslideSound;                                   // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         IceDashFX;                                         // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              IceDashSound;                                      // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                SentryTurret;                                      // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                SniperTurret;                                      // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                FireTurret;                                        // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                PoisonTurret;                                      // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTurret>                MortarTurret;                                      // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabTotem>>         Totems;                                            // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      EnemyMirroredProjectileDA;                         // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      EnemyShrapnelProjectileDA;                         // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      EnemyHomingThornDA;                                // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          EnemyHomingBarrel;                                 // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyIceDamageArea;                                // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyFireDamageArea;                               // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyLightningDamageArea;                          // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyPoisonDamageArea;                             // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDamageArea>            EnemyEnergyRingDamageArea;                         // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabStrike>                EnemySpikeStrike;                                  // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabHarvestArea>>   HarvestAreas;                                      // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  DemolitionDestructibles;                           // 0x0478(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ACrabDestructible>>  ParkourDestructibles;                              // 0x0488(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabDestructible>          CrystalAsteroid;                                   // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabSpawnPoint>            RewardSpawnPoint;                                  // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 DamageChest;                                       // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 CriticalChest;                                     // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 ElementalChest;                                    // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SpeedChest;                                        // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 LuckChest;                                         // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 HealthChest;                                       // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 EconomyChest;                                      // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SkillChest;                                        // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 GreedChest;                                        // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 UpgradeChest;                                      // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 RandomChest;                                       // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 RelicChest;                                        // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SpikedChest;                                       // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 EpicChest;                                         // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 LegendaryChest;                                    // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 HealingChest;                                      // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 KeyChest;                                          // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabChest>                 SecretChest;                                       // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              RarePickupSound;                                   // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EpicPickupSound;                                   // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LegendaryPickupSound;                              // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PurchaseSound;                                     // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BossMusic;                                         // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              VictoryMusic;                                      // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabTotem>                 RerollTotem;                                       // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabShopPedestal>          ShopPedestal;                                      // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabEnemyC>                TargetDummy;                                       // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              FindSafeSpawnLocsEnvQuery;                         // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              FindBossLootSpawnLocsEnvQuery;                     // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                NewRunPortal;                                      // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ContinueRunPortal;                                 // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ArenaPortal;                                       // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                HordePortal;                                       // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                WavesPortal;                                       // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                HarvestPortal;                                     // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                DemolitionPortal;                                  // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ParkourPortal;                                     // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ShopPortal;                                        // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                ElitePortal;                                       // 0x05D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                BossPortal;                                        // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                BiomePortal;                                       // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                CrabIslandPortal;                                  // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACrabPortal>                LoopPortal;                                        // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DamageIcon;                                        // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            CriticalIcon;                                      // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ElementalIcon;                                     // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SpeedIcon;                                         // 0x0618(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            LuckIcon;                                          // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            HealthIcon;                                        // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            EconomyIcon;                                       // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SkillIcon;                                         // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GreedIcon;                                         // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            UpgradeIcon;                                       // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RandomIcon;                                        // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RelicIcon;                                         // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SpikedIcon;                                        // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BronzeMedalIcon;                                   // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SilverMedalIcon;                                   // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GoldMedalIcon;                                     // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SapphireMedalIcon;                                 // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EmeraldMedalIcon;                                  // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RubyMedalIcon;                                     // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DiamondMedalIcon;                                  // 0x0698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSpawnablesDA">();
	}
	static class UCrabSpawnablesDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSpawnablesDA>();
	}
};
static_assert(alignof(UCrabSpawnablesDA) == 0x000008, "Wrong alignment on UCrabSpawnablesDA");
static_assert(sizeof(UCrabSpawnablesDA) == 0x0006A0, "Wrong size on UCrabSpawnablesDA");
static_assert(offsetof(UCrabSpawnablesDA, ShieldFX) == 0x000030, "Member 'UCrabSpawnablesDA::ShieldFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceMat) == 0x000038, "Member 'UCrabSpawnablesDA::IceMat' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceFX) == 0x000040, "Member 'UCrabSpawnablesDA::IceFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceSound) == 0x000048, "Member 'UCrabSpawnablesDA::IceSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceThawFX) == 0x000050, "Member 'UCrabSpawnablesDA::IceThawFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireFX) == 0x000058, "Member 'UCrabSpawnablesDA::FireFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireSound) == 0x000060, "Member 'UCrabSpawnablesDA::FireSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningFX) == 0x000068, "Member 'UCrabSpawnablesDA::LightningFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningSound) == 0x000070, "Member 'UCrabSpawnablesDA::LightningSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ChainLightningFX) == 0x000078, "Member 'UCrabSpawnablesDA::ChainLightningFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonFX) == 0x000080, "Member 'UCrabSpawnablesDA::PoisonFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonSound) == 0x000088, "Member 'UCrabSpawnablesDA::PoisonSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArcaneFX) == 0x000090, "Member 'UCrabSpawnablesDA::ArcaneFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArcaneSound) == 0x000098, "Member 'UCrabSpawnablesDA::ArcaneSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GenericExplosionFX) == 0x0000A0, "Member 'UCrabSpawnablesDA::GenericExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GenericExplosionSound) == 0x0000A8, "Member 'UCrabSpawnablesDA::GenericExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceExplosionFX) == 0x0000B0, "Member 'UCrabSpawnablesDA::IceExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceExplosionSound) == 0x0000B8, "Member 'UCrabSpawnablesDA::IceExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireExplosionFX) == 0x0000C0, "Member 'UCrabSpawnablesDA::FireExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireExplosionSound) == 0x0000C8, "Member 'UCrabSpawnablesDA::FireExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningExplosionFX) == 0x0000D0, "Member 'UCrabSpawnablesDA::LightningExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningExplosionSound) == 0x0000D8, "Member 'UCrabSpawnablesDA::LightningExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonExplosionFX) == 0x0000E0, "Member 'UCrabSpawnablesDA::PoisonExplosionFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonExplosionSound) == 0x0000E8, "Member 'UCrabSpawnablesDA::PoisonExplosionSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Weapons) == 0x0000F0, "Member 'UCrabSpawnablesDA::Weapons' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Abilities) == 0x000100, "Member 'UCrabSpawnablesDA::Abilities' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MeleeWeapons) == 0x000110, "Member 'UCrabSpawnablesDA::MeleeWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, WeaponMods) == 0x000120, "Member 'UCrabSpawnablesDA::WeaponMods' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GrenadeMods) == 0x000130, "Member 'UCrabSpawnablesDA::GrenadeMods' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Perks) == 0x000140, "Member 'UCrabSpawnablesDA::Perks' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Relics) == 0x000150, "Member 'UCrabSpawnablesDA::Relics' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Consumables) == 0x000160, "Member 'UCrabSpawnablesDA::Consumables' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthPickup) == 0x000170, "Member 'UCrabSpawnablesDA::HealthPickup' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalPickup) == 0x000178, "Member 'UCrabSpawnablesDA::CrystalPickup' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BananaAmbienceFX) == 0x000180, "Member 'UCrabSpawnablesDA::BananaAmbienceFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalBlastFX) == 0x000188, "Member 'UCrabSpawnablesDA::CriticalBlastFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalBlastSound) == 0x000190, "Member 'UCrabSpawnablesDA::CriticalBlastSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TimeBoltDA) == 0x000198, "Member 'UCrabSpawnablesDA::TimeBoltDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UltraShotDA) == 0x0001A0, "Member 'UCrabSpawnablesDA::UltraShotDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ReloadArcDA) == 0x0001A8, "Member 'UCrabSpawnablesDA::ReloadArcDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LinkDA) == 0x0001B0, "Member 'UCrabSpawnablesDA::LinkDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DrillDA) == 0x0001B8, "Member 'UCrabSpawnablesDA::DrillDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BubbleDA) == 0x0001C0, "Member 'UCrabSpawnablesDA::BubbleDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DaggerDA) == 0x0001C8, "Member 'UCrabSpawnablesDA::DaggerDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ScytheDA) == 0x0001D0, "Member 'UCrabSpawnablesDA::ScytheDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PiercingWaveDA) == 0x0001D8, "Member 'UCrabSpawnablesDA::PiercingWaveDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArcaneBlastDA) == 0x0001E0, "Member 'UCrabSpawnablesDA::ArcaneBlastDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShotgunDA) == 0x0001E8, "Member 'UCrabSpawnablesDA::ShotgunDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MaceBallDA) == 0x0001F0, "Member 'UCrabSpawnablesDA::MaceBallDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireworkDA) == 0x0001F8, "Member 'UCrabSpawnablesDA::FireworkDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ThornDA) == 0x000200, "Member 'UCrabSpawnablesDA::ThornDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SparkDA) == 0x000208, "Member 'UCrabSpawnablesDA::SparkDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ProximityBarrageDA) == 0x000210, "Member 'UCrabSpawnablesDA::ProximityBarrageDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HomingBladeDA) == 0x000218, "Member 'UCrabSpawnablesDA::HomingBladeDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BombDA) == 0x000220, "Member 'UCrabSpawnablesDA::BombDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TorpedoDA) == 0x000228, "Member 'UCrabSpawnablesDA::TorpedoDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireballDA) == 0x000230, "Member 'UCrabSpawnablesDA::FireballDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SharpenedAxeDA) == 0x000238, "Member 'UCrabSpawnablesDA::SharpenedAxeDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TriangleDA) == 0x000240, "Member 'UCrabSpawnablesDA::TriangleDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpinningBladeDA) == 0x000248, "Member 'UCrabSpawnablesDA::SpinningBladeDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Landmine) == 0x000250, "Member 'UCrabSpawnablesDA::Landmine' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HomingBarrel) == 0x000258, "Member 'UCrabSpawnablesDA::HomingBarrel' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SporeMushroom) == 0x000260, "Member 'UCrabSpawnablesDA::SporeMushroom' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UltraMushroom) == 0x000268, "Member 'UCrabSpawnablesDA::UltraMushroom' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrimsonHazeDamageArea) == 0x000270, "Member 'UCrabSpawnablesDA::CrimsonHazeDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GiantDrillDamageArea) == 0x000278, "Member 'UCrabSpawnablesDA::GiantDrillDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ScytheVortexDamageArea) == 0x000280, "Member 'UCrabSpawnablesDA::ScytheVortexDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalBarrageDamageArea) == 0x000288, "Member 'UCrabSpawnablesDA::CrystalBarrageDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnergyRingDamageArea) == 0x000290, "Member 'UCrabSpawnablesDA::EnergyRingDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BlackHoleDamageArea) == 0x000298, "Member 'UCrabSpawnablesDA::BlackHoleDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceStormDamageArea) == 0x0002A0, "Member 'UCrabSpawnablesDA::IceStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireStormDamageArea) == 0x0002A8, "Member 'UCrabSpawnablesDA::FireStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningStormDamageArea) == 0x0002B0, "Member 'UCrabSpawnablesDA::LightningStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonStormDamageArea) == 0x0002B8, "Member 'UCrabSpawnablesDA::PoisonStormDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceExplosionDamageArea) == 0x0002C0, "Member 'UCrabSpawnablesDA::IceExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireExplosionDamageArea) == 0x0002C8, "Member 'UCrabSpawnablesDA::FireExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningExplosionDamageArea) == 0x0002D0, "Member 'UCrabSpawnablesDA::LightningExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonExplosionDamageArea) == 0x0002D8, "Member 'UCrabSpawnablesDA::PoisonExplosionDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalArrow) == 0x0002E0, "Member 'UCrabSpawnablesDA::CriticalArrow' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceStrike) == 0x0002E8, "Member 'UCrabSpawnablesDA::IceStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireStrike) == 0x0002F0, "Member 'UCrabSpawnablesDA::FireStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningStrike) == 0x0002F8, "Member 'UCrabSpawnablesDA::LightningStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonStrike) == 0x000300, "Member 'UCrabSpawnablesDA::PoisonStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpikeStrike) == 0x000308, "Member 'UCrabSpawnablesDA::SpikeStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalStrike) == 0x000310, "Member 'UCrabSpawnablesDA::CrystalStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalLightning) == 0x000318, "Member 'UCrabSpawnablesDA::CriticalLightning' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SonicBoomFX) == 0x000320, "Member 'UCrabSpawnablesDA::SonicBoomFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SonicBoomSound) == 0x000328, "Member 'UCrabSpawnablesDA::SonicBoomSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealFX) == 0x000330, "Member 'UCrabSpawnablesDA::HealFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealSound) == 0x000338, "Member 'UCrabSpawnablesDA::HealSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShockwaveFX) == 0x000340, "Member 'UCrabSpawnablesDA::ShockwaveFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShockwaveSound) == 0x000348, "Member 'UCrabSpawnablesDA::ShockwaveSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BulletproofFX) == 0x000350, "Member 'UCrabSpawnablesDA::BulletproofFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BulletproofSound) == 0x000358, "Member 'UCrabSpawnablesDA::BulletproofSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceAuraFX) == 0x000360, "Member 'UCrabSpawnablesDA::IceAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceAuraSound) == 0x000368, "Member 'UCrabSpawnablesDA::IceAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireAuraFX) == 0x000370, "Member 'UCrabSpawnablesDA::FireAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireAuraSound) == 0x000378, "Member 'UCrabSpawnablesDA::FireAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningAuraFX) == 0x000380, "Member 'UCrabSpawnablesDA::LightningAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LightningAuraSound) == 0x000388, "Member 'UCrabSpawnablesDA::LightningAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonAuraFX) == 0x000390, "Member 'UCrabSpawnablesDA::PoisonAuraFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonAuraSound) == 0x000398, "Member 'UCrabSpawnablesDA::PoisonAuraSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RareTreasureFX) == 0x0003A0, "Member 'UCrabSpawnablesDA::RareTreasureFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RareTreasureSound) == 0x0003A8, "Member 'UCrabSpawnablesDA::RareTreasureSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ExplodingEnemiesFX) == 0x0003B0, "Member 'UCrabSpawnablesDA::ExplodingEnemiesFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ExplodingEnemiesSound) == 0x0003B8, "Member 'UCrabSpawnablesDA::ExplodingEnemiesSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PowerslideFX) == 0x0003C0, "Member 'UCrabSpawnablesDA::PowerslideFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PowerslideSound) == 0x0003C8, "Member 'UCrabSpawnablesDA::PowerslideSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceDashFX) == 0x0003D0, "Member 'UCrabSpawnablesDA::IceDashFX' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, IceDashSound) == 0x0003D8, "Member 'UCrabSpawnablesDA::IceDashSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SentryTurret) == 0x0003E0, "Member 'UCrabSpawnablesDA::SentryTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SniperTurret) == 0x0003E8, "Member 'UCrabSpawnablesDA::SniperTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FireTurret) == 0x0003F0, "Member 'UCrabSpawnablesDA::FireTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PoisonTurret) == 0x0003F8, "Member 'UCrabSpawnablesDA::PoisonTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, MortarTurret) == 0x000400, "Member 'UCrabSpawnablesDA::MortarTurret' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, Totems) == 0x000408, "Member 'UCrabSpawnablesDA::Totems' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyMirroredProjectileDA) == 0x000418, "Member 'UCrabSpawnablesDA::EnemyMirroredProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyShrapnelProjectileDA) == 0x000420, "Member 'UCrabSpawnablesDA::EnemyShrapnelProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyHomingThornDA) == 0x000428, "Member 'UCrabSpawnablesDA::EnemyHomingThornDA' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyHomingBarrel) == 0x000430, "Member 'UCrabSpawnablesDA::EnemyHomingBarrel' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyIceDamageArea) == 0x000438, "Member 'UCrabSpawnablesDA::EnemyIceDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyFireDamageArea) == 0x000440, "Member 'UCrabSpawnablesDA::EnemyFireDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyLightningDamageArea) == 0x000448, "Member 'UCrabSpawnablesDA::EnemyLightningDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyPoisonDamageArea) == 0x000450, "Member 'UCrabSpawnablesDA::EnemyPoisonDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemyEnergyRingDamageArea) == 0x000458, "Member 'UCrabSpawnablesDA::EnemyEnergyRingDamageArea' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EnemySpikeStrike) == 0x000460, "Member 'UCrabSpawnablesDA::EnemySpikeStrike' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HarvestAreas) == 0x000468, "Member 'UCrabSpawnablesDA::HarvestAreas' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DemolitionDestructibles) == 0x000478, "Member 'UCrabSpawnablesDA::DemolitionDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ParkourDestructibles) == 0x000488, "Member 'UCrabSpawnablesDA::ParkourDestructibles' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrystalAsteroid) == 0x000498, "Member 'UCrabSpawnablesDA::CrystalAsteroid' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RewardSpawnPoint) == 0x0004A0, "Member 'UCrabSpawnablesDA::RewardSpawnPoint' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DamageChest) == 0x0004A8, "Member 'UCrabSpawnablesDA::DamageChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalChest) == 0x0004B0, "Member 'UCrabSpawnablesDA::CriticalChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ElementalChest) == 0x0004B8, "Member 'UCrabSpawnablesDA::ElementalChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpeedChest) == 0x0004C0, "Member 'UCrabSpawnablesDA::SpeedChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LuckChest) == 0x0004C8, "Member 'UCrabSpawnablesDA::LuckChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthChest) == 0x0004D0, "Member 'UCrabSpawnablesDA::HealthChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EconomyChest) == 0x0004D8, "Member 'UCrabSpawnablesDA::EconomyChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SkillChest) == 0x0004E0, "Member 'UCrabSpawnablesDA::SkillChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GreedChest) == 0x0004E8, "Member 'UCrabSpawnablesDA::GreedChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UpgradeChest) == 0x0004F0, "Member 'UCrabSpawnablesDA::UpgradeChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RandomChest) == 0x0004F8, "Member 'UCrabSpawnablesDA::RandomChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RelicChest) == 0x000500, "Member 'UCrabSpawnablesDA::RelicChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpikedChest) == 0x000508, "Member 'UCrabSpawnablesDA::SpikedChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EpicChest) == 0x000510, "Member 'UCrabSpawnablesDA::EpicChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LegendaryChest) == 0x000518, "Member 'UCrabSpawnablesDA::LegendaryChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealingChest) == 0x000520, "Member 'UCrabSpawnablesDA::HealingChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, KeyChest) == 0x000528, "Member 'UCrabSpawnablesDA::KeyChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SecretChest) == 0x000530, "Member 'UCrabSpawnablesDA::SecretChest' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RarePickupSound) == 0x000538, "Member 'UCrabSpawnablesDA::RarePickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EpicPickupSound) == 0x000540, "Member 'UCrabSpawnablesDA::EpicPickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LegendaryPickupSound) == 0x000548, "Member 'UCrabSpawnablesDA::LegendaryPickupSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, PurchaseSound) == 0x000550, "Member 'UCrabSpawnablesDA::PurchaseSound' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BossMusic) == 0x000558, "Member 'UCrabSpawnablesDA::BossMusic' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, VictoryMusic) == 0x000560, "Member 'UCrabSpawnablesDA::VictoryMusic' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RerollTotem) == 0x000568, "Member 'UCrabSpawnablesDA::RerollTotem' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShopPedestal) == 0x000570, "Member 'UCrabSpawnablesDA::ShopPedestal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, TargetDummy) == 0x000578, "Member 'UCrabSpawnablesDA::TargetDummy' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FindSafeSpawnLocsEnvQuery) == 0x000580, "Member 'UCrabSpawnablesDA::FindSafeSpawnLocsEnvQuery' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, FindBossLootSpawnLocsEnvQuery) == 0x000588, "Member 'UCrabSpawnablesDA::FindBossLootSpawnLocsEnvQuery' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, NewRunPortal) == 0x000590, "Member 'UCrabSpawnablesDA::NewRunPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ContinueRunPortal) == 0x000598, "Member 'UCrabSpawnablesDA::ContinueRunPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ArenaPortal) == 0x0005A0, "Member 'UCrabSpawnablesDA::ArenaPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HordePortal) == 0x0005A8, "Member 'UCrabSpawnablesDA::HordePortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, WavesPortal) == 0x0005B0, "Member 'UCrabSpawnablesDA::WavesPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HarvestPortal) == 0x0005B8, "Member 'UCrabSpawnablesDA::HarvestPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DemolitionPortal) == 0x0005C0, "Member 'UCrabSpawnablesDA::DemolitionPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ParkourPortal) == 0x0005C8, "Member 'UCrabSpawnablesDA::ParkourPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ShopPortal) == 0x0005D0, "Member 'UCrabSpawnablesDA::ShopPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ElitePortal) == 0x0005D8, "Member 'UCrabSpawnablesDA::ElitePortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BossPortal) == 0x0005E0, "Member 'UCrabSpawnablesDA::BossPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BiomePortal) == 0x0005E8, "Member 'UCrabSpawnablesDA::BiomePortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CrabIslandPortal) == 0x0005F0, "Member 'UCrabSpawnablesDA::CrabIslandPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LoopPortal) == 0x0005F8, "Member 'UCrabSpawnablesDA::LoopPortal' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DamageIcon) == 0x000600, "Member 'UCrabSpawnablesDA::DamageIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, CriticalIcon) == 0x000608, "Member 'UCrabSpawnablesDA::CriticalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, ElementalIcon) == 0x000610, "Member 'UCrabSpawnablesDA::ElementalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpeedIcon) == 0x000618, "Member 'UCrabSpawnablesDA::SpeedIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, LuckIcon) == 0x000620, "Member 'UCrabSpawnablesDA::LuckIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, HealthIcon) == 0x000628, "Member 'UCrabSpawnablesDA::HealthIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EconomyIcon) == 0x000630, "Member 'UCrabSpawnablesDA::EconomyIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SkillIcon) == 0x000638, "Member 'UCrabSpawnablesDA::SkillIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GreedIcon) == 0x000640, "Member 'UCrabSpawnablesDA::GreedIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, UpgradeIcon) == 0x000648, "Member 'UCrabSpawnablesDA::UpgradeIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RandomIcon) == 0x000650, "Member 'UCrabSpawnablesDA::RandomIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RelicIcon) == 0x000658, "Member 'UCrabSpawnablesDA::RelicIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SpikedIcon) == 0x000660, "Member 'UCrabSpawnablesDA::SpikedIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, BronzeMedalIcon) == 0x000668, "Member 'UCrabSpawnablesDA::BronzeMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SilverMedalIcon) == 0x000670, "Member 'UCrabSpawnablesDA::SilverMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, GoldMedalIcon) == 0x000678, "Member 'UCrabSpawnablesDA::GoldMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, SapphireMedalIcon) == 0x000680, "Member 'UCrabSpawnablesDA::SapphireMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, EmeraldMedalIcon) == 0x000688, "Member 'UCrabSpawnablesDA::EmeraldMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, RubyMedalIcon) == 0x000690, "Member 'UCrabSpawnablesDA::RubyMedalIcon' has a wrong offset!");
static_assert(offsetof(UCrabSpawnablesDA, DiamondMedalIcon) == 0x000698, "Member 'UCrabSpawnablesDA::DiamondMedalIcon' has a wrong offset!");

// Class CrabChampions.CrabInventoryUI
// 0x0160 (0x0530 - 0x03D0)
class UCrabInventoryUI : public UCrabFocusMenuUI
{
public:
	class ACrabPS*                                OwningPS;                                          // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInventorySlotUI>       InventorySlotUIToSpawn;                            // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInventorySlotUI*                   HoveredInventorySlotUI;                            // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CrystalsText;                                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KeysText;                                          // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      WeaponModUniformGridPanel;                         // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      GrenadeModUniformGridPanel;                        // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      PerkUniformGridPanel;                              // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      RelicUniformGridPanel;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SelectedSlotSizeBox;                               // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectedSlotBackgroundImage;                       // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectedSlotIconImage;                             // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotNameText;                              // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotLevelText;                             // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotRarityText;                            // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotEnhanceableHorizontalBox;              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotLootPoolText;                          // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotDescriptionText;                       // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotLevelDescriptionText;                  // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotCooldownHorizontalBox;                 // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotCooldownText;                          // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         EnhancementAHorizontalBox;                         // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EnhancementAText;                                  // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         EnhancementBHorizontalBox;                         // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EnhancementBText;                                  // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         EnhancementCHorizontalBox;                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EnhancementCText;                                  // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotAccumulatedBuffHorizontalBox;          // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotAccumulatedBuffText;                   // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SelectedSlotDropButtonOverlay;                     // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotDropText;                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SelectedSlotLockedIcon;                            // 0x04C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SelectedSlotCostHorizontalBox;                     // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SelectedSlotCostText;                              // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              SelectedSlotUnlockSound;                           // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponDamageStatText;                              // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FireRateStatText;                                  // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilityDamageStatText;                             // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeDamageStatText;                               // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GlobalDamageStatText;                              // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CriticalHitChanceStatText;                         // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CriticalHitDamageStatText;                         // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CrystalGainStatText;                               // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IncomingDamageStatText;                            // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventoryUI">();
	}
	static class UCrabInventoryUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventoryUI>();
	}
};
static_assert(alignof(UCrabInventoryUI) == 0x000008, "Wrong alignment on UCrabInventoryUI");
static_assert(sizeof(UCrabInventoryUI) == 0x000530, "Wrong size on UCrabInventoryUI");
static_assert(offsetof(UCrabInventoryUI, OwningPS) == 0x0003D0, "Member 'UCrabInventoryUI::OwningPS' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, InventorySlotUIToSpawn) == 0x0003D8, "Member 'UCrabInventoryUI::InventorySlotUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, HoveredInventorySlotUI) == 0x0003E0, "Member 'UCrabInventoryUI::HoveredInventorySlotUI' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CrystalsText) == 0x0003E8, "Member 'UCrabInventoryUI::CrystalsText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, KeysText) == 0x0003F0, "Member 'UCrabInventoryUI::KeysText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, WeaponModUniformGridPanel) == 0x0003F8, "Member 'UCrabInventoryUI::WeaponModUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, GrenadeModUniformGridPanel) == 0x000400, "Member 'UCrabInventoryUI::GrenadeModUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, PerkUniformGridPanel) == 0x000408, "Member 'UCrabInventoryUI::PerkUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, RelicUniformGridPanel) == 0x000410, "Member 'UCrabInventoryUI::RelicUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotSizeBox) == 0x000418, "Member 'UCrabInventoryUI::SelectedSlotSizeBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotBackgroundImage) == 0x000420, "Member 'UCrabInventoryUI::SelectedSlotBackgroundImage' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotIconImage) == 0x000428, "Member 'UCrabInventoryUI::SelectedSlotIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotNameText) == 0x000430, "Member 'UCrabInventoryUI::SelectedSlotNameText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLevelText) == 0x000438, "Member 'UCrabInventoryUI::SelectedSlotLevelText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotRarityText) == 0x000440, "Member 'UCrabInventoryUI::SelectedSlotRarityText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotEnhanceableHorizontalBox) == 0x000448, "Member 'UCrabInventoryUI::SelectedSlotEnhanceableHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLootPoolText) == 0x000450, "Member 'UCrabInventoryUI::SelectedSlotLootPoolText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotDescriptionText) == 0x000458, "Member 'UCrabInventoryUI::SelectedSlotDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLevelDescriptionText) == 0x000460, "Member 'UCrabInventoryUI::SelectedSlotLevelDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCooldownHorizontalBox) == 0x000468, "Member 'UCrabInventoryUI::SelectedSlotCooldownHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCooldownText) == 0x000470, "Member 'UCrabInventoryUI::SelectedSlotCooldownText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementAHorizontalBox) == 0x000478, "Member 'UCrabInventoryUI::EnhancementAHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementAText) == 0x000480, "Member 'UCrabInventoryUI::EnhancementAText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementBHorizontalBox) == 0x000488, "Member 'UCrabInventoryUI::EnhancementBHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementBText) == 0x000490, "Member 'UCrabInventoryUI::EnhancementBText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementCHorizontalBox) == 0x000498, "Member 'UCrabInventoryUI::EnhancementCHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, EnhancementCText) == 0x0004A0, "Member 'UCrabInventoryUI::EnhancementCText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotAccumulatedBuffHorizontalBox) == 0x0004A8, "Member 'UCrabInventoryUI::SelectedSlotAccumulatedBuffHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotAccumulatedBuffText) == 0x0004B0, "Member 'UCrabInventoryUI::SelectedSlotAccumulatedBuffText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotDropButtonOverlay) == 0x0004B8, "Member 'UCrabInventoryUI::SelectedSlotDropButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotDropText) == 0x0004C0, "Member 'UCrabInventoryUI::SelectedSlotDropText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotLockedIcon) == 0x0004C8, "Member 'UCrabInventoryUI::SelectedSlotLockedIcon' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCostHorizontalBox) == 0x0004D0, "Member 'UCrabInventoryUI::SelectedSlotCostHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotCostText) == 0x0004D8, "Member 'UCrabInventoryUI::SelectedSlotCostText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, SelectedSlotUnlockSound) == 0x0004E0, "Member 'UCrabInventoryUI::SelectedSlotUnlockSound' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, WeaponDamageStatText) == 0x0004E8, "Member 'UCrabInventoryUI::WeaponDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, FireRateStatText) == 0x0004F0, "Member 'UCrabInventoryUI::FireRateStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, AbilityDamageStatText) == 0x0004F8, "Member 'UCrabInventoryUI::AbilityDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, MeleeDamageStatText) == 0x000500, "Member 'UCrabInventoryUI::MeleeDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, GlobalDamageStatText) == 0x000508, "Member 'UCrabInventoryUI::GlobalDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CriticalHitChanceStatText) == 0x000510, "Member 'UCrabInventoryUI::CriticalHitChanceStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CriticalHitDamageStatText) == 0x000518, "Member 'UCrabInventoryUI::CriticalHitDamageStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, CrystalGainStatText) == 0x000520, "Member 'UCrabInventoryUI::CrystalGainStatText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryUI, IncomingDamageStatText) == 0x000528, "Member 'UCrabInventoryUI::IncomingDamageStatText' has a wrong offset!");

// Class CrabChampions.CrabHealthBarUI
// 0x00D0 (0x0388 - 0x02B8)
class UCrabHealthBarUI : public UCrabUI
{
public:
	class ACrabC*                                 OwningC;                                           // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BuffText;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OwnerNameText;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ArmorPlatesHorizontalBox;                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           HealthBar;                                         // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           RecentDamageHealthBar;                             // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentHealthText;                                 // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentMaxHealthText;                              // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ConfusionStackOverlay;                             // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ConfusionStackText;                                // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               WeakStackOverlay;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeakStackText;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               SlowStackOverlay;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SlowStackText;                                     // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               IceStackOverlay;                                   // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IceStackText;                                      // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               FireStackOverlay;                                  // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FireStackText;                                     // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               LightningStackOverlay;                             // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LightningStackText;                                // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               PoisonStackOverlay;                                // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PoisonStackText;                                   // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               ArcaneStackOverlay;                                // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ArcaneStackText;                                   // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B1[0x10];                                    // 0x0378(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHealthBarUI">();
	}
	static class UCrabHealthBarUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabHealthBarUI>();
	}
};
static_assert(alignof(UCrabHealthBarUI) == 0x000008, "Wrong alignment on UCrabHealthBarUI");
static_assert(sizeof(UCrabHealthBarUI) == 0x000388, "Wrong size on UCrabHealthBarUI");
static_assert(offsetof(UCrabHealthBarUI, OwningC) == 0x0002B8, "Member 'UCrabHealthBarUI::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, BuffText) == 0x0002C0, "Member 'UCrabHealthBarUI::BuffText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, OwnerNameText) == 0x0002C8, "Member 'UCrabHealthBarUI::OwnerNameText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ArmorPlatesHorizontalBox) == 0x0002D0, "Member 'UCrabHealthBarUI::ArmorPlatesHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, HealthBar) == 0x0002D8, "Member 'UCrabHealthBarUI::HealthBar' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, RecentDamageHealthBar) == 0x0002E0, "Member 'UCrabHealthBarUI::RecentDamageHealthBar' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, CurrentHealthText) == 0x0002E8, "Member 'UCrabHealthBarUI::CurrentHealthText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, CurrentMaxHealthText) == 0x0002F0, "Member 'UCrabHealthBarUI::CurrentMaxHealthText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ConfusionStackOverlay) == 0x0002F8, "Member 'UCrabHealthBarUI::ConfusionStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ConfusionStackText) == 0x000300, "Member 'UCrabHealthBarUI::ConfusionStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, WeakStackOverlay) == 0x000308, "Member 'UCrabHealthBarUI::WeakStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, WeakStackText) == 0x000310, "Member 'UCrabHealthBarUI::WeakStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, SlowStackOverlay) == 0x000318, "Member 'UCrabHealthBarUI::SlowStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, SlowStackText) == 0x000320, "Member 'UCrabHealthBarUI::SlowStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, IceStackOverlay) == 0x000328, "Member 'UCrabHealthBarUI::IceStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, IceStackText) == 0x000330, "Member 'UCrabHealthBarUI::IceStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, FireStackOverlay) == 0x000338, "Member 'UCrabHealthBarUI::FireStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, FireStackText) == 0x000340, "Member 'UCrabHealthBarUI::FireStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, LightningStackOverlay) == 0x000348, "Member 'UCrabHealthBarUI::LightningStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, LightningStackText) == 0x000350, "Member 'UCrabHealthBarUI::LightningStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, PoisonStackOverlay) == 0x000358, "Member 'UCrabHealthBarUI::PoisonStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, PoisonStackText) == 0x000360, "Member 'UCrabHealthBarUI::PoisonStackText' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ArcaneStackOverlay) == 0x000368, "Member 'UCrabHealthBarUI::ArcaneStackOverlay' has a wrong offset!");
static_assert(offsetof(UCrabHealthBarUI, ArcaneStackText) == 0x000370, "Member 'UCrabHealthBarUI::ArcaneStackText' has a wrong offset!");

// Class CrabChampions.CrabInteractUI
// 0x00A0 (0x0358 - 0x02B8)
class UCrabInteractUI : public UCrabUI
{
public:
	class UImage*                                 IconImage;                                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TypeText;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameText;                                          // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DescriptionText;                                   // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RarityBorder;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LootPoolText;                                      // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InteractKeyText;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 InteractControllerIcon;                            // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InteractMessageText;                               // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         CostHorizontalBox;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrystalIconImage;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KeyIconImage;                                      // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HealthIconImage;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CostText;                                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SalvageHorizontalBox;                              // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SalvageKeyText;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SalvageControllerIcon;                             // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SalvageRewardText;                                 // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           SalvageProgressBar;                                // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       SalvageAnim;                                       // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInteractUI">();
	}
	static class UCrabInteractUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInteractUI>();
	}
};
static_assert(alignof(UCrabInteractUI) == 0x000008, "Wrong alignment on UCrabInteractUI");
static_assert(sizeof(UCrabInteractUI) == 0x000358, "Wrong size on UCrabInteractUI");
static_assert(offsetof(UCrabInteractUI, IconImage) == 0x0002B8, "Member 'UCrabInteractUI::IconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, TypeText) == 0x0002C0, "Member 'UCrabInteractUI::TypeText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, NameText) == 0x0002C8, "Member 'UCrabInteractUI::NameText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, DescriptionText) == 0x0002D0, "Member 'UCrabInteractUI::DescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, RarityBorder) == 0x0002D8, "Member 'UCrabInteractUI::RarityBorder' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, LootPoolText) == 0x0002E0, "Member 'UCrabInteractUI::LootPoolText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, InteractKeyText) == 0x0002E8, "Member 'UCrabInteractUI::InteractKeyText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, InteractControllerIcon) == 0x0002F0, "Member 'UCrabInteractUI::InteractControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, InteractMessageText) == 0x0002F8, "Member 'UCrabInteractUI::InteractMessageText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, CostHorizontalBox) == 0x000300, "Member 'UCrabInteractUI::CostHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, CrystalIconImage) == 0x000308, "Member 'UCrabInteractUI::CrystalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, KeyIconImage) == 0x000310, "Member 'UCrabInteractUI::KeyIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, HealthIconImage) == 0x000318, "Member 'UCrabInteractUI::HealthIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, CostText) == 0x000320, "Member 'UCrabInteractUI::CostText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageHorizontalBox) == 0x000328, "Member 'UCrabInteractUI::SalvageHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageKeyText) == 0x000330, "Member 'UCrabInteractUI::SalvageKeyText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageControllerIcon) == 0x000338, "Member 'UCrabInteractUI::SalvageControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageRewardText) == 0x000340, "Member 'UCrabInteractUI::SalvageRewardText' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageProgressBar) == 0x000348, "Member 'UCrabInteractUI::SalvageProgressBar' has a wrong offset!");
static_assert(offsetof(UCrabInteractUI, SalvageAnim) == 0x000350, "Member 'UCrabInteractUI::SalvageAnim' has a wrong offset!");

// Class CrabChampions.CrabMinigameGameOverRowUI
// 0x0020 (0x02D8 - 0x02B8)
class UCrabMinigameGameOverRowUI : public UCrabUI
{
public:
	class UTextBlock*                             PlacementText;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MVPCrownImage;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EliminationsText;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMinigameGameOverRowUI">();
	}
	static class UCrabMinigameGameOverRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMinigameGameOverRowUI>();
	}
};
static_assert(alignof(UCrabMinigameGameOverRowUI) == 0x000008, "Wrong alignment on UCrabMinigameGameOverRowUI");
static_assert(sizeof(UCrabMinigameGameOverRowUI) == 0x0002D8, "Wrong size on UCrabMinigameGameOverRowUI");
static_assert(offsetof(UCrabMinigameGameOverRowUI, PlacementText) == 0x0002B8, "Member 'UCrabMinigameGameOverRowUI::PlacementText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverRowUI, MVPCrownImage) == 0x0002C0, "Member 'UCrabMinigameGameOverRowUI::MVPCrownImage' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverRowUI, PlayerNameText) == 0x0002C8, "Member 'UCrabMinigameGameOverRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverRowUI, EliminationsText) == 0x0002D0, "Member 'UCrabMinigameGameOverRowUI::EliminationsText' has a wrong offset!");

// Class CrabChampions.CrabPlayerNameUI
// 0x0008 (0x02C0 - 0x02B8)
class UCrabPlayerNameUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerNameUI">();
	}
	static class UCrabPlayerNameUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPlayerNameUI>();
	}
};
static_assert(alignof(UCrabPlayerNameUI) == 0x000008, "Wrong alignment on UCrabPlayerNameUI");
static_assert(sizeof(UCrabPlayerNameUI) == 0x0002C0, "Wrong size on UCrabPlayerNameUI");
static_assert(offsetof(UCrabPlayerNameUI, PlayerNameText) == 0x0002B8, "Member 'UCrabPlayerNameUI::PlayerNameText' has a wrong offset!");

// Class CrabChampions.CrabKeyBindRowUI
// 0x00A8 (0x0360 - 0x02B8)
class UCrabKeyBindRowUI : public UCrabUI
{
public:
	class UButton*                                KeyboardButton;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ControllerButton;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabKeyBind                           CurrentKeyBind;                                    // 0x02C8(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             KeyBindTitleText;                                  // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputKeySelector*                      KeyboardKeySelector;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputKeySelector*                      ControllerKeySelector;                             // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ControllerIcon;                                    // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     ControllerIconMat;                                 // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredControllerButton();
	void OnHoveredKeyboardButton();
	void OnPressedControllerKeySelector(const struct FInputChord& SelectedKey);
	void OnPressedKeyboardKeySelector(const struct FInputChord& SelectedKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabKeyBindRowUI">();
	}
	static class UCrabKeyBindRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabKeyBindRowUI>();
	}
};
static_assert(alignof(UCrabKeyBindRowUI) == 0x000008, "Wrong alignment on UCrabKeyBindRowUI");
static_assert(sizeof(UCrabKeyBindRowUI) == 0x000360, "Wrong size on UCrabKeyBindRowUI");
static_assert(offsetof(UCrabKeyBindRowUI, KeyboardButton) == 0x0002B8, "Member 'UCrabKeyBindRowUI::KeyboardButton' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerButton) == 0x0002C0, "Member 'UCrabKeyBindRowUI::ControllerButton' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, CurrentKeyBind) == 0x0002C8, "Member 'UCrabKeyBindRowUI::CurrentKeyBind' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, KeyBindTitleText) == 0x000338, "Member 'UCrabKeyBindRowUI::KeyBindTitleText' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, KeyboardKeySelector) == 0x000340, "Member 'UCrabKeyBindRowUI::KeyboardKeySelector' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerKeySelector) == 0x000348, "Member 'UCrabKeyBindRowUI::ControllerKeySelector' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerIcon) == 0x000350, "Member 'UCrabKeyBindRowUI::ControllerIcon' has a wrong offset!");
static_assert(offsetof(UCrabKeyBindRowUI, ControllerIconMat) == 0x000358, "Member 'UCrabKeyBindRowUI::ControllerIconMat' has a wrong offset!");

// Class CrabChampions.CrabPingUI
// 0x0008 (0x02C0 - 0x02B8)
class UCrabPingUI : public UCrabUI
{
public:
	class UImage*                                 PingIconImage;                                     // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPingUI">();
	}
	static class UCrabPingUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPingUI>();
	}
};
static_assert(alignof(UCrabPingUI) == 0x000008, "Wrong alignment on UCrabPingUI");
static_assert(sizeof(UCrabPingUI) == 0x0002C0, "Wrong size on UCrabPingUI");
static_assert(offsetof(UCrabPingUI, PingIconImage) == 0x0002B8, "Member 'UCrabPingUI::PingIconImage' has a wrong offset!");

// Class CrabChampions.CrabGameStateUI
// 0x0188 (0x0440 - 0x02B8)
class UCrabGameStateUI : public UCrabUI
{
public:
	class UVerticalBox*                           PlayerStateUIVerticalBox;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabPlayerStateUI>         PlayerStateUIToSpawn;                              // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentTimeText;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B2[0x8];                                     // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           CountdownVerticalBox;                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CountdownMessageText;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CountdownTime;                                     // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CountdownAnim;                                     // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         IslandProgressionHorizontalBox;                    // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             RandomIslandsIcon;                                 // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentIslandText;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyText;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GameplayMessageText;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       GameplayMessageAnim;                               // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ChatVerticalBox;                                   // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ChatEntriesVerticalBox;                            // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabChatEntryRowUI>        ChatEntryRowUIToSpawn;                             // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCrabChatEntryRowUI*>            ChatEntryRows;                                     // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       ChatInputEditableTextBox;                          // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B3[0x8];                                     // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             BiomeText;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandTypeText;                                    // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandDescriptionText;                             // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       IslandIntroductionAnim;                            // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              CountdownSound;                                    // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ObjectiveVerticalBox;                              // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectiveGoalText;                                 // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedObjectiveGoalAnim;                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ObjectiveText;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           IslandRewardVerticalBox;                           // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             IslandRewardText;                                  // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedIslandRewardRarityAnim;                   // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeModifierTitleText;                        // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeModifierText;                             // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeModifierDescriptionText;                  // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeModifierText;                   // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeModifierDescriptionText;        // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnStartedChallengeAnim;                            // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnCompletedChallengeAnim;                          // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FlawlessIslandClearAnim;                           // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SpectatingVerticalBox;                             // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SpectatingPlayerNameText;                          // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         MinigameHorizontalBox;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameScoreTitleText;                            // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameScoreText;                                 // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnUpdatedMinigameScoreAnim;                        // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameHighScoreTitleText;                        // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MinigameHighScoreText;                             // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChatTextCommitted(const class FText& Text, ETextCommit CommitMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGameStateUI">();
	}
	static class UCrabGameStateUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGameStateUI>();
	}
};
static_assert(alignof(UCrabGameStateUI) == 0x000008, "Wrong alignment on UCrabGameStateUI");
static_assert(sizeof(UCrabGameStateUI) == 0x000440, "Wrong size on UCrabGameStateUI");
static_assert(offsetof(UCrabGameStateUI, PlayerStateUIVerticalBox) == 0x0002B8, "Member 'UCrabGameStateUI::PlayerStateUIVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, PlayerStateUIToSpawn) == 0x0002C0, "Member 'UCrabGameStateUI::PlayerStateUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CurrentTimeText) == 0x0002C8, "Member 'UCrabGameStateUI::CurrentTimeText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownVerticalBox) == 0x0002D8, "Member 'UCrabGameStateUI::CountdownVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownMessageText) == 0x0002E0, "Member 'UCrabGameStateUI::CountdownMessageText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownTime) == 0x0002E8, "Member 'UCrabGameStateUI::CountdownTime' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownAnim) == 0x0002F0, "Member 'UCrabGameStateUI::CountdownAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandProgressionHorizontalBox) == 0x0002F8, "Member 'UCrabGameStateUI::IslandProgressionHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, RandomIslandsIcon) == 0x000300, "Member 'UCrabGameStateUI::RandomIslandsIcon' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CurrentIslandText) == 0x000308, "Member 'UCrabGameStateUI::CurrentIslandText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, DifficultyText) == 0x000310, "Member 'UCrabGameStateUI::DifficultyText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, GameplayMessageText) == 0x000318, "Member 'UCrabGameStateUI::GameplayMessageText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, GameplayMessageAnim) == 0x000320, "Member 'UCrabGameStateUI::GameplayMessageAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatVerticalBox) == 0x000328, "Member 'UCrabGameStateUI::ChatVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatEntriesVerticalBox) == 0x000330, "Member 'UCrabGameStateUI::ChatEntriesVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatEntryRowUIToSpawn) == 0x000338, "Member 'UCrabGameStateUI::ChatEntryRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatEntryRows) == 0x000340, "Member 'UCrabGameStateUI::ChatEntryRows' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChatInputEditableTextBox) == 0x000350, "Member 'UCrabGameStateUI::ChatInputEditableTextBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, BiomeText) == 0x000360, "Member 'UCrabGameStateUI::BiomeText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandTypeText) == 0x000368, "Member 'UCrabGameStateUI::IslandTypeText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandDescriptionText) == 0x000370, "Member 'UCrabGameStateUI::IslandDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandIntroductionAnim) == 0x000378, "Member 'UCrabGameStateUI::IslandIntroductionAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, CountdownSound) == 0x000380, "Member 'UCrabGameStateUI::CountdownSound' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ObjectiveVerticalBox) == 0x000388, "Member 'UCrabGameStateUI::ObjectiveVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ObjectiveGoalText) == 0x000390, "Member 'UCrabGameStateUI::ObjectiveGoalText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnUpdatedObjectiveGoalAnim) == 0x000398, "Member 'UCrabGameStateUI::OnUpdatedObjectiveGoalAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ObjectiveText) == 0x0003A0, "Member 'UCrabGameStateUI::ObjectiveText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandRewardVerticalBox) == 0x0003A8, "Member 'UCrabGameStateUI::IslandRewardVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, IslandRewardText) == 0x0003B0, "Member 'UCrabGameStateUI::IslandRewardText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnUpdatedIslandRewardRarityAnim) == 0x0003B8, "Member 'UCrabGameStateUI::OnUpdatedIslandRewardRarityAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChallengeModifierTitleText) == 0x0003C0, "Member 'UCrabGameStateUI::ChallengeModifierTitleText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChallengeModifierText) == 0x0003C8, "Member 'UCrabGameStateUI::ChallengeModifierText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, ChallengeModifierDescriptionText) == 0x0003D0, "Member 'UCrabGameStateUI::ChallengeModifierDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, AdditionalChallengeModifierText) == 0x0003D8, "Member 'UCrabGameStateUI::AdditionalChallengeModifierText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, AdditionalChallengeModifierDescriptionText) == 0x0003E0, "Member 'UCrabGameStateUI::AdditionalChallengeModifierDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnStartedChallengeAnim) == 0x0003E8, "Member 'UCrabGameStateUI::OnStartedChallengeAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnCompletedChallengeAnim) == 0x0003F0, "Member 'UCrabGameStateUI::OnCompletedChallengeAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, FlawlessIslandClearAnim) == 0x0003F8, "Member 'UCrabGameStateUI::FlawlessIslandClearAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, SpectatingVerticalBox) == 0x000400, "Member 'UCrabGameStateUI::SpectatingVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, SpectatingPlayerNameText) == 0x000408, "Member 'UCrabGameStateUI::SpectatingPlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameHorizontalBox) == 0x000410, "Member 'UCrabGameStateUI::MinigameHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameScoreTitleText) == 0x000418, "Member 'UCrabGameStateUI::MinigameScoreTitleText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameScoreText) == 0x000420, "Member 'UCrabGameStateUI::MinigameScoreText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, OnUpdatedMinigameScoreAnim) == 0x000428, "Member 'UCrabGameStateUI::OnUpdatedMinigameScoreAnim' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameHighScoreTitleText) == 0x000430, "Member 'UCrabGameStateUI::MinigameHighScoreTitleText' has a wrong offset!");
static_assert(offsetof(UCrabGameStateUI, MinigameHighScoreText) == 0x000438, "Member 'UCrabGameStateUI::MinigameHighScoreText' has a wrong offset!");

// Class CrabChampions.CrabSliderUI
// 0x0018 (0x02D0 - 0x02B8)
class UCrabSliderUI : public UCrabUI
{
public:
	class USlider*                                MainSlider;                                        // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           SliderPB;                                          // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SliderText;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMainSliderValueChanged(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSliderUI">();
	}
	static class UCrabSliderUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSliderUI>();
	}
};
static_assert(alignof(UCrabSliderUI) == 0x000008, "Wrong alignment on UCrabSliderUI");
static_assert(sizeof(UCrabSliderUI) == 0x0002D0, "Wrong size on UCrabSliderUI");
static_assert(offsetof(UCrabSliderUI, MainSlider) == 0x0002B8, "Member 'UCrabSliderUI::MainSlider' has a wrong offset!");
static_assert(offsetof(UCrabSliderUI, SliderPB) == 0x0002C0, "Member 'UCrabSliderUI::SliderPB' has a wrong offset!");
static_assert(offsetof(UCrabSliderUI, SliderText) == 0x0002C8, "Member 'UCrabSliderUI::SliderText' has a wrong offset!");

// Class CrabChampions.CrabSoundMenuUI
// 0x0028 (0x02E0 - 0x02B8)
class UCrabSoundMenuUI : public UCrabUI
{
public:
	TArray<class UWidget*>                        SoundMenuFocusableWidgetArray;                     // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          MasterVolumeSlider;                                // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          GameplayVolumeSlider;                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabSliderUI*                          MusicVolumeSlider;                                 // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSoundMenuUI">();
	}
	static class UCrabSoundMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSoundMenuUI>();
	}
};
static_assert(alignof(UCrabSoundMenuUI) == 0x000008, "Wrong alignment on UCrabSoundMenuUI");
static_assert(sizeof(UCrabSoundMenuUI) == 0x0002E0, "Wrong size on UCrabSoundMenuUI");
static_assert(offsetof(UCrabSoundMenuUI, SoundMenuFocusableWidgetArray) == 0x0002B8, "Member 'UCrabSoundMenuUI::SoundMenuFocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabSoundMenuUI, MasterVolumeSlider) == 0x0002C8, "Member 'UCrabSoundMenuUI::MasterVolumeSlider' has a wrong offset!");
static_assert(offsetof(UCrabSoundMenuUI, GameplayVolumeSlider) == 0x0002D0, "Member 'UCrabSoundMenuUI::GameplayVolumeSlider' has a wrong offset!");
static_assert(offsetof(UCrabSoundMenuUI, MusicVolumeSlider) == 0x0002D8, "Member 'UCrabSoundMenuUI::MusicVolumeSlider' has a wrong offset!");

// Class CrabChampions.CrabPlayerStateUI
// 0x0048 (0x0300 - 0x02B8)
class UCrabPlayerStateUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerPointsText;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerEliminationsText;                            // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PlayerAccountRankImage;                            // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerAccountLevelText;                            // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PlayerHealthBar;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PlayerEliminatedAnim;                              // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                PlayerPS;                                          // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           PlayerC;                                           // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerStateUI">();
	}
	static class UCrabPlayerStateUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPlayerStateUI>();
	}
};
static_assert(alignof(UCrabPlayerStateUI) == 0x000008, "Wrong alignment on UCrabPlayerStateUI");
static_assert(sizeof(UCrabPlayerStateUI) == 0x000300, "Wrong size on UCrabPlayerStateUI");
static_assert(offsetof(UCrabPlayerStateUI, PlayerNameText) == 0x0002B8, "Member 'UCrabPlayerStateUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerPointsText) == 0x0002C0, "Member 'UCrabPlayerStateUI::PlayerPointsText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerEliminationsText) == 0x0002C8, "Member 'UCrabPlayerStateUI::PlayerEliminationsText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerAccountRankImage) == 0x0002D0, "Member 'UCrabPlayerStateUI::PlayerAccountRankImage' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerAccountLevelText) == 0x0002D8, "Member 'UCrabPlayerStateUI::PlayerAccountLevelText' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerHealthBar) == 0x0002E0, "Member 'UCrabPlayerStateUI::PlayerHealthBar' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerEliminatedAnim) == 0x0002E8, "Member 'UCrabPlayerStateUI::PlayerEliminatedAnim' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerPS) == 0x0002F0, "Member 'UCrabPlayerStateUI::PlayerPS' has a wrong offset!");
static_assert(offsetof(UCrabPlayerStateUI, PlayerC) == 0x0002F8, "Member 'UCrabPlayerStateUI::PlayerC' has a wrong offset!");

// Class CrabChampions.CrabShopPedestalUI
// 0x0030 (0x02E8 - 0x02B8)
class UCrabShopPedestalUI : public UCrabUI
{
public:
	class UImage*                                 CrystalIconImage;                                  // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KeyIconImage;                                      // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HealthIconImage;                                   // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CostText;                                          // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DiscountText;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                DiscountBorder;                                    // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabShopPedestalUI">();
	}
	static class UCrabShopPedestalUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabShopPedestalUI>();
	}
};
static_assert(alignof(UCrabShopPedestalUI) == 0x000008, "Wrong alignment on UCrabShopPedestalUI");
static_assert(sizeof(UCrabShopPedestalUI) == 0x0002E8, "Wrong size on UCrabShopPedestalUI");
static_assert(offsetof(UCrabShopPedestalUI, CrystalIconImage) == 0x0002B8, "Member 'UCrabShopPedestalUI::CrystalIconImage' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, KeyIconImage) == 0x0002C0, "Member 'UCrabShopPedestalUI::KeyIconImage' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, HealthIconImage) == 0x0002C8, "Member 'UCrabShopPedestalUI::HealthIconImage' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, CostText) == 0x0002D0, "Member 'UCrabShopPedestalUI::CostText' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, DiscountText) == 0x0002D8, "Member 'UCrabShopPedestalUI::DiscountText' has a wrong offset!");
static_assert(offsetof(UCrabShopPedestalUI, DiscountBorder) == 0x0002E0, "Member 'UCrabShopPedestalUI::DiscountBorder' has a wrong offset!");

// Class CrabChampions.CrabStatsUI
// 0x0108 (0x03C0 - 0x02B8)
class UCrabStatsUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DifficultyText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighScoreText;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AttemptsText;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinsText;                                          // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WinStreakText;                                     // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighestIslandReachedText;                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalUnlockedPercentageText;                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           TotalUnlockedPB;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticsUnlockedText;                             // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalCosmeticsToUnlockText;                        // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CosmeticsUnlockedPB;                               // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponsUnlockedText;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalWeaponsToUnlockText;                          // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           WeaponsUnlockedPB;                                 // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AbilitiesUnlockedText;                             // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalAbilitiesToUnlockText;                        // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           AbilitiesUnlockedPB;                               // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             MeleeWeaponsUnlockedText;                          // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalMeleeWeaponsToUnlockText;                     // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           MeleeWeaponsUnlockedPB;                            // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             WeaponModsUnlockedText;                            // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalWeaponModsToUnlockText;                       // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           WeaponModsUnlockedPB;                              // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GrenadeModsUnlockedText;                           // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalGrenadeModsToUnlockText;                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           GrenadeModsUnlockedPB;                             // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PerksUnlockedText;                                 // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalPerksToUnlockText;                            // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PerksUnlockedPB;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RelicsUnlockedText;                                // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalRelicsToUnlockText;                           // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           RelicsUnlockedPB;                                  // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabStatsUI">();
	}
	static class UCrabStatsUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabStatsUI>();
	}
};
static_assert(alignof(UCrabStatsUI) == 0x000008, "Wrong alignment on UCrabStatsUI");
static_assert(sizeof(UCrabStatsUI) == 0x0003C0, "Wrong size on UCrabStatsUI");
static_assert(offsetof(UCrabStatsUI, PlayerNameText) == 0x0002B8, "Member 'UCrabStatsUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, DifficultyText) == 0x0002C0, "Member 'UCrabStatsUI::DifficultyText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, HighScoreText) == 0x0002C8, "Member 'UCrabStatsUI::HighScoreText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AttemptsText) == 0x0002D0, "Member 'UCrabStatsUI::AttemptsText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WinsText) == 0x0002D8, "Member 'UCrabStatsUI::WinsText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WinStreakText) == 0x0002E0, "Member 'UCrabStatsUI::WinStreakText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, HighestIslandReachedText) == 0x0002E8, "Member 'UCrabStatsUI::HighestIslandReachedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalUnlockedPercentageText) == 0x0002F0, "Member 'UCrabStatsUI::TotalUnlockedPercentageText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalUnlockedPB) == 0x0002F8, "Member 'UCrabStatsUI::TotalUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, CosmeticsUnlockedText) == 0x000300, "Member 'UCrabStatsUI::CosmeticsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalCosmeticsToUnlockText) == 0x000308, "Member 'UCrabStatsUI::TotalCosmeticsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, CosmeticsUnlockedPB) == 0x000310, "Member 'UCrabStatsUI::CosmeticsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponsUnlockedText) == 0x000318, "Member 'UCrabStatsUI::WeaponsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalWeaponsToUnlockText) == 0x000320, "Member 'UCrabStatsUI::TotalWeaponsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponsUnlockedPB) == 0x000328, "Member 'UCrabStatsUI::WeaponsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AbilitiesUnlockedText) == 0x000330, "Member 'UCrabStatsUI::AbilitiesUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalAbilitiesToUnlockText) == 0x000338, "Member 'UCrabStatsUI::TotalAbilitiesToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, AbilitiesUnlockedPB) == 0x000340, "Member 'UCrabStatsUI::AbilitiesUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, MeleeWeaponsUnlockedText) == 0x000348, "Member 'UCrabStatsUI::MeleeWeaponsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalMeleeWeaponsToUnlockText) == 0x000350, "Member 'UCrabStatsUI::TotalMeleeWeaponsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, MeleeWeaponsUnlockedPB) == 0x000358, "Member 'UCrabStatsUI::MeleeWeaponsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponModsUnlockedText) == 0x000360, "Member 'UCrabStatsUI::WeaponModsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalWeaponModsToUnlockText) == 0x000368, "Member 'UCrabStatsUI::TotalWeaponModsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, WeaponModsUnlockedPB) == 0x000370, "Member 'UCrabStatsUI::WeaponModsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, GrenadeModsUnlockedText) == 0x000378, "Member 'UCrabStatsUI::GrenadeModsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalGrenadeModsToUnlockText) == 0x000380, "Member 'UCrabStatsUI::TotalGrenadeModsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, GrenadeModsUnlockedPB) == 0x000388, "Member 'UCrabStatsUI::GrenadeModsUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, PerksUnlockedText) == 0x000390, "Member 'UCrabStatsUI::PerksUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalPerksToUnlockText) == 0x000398, "Member 'UCrabStatsUI::TotalPerksToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, PerksUnlockedPB) == 0x0003A0, "Member 'UCrabStatsUI::PerksUnlockedPB' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, RelicsUnlockedText) == 0x0003A8, "Member 'UCrabStatsUI::RelicsUnlockedText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, TotalRelicsToUnlockText) == 0x0003B0, "Member 'UCrabStatsUI::TotalRelicsToUnlockText' has a wrong offset!");
static_assert(offsetof(UCrabStatsUI, RelicsUnlockedPB) == 0x0003B8, "Member 'UCrabStatsUI::RelicsUnlockedPB' has a wrong offset!");

// Class CrabChampions.CrabWeapon
// 0x0150 (0x0370 - 0x0220)
class ACrabWeapon final : public AActor
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      CosmeticNC;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B5[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      MuzzleFlashNC;                                     // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPS*                                OwningPS;                                          // 0x0240(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabWeaponInfo                        WeaponInfo;                                        // 0x0248(0x0018)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabC*                                 OwningC;                                           // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPC*                                OwningPC;                                          // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B6[0x8];                                     // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B7[0xA8];                                    // 0x0290(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimesFired;                                        // 0x0338(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B8[0x1C];                                    // 0x033C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReloading;                                      // 0x0358(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14B9[0x17];                                    // 0x0359(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsReloading();
	void OnRep_OwningPS();
	void OnRep_TimesFired();
	void OnRep_WeaponInfo();
	void ServerPlayStartFireFX();
	void ServerSetIsReloading(bool bNewIsReloading);
	void ServerTriggerOnReloadPerks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabWeapon">();
	}
	static class ACrabWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabWeapon>();
	}
};
static_assert(alignof(ACrabWeapon) == 0x000008, "Wrong alignment on ACrabWeapon");
static_assert(sizeof(ACrabWeapon) == 0x000370, "Wrong size on ACrabWeapon");
static_assert(offsetof(ACrabWeapon, Mesh) == 0x000220, "Member 'ACrabWeapon::Mesh' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, CosmeticNC) == 0x000228, "Member 'ACrabWeapon::CosmeticNC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, MuzzleFlashNC) == 0x000238, "Member 'ACrabWeapon::MuzzleFlashNC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, OwningPS) == 0x000240, "Member 'ACrabWeapon::OwningPS' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, WeaponInfo) == 0x000248, "Member 'ACrabWeapon::WeaponInfo' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, WeaponDA) == 0x000260, "Member 'ACrabWeapon::WeaponDA' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, OwningC) == 0x000268, "Member 'ACrabWeapon::OwningC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, OwningPC) == 0x000270, "Member 'ACrabWeapon::OwningPC' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, ActorsToIgnore) == 0x000280, "Member 'ACrabWeapon::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, TimesFired) == 0x000338, "Member 'ACrabWeapon::TimesFired' has a wrong offset!");
static_assert(offsetof(ACrabWeapon, bIsReloading) == 0x000358, "Member 'ACrabWeapon::bIsReloading' has a wrong offset!");

// Class CrabChampions.CrabVideoMenuUI
// 0x01A8 (0x0460 - 0x02B8)
class UCrabVideoMenuUI : public UCrabUI
{
public:
	TArray<class UWidget*>                        VideoMenuFocusableWidgetArray;                     // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BA[0x110];                                   // 0x02C8(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabArrowSelectionUI*                  DisplayModeAS;                                     // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  ResolutionAS;                                      // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  ResolutionQualityAS;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  FPSLimitAS;                                        // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  VSyncAS;                                           // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  FieldOfViewAS;                                     // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  GraphicsQualityAS;                                 // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  WeaponEffectsAS;                                   // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  AntiAliasingTypeAS;                                // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  SharpeningAS;                                      // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  MotionBlurAS;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  CameraShakeAS;                                     // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  HitmarkersAS;                                      // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  DamageNumbersAS;                                   // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  TextChatVisibilityAS;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  ShowFPSAS;                                         // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabArrowSelectionUI*                  PauseWhenLosingFocusAS;                            // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAntiAliasingType(const class FString& NewSelection);
	void SetCameraShake(const class FString& NewSelection);
	void SetDamageNumbers(const class FString& NewSelection);
	void SetDisplayMode(const class FString& NewSelection);
	void SetFieldOfView(const class FString& NewSelection);
	void SetFPSLimit(const class FString& NewSelection);
	void SetGraphicsQuality(const class FString& NewSelection);
	void SetHitmarkers(const class FString& NewSelection);
	void SetMotionBlur(const class FString& NewSelection);
	void SetPauseWhenLosingFocus(const class FString& NewSelection);
	void SetResolution(const class FString& NewSelection);
	void SetResolutionQuality(const class FString& NewSelection);
	void SetSharpening(const class FString& NewSelection);
	void SetShowFPS(const class FString& NewSelection);
	void SetTextChatVisibility(const class FString& NewSelection);
	void SetVSync(const class FString& NewSelection);
	void SetWeaponEffects(const class FString& NewSelection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabVideoMenuUI">();
	}
	static class UCrabVideoMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabVideoMenuUI>();
	}
};
static_assert(alignof(UCrabVideoMenuUI) == 0x000008, "Wrong alignment on UCrabVideoMenuUI");
static_assert(sizeof(UCrabVideoMenuUI) == 0x000460, "Wrong size on UCrabVideoMenuUI");
static_assert(offsetof(UCrabVideoMenuUI, VideoMenuFocusableWidgetArray) == 0x0002B8, "Member 'UCrabVideoMenuUI::VideoMenuFocusableWidgetArray' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, DisplayModeAS) == 0x0003D8, "Member 'UCrabVideoMenuUI::DisplayModeAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, ResolutionAS) == 0x0003E0, "Member 'UCrabVideoMenuUI::ResolutionAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, ResolutionQualityAS) == 0x0003E8, "Member 'UCrabVideoMenuUI::ResolutionQualityAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, FPSLimitAS) == 0x0003F0, "Member 'UCrabVideoMenuUI::FPSLimitAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, VSyncAS) == 0x0003F8, "Member 'UCrabVideoMenuUI::VSyncAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, FieldOfViewAS) == 0x000400, "Member 'UCrabVideoMenuUI::FieldOfViewAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, GraphicsQualityAS) == 0x000408, "Member 'UCrabVideoMenuUI::GraphicsQualityAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, WeaponEffectsAS) == 0x000410, "Member 'UCrabVideoMenuUI::WeaponEffectsAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, AntiAliasingTypeAS) == 0x000418, "Member 'UCrabVideoMenuUI::AntiAliasingTypeAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, SharpeningAS) == 0x000420, "Member 'UCrabVideoMenuUI::SharpeningAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, MotionBlurAS) == 0x000428, "Member 'UCrabVideoMenuUI::MotionBlurAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, CameraShakeAS) == 0x000430, "Member 'UCrabVideoMenuUI::CameraShakeAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, HitmarkersAS) == 0x000438, "Member 'UCrabVideoMenuUI::HitmarkersAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, DamageNumbersAS) == 0x000440, "Member 'UCrabVideoMenuUI::DamageNumbersAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, TextChatVisibilityAS) == 0x000448, "Member 'UCrabVideoMenuUI::TextChatVisibilityAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, ShowFPSAS) == 0x000450, "Member 'UCrabVideoMenuUI::ShowFPSAS' has a wrong offset!");
static_assert(offsetof(UCrabVideoMenuUI, PauseWhenLosingFocusAS) == 0x000458, "Member 'UCrabVideoMenuUI::PauseWhenLosingFocusAS' has a wrong offset!");

// Class CrabChampions.CrabFireWeaponActionDA
// 0x0008 (0x0070 - 0x0068)
class UCrabFireWeaponActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BB[0x3];                                     // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Spread;                                            // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabFireWeaponActionDA">();
	}
	static class UCrabFireWeaponActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabFireWeaponActionDA>();
	}
};
static_assert(alignof(UCrabFireWeaponActionDA) == 0x000008, "Wrong alignment on UCrabFireWeaponActionDA");
static_assert(sizeof(UCrabFireWeaponActionDA) == 0x000070, "Wrong size on UCrabFireWeaponActionDA");
static_assert(offsetof(UCrabFireWeaponActionDA, TargetType) == 0x000068, "Member 'UCrabFireWeaponActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabFireWeaponActionDA, Spread) == 0x00006C, "Member 'UCrabFireWeaponActionDA::Spread' has a wrong offset!");

// Class CrabChampions.CrabProjectileActionDA
// 0x0030 (0x0098 - 0x0068)
class UCrabProjectileActionDA final : public UCrabActionDA
{
public:
	ECrabTargetType                               TargetType;                                        // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BC[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SocketNames;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabFormationType                            FormationType;                                     // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BD[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FormationSpacing;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FormationExpansionDampening;                       // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spread;                                            // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabProjectileActionDA">();
	}
	static class UCrabProjectileActionDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabProjectileActionDA>();
	}
};
static_assert(alignof(UCrabProjectileActionDA) == 0x000008, "Wrong alignment on UCrabProjectileActionDA");
static_assert(sizeof(UCrabProjectileActionDA) == 0x000098, "Wrong size on UCrabProjectileActionDA");
static_assert(offsetof(UCrabProjectileActionDA, TargetType) == 0x000068, "Member 'UCrabProjectileActionDA::TargetType' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, SocketNames) == 0x000070, "Member 'UCrabProjectileActionDA::SocketNames' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, ProjectileDA) == 0x000080, "Member 'UCrabProjectileActionDA::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationType) == 0x000088, "Member 'UCrabProjectileActionDA::FormationType' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationSpacing) == 0x00008C, "Member 'UCrabProjectileActionDA::FormationSpacing' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, FormationExpansionDampening) == 0x000090, "Member 'UCrabProjectileActionDA::FormationExpansionDampening' has a wrong offset!");
static_assert(offsetof(UCrabProjectileActionDA, Spread) == 0x000094, "Member 'UCrabProjectileActionDA::Spread' has a wrong offset!");

// Class CrabChampions.CrabEnemyAnimInstance
// 0x0010 (0x02E0 - 0x02D0)
class UCrabEnemyAnimInstance : public UCrabAnimInstance
{
public:
	class ACrabEnemyC*                            OwningEnemyC;                                      // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomAnimOffset;                                  // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BE[0x4];                                     // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_Action();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabEnemyAnimInstance">();
	}
	static class UCrabEnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabEnemyAnimInstance>();
	}
};
static_assert(alignof(UCrabEnemyAnimInstance) == 0x000010, "Wrong alignment on UCrabEnemyAnimInstance");
static_assert(sizeof(UCrabEnemyAnimInstance) == 0x0002E0, "Wrong size on UCrabEnemyAnimInstance");
static_assert(offsetof(UCrabEnemyAnimInstance, OwningEnemyC) == 0x0002D0, "Member 'UCrabEnemyAnimInstance::OwningEnemyC' has a wrong offset!");
static_assert(offsetof(UCrabEnemyAnimInstance, RandomAnimOffset) == 0x0002D8, "Member 'UCrabEnemyAnimInstance::RandomAnimOffset' has a wrong offset!");

// Class CrabChampions.CrabPlayerAnimInstance
// 0x0020 (0x02F0 - 0x02D0)
class UCrabPlayerAnimInstance : public UCrabAnimInstance
{
public:
	class ACrabPlayerC*                           OwningPlayerC;                                     // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTurnDir;                                    // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CurrentInputDir;                                   // 0x02DC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSliding;                                        // 0x02E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BF[0xB];                                     // 0x02E5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_Melee();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPlayerAnimInstance">();
	}
	static class UCrabPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPlayerAnimInstance>();
	}
};
static_assert(alignof(UCrabPlayerAnimInstance) == 0x000010, "Wrong alignment on UCrabPlayerAnimInstance");
static_assert(sizeof(UCrabPlayerAnimInstance) == 0x0002F0, "Wrong size on UCrabPlayerAnimInstance");
static_assert(offsetof(UCrabPlayerAnimInstance, OwningPlayerC) == 0x0002D0, "Member 'UCrabPlayerAnimInstance::OwningPlayerC' has a wrong offset!");
static_assert(offsetof(UCrabPlayerAnimInstance, CurrentTurnDir) == 0x0002D8, "Member 'UCrabPlayerAnimInstance::CurrentTurnDir' has a wrong offset!");
static_assert(offsetof(UCrabPlayerAnimInstance, CurrentInputDir) == 0x0002DC, "Member 'UCrabPlayerAnimInstance::CurrentInputDir' has a wrong offset!");
static_assert(offsetof(UCrabPlayerAnimInstance, bIsSliding) == 0x0002E4, "Member 'UCrabPlayerAnimInstance::bIsSliding' has a wrong offset!");

// Class CrabChampions.CrabDamageInterface
// 0x0000 (0x0028 - 0x0028)
class ICrabDamageInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageInterface">();
	}
	static class ICrabDamageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICrabDamageInterface>();
	}
};
static_assert(alignof(ICrabDamageInterface) == 0x000008, "Wrong alignment on ICrabDamageInterface");
static_assert(sizeof(ICrabDamageInterface) == 0x000028, "Wrong size on ICrabDamageInterface");

// Class CrabChampions.CrabOverlapInterface
// 0x0000 (0x0028 - 0x0028)
class ICrabOverlapInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabOverlapInterface">();
	}
	static class ICrabOverlapInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICrabOverlapInterface>();
	}
};
static_assert(alignof(ICrabOverlapInterface) == 0x000008, "Wrong alignment on ICrabOverlapInterface");
static_assert(sizeof(ICrabOverlapInterface) == 0x000028, "Wrong size on ICrabOverlapInterface");

// Class CrabChampions.CrabCMC
// 0x0060 (0x0B50 - 0x0AF0)
class UCrabCMC final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_14C0[0x8];                                     // 0x0AF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientAuthoritativeMoveData           ServerLatestMoveData;                              // 0x0AF8(0x0050)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C1[0x8];                                     // 0x0B48(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCMC">();
	}
	static class UCrabCMC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCMC>();
	}
};
static_assert(alignof(UCrabCMC) == 0x000010, "Wrong alignment on UCrabCMC");
static_assert(sizeof(UCrabCMC) == 0x000B50, "Wrong size on UCrabCMC");
static_assert(offsetof(UCrabCMC, ServerLatestMoveData) == 0x000AF8, "Member 'UCrabCMC::ServerLatestMoveData' has a wrong offset!");

// Class CrabChampions.CrabDamageTextActor
// 0x0018 (0x0238 - 0x0220)
class ACrabDamageTextActor final : public AActor
{
public:
	class UWidgetComponent*                       DamageTextWC;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabDamageTextUI*                      DamageTextUI;                                      // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C2[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDamageTextActor">();
	}
	static class ACrabDamageTextActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabDamageTextActor>();
	}
};
static_assert(alignof(ACrabDamageTextActor) == 0x000008, "Wrong alignment on ACrabDamageTextActor");
static_assert(sizeof(ACrabDamageTextActor) == 0x000238, "Wrong size on ACrabDamageTextActor");
static_assert(offsetof(ACrabDamageTextActor, DamageTextWC) == 0x000220, "Member 'ACrabDamageTextActor::DamageTextWC' has a wrong offset!");
static_assert(offsetof(ACrabDamageTextActor, DamageTextUI) == 0x000228, "Member 'ACrabDamageTextActor::DamageTextUI' has a wrong offset!");

// Class CrabChampions.CrabGI
// 0x04F8 (0x06A0 - 0x01A8)
class UCrabGI : public UGameInstance
{
public:
	TSubclassOf<class UUserWidget>                LoadingScreenUIToSpawn;                            // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            LoadingScreenUI;                                   // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C3[0x30];                                    // 0x01B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabSG*                                SG;                                                // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C4[0x10];                                    // 0x01F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabSettingsSG*                        SettingsSG;                                        // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C5[0x4];                                     // 0x0208(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CrabChampionsVersion;                              // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabKeyBind>                   CrabKeyBinds;                                      // 0x0210(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackButton;                                        // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BumperL;                                           // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BumperR;                                           // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonD;                                           // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonL;                                           // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonR;                                           // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ButtonU;                                           // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadD;                                             // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadL;                                             // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadR;                                             // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DPadU;                                             // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StartButton;                                       // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickL;                                            // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickLHorizontal;                                  // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickLVertical;                                    // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickR;                                            // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickRHorizontal;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StickRVertical;                                    // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TriggerL;                                          // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TriggerR;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            MasterSoundClass;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              MasterSoundMix;                                    // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            GameplaySoundClass;                                // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              GameplaySoundMix;                                  // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundClass*                            MusicSoundClass;                                   // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              MusicSoundMix;                                     // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCosmeticsDA*                       CosmeticsDA;                                       // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabChallenge>                 Challenges;                                        // 0x02F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDebugUnlockAllContent;                            // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C6[0x7];                                     // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabAutoSave                          DebugAutoSave;                                     // 0x0310(0x0130)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C7[0x260];                                   // 0x0440(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStreamLevelLoaded();
	void OnStreamLevelUnloaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGI">();
	}
	static class UCrabGI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabGI>();
	}
};
static_assert(alignof(UCrabGI) == 0x000008, "Wrong alignment on UCrabGI");
static_assert(sizeof(UCrabGI) == 0x0006A0, "Wrong size on UCrabGI");
static_assert(offsetof(UCrabGI, LoadingScreenUIToSpawn) == 0x0001A8, "Member 'UCrabGI::LoadingScreenUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabGI, LoadingScreenUI) == 0x0001B0, "Member 'UCrabGI::LoadingScreenUI' has a wrong offset!");
static_assert(offsetof(UCrabGI, SG) == 0x0001E8, "Member 'UCrabGI::SG' has a wrong offset!");
static_assert(offsetof(UCrabGI, SettingsSG) == 0x000200, "Member 'UCrabGI::SettingsSG' has a wrong offset!");
static_assert(offsetof(UCrabGI, CrabChampionsVersion) == 0x00020C, "Member 'UCrabGI::CrabChampionsVersion' has a wrong offset!");
static_assert(offsetof(UCrabGI, CrabKeyBinds) == 0x000210, "Member 'UCrabGI::CrabKeyBinds' has a wrong offset!");
static_assert(offsetof(UCrabGI, BackButton) == 0x000220, "Member 'UCrabGI::BackButton' has a wrong offset!");
static_assert(offsetof(UCrabGI, BumperL) == 0x000228, "Member 'UCrabGI::BumperL' has a wrong offset!");
static_assert(offsetof(UCrabGI, BumperR) == 0x000230, "Member 'UCrabGI::BumperR' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonD) == 0x000238, "Member 'UCrabGI::ButtonD' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonL) == 0x000240, "Member 'UCrabGI::ButtonL' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonR) == 0x000248, "Member 'UCrabGI::ButtonR' has a wrong offset!");
static_assert(offsetof(UCrabGI, ButtonU) == 0x000250, "Member 'UCrabGI::ButtonU' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadD) == 0x000258, "Member 'UCrabGI::DPadD' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadL) == 0x000260, "Member 'UCrabGI::DPadL' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadR) == 0x000268, "Member 'UCrabGI::DPadR' has a wrong offset!");
static_assert(offsetof(UCrabGI, DPadU) == 0x000270, "Member 'UCrabGI::DPadU' has a wrong offset!");
static_assert(offsetof(UCrabGI, StartButton) == 0x000278, "Member 'UCrabGI::StartButton' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickL) == 0x000280, "Member 'UCrabGI::StickL' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickLHorizontal) == 0x000288, "Member 'UCrabGI::StickLHorizontal' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickLVertical) == 0x000290, "Member 'UCrabGI::StickLVertical' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickR) == 0x000298, "Member 'UCrabGI::StickR' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickRHorizontal) == 0x0002A0, "Member 'UCrabGI::StickRHorizontal' has a wrong offset!");
static_assert(offsetof(UCrabGI, StickRVertical) == 0x0002A8, "Member 'UCrabGI::StickRVertical' has a wrong offset!");
static_assert(offsetof(UCrabGI, TriggerL) == 0x0002B0, "Member 'UCrabGI::TriggerL' has a wrong offset!");
static_assert(offsetof(UCrabGI, TriggerR) == 0x0002B8, "Member 'UCrabGI::TriggerR' has a wrong offset!");
static_assert(offsetof(UCrabGI, MasterSoundClass) == 0x0002C0, "Member 'UCrabGI::MasterSoundClass' has a wrong offset!");
static_assert(offsetof(UCrabGI, MasterSoundMix) == 0x0002C8, "Member 'UCrabGI::MasterSoundMix' has a wrong offset!");
static_assert(offsetof(UCrabGI, GameplaySoundClass) == 0x0002D0, "Member 'UCrabGI::GameplaySoundClass' has a wrong offset!");
static_assert(offsetof(UCrabGI, GameplaySoundMix) == 0x0002D8, "Member 'UCrabGI::GameplaySoundMix' has a wrong offset!");
static_assert(offsetof(UCrabGI, MusicSoundClass) == 0x0002E0, "Member 'UCrabGI::MusicSoundClass' has a wrong offset!");
static_assert(offsetof(UCrabGI, MusicSoundMix) == 0x0002E8, "Member 'UCrabGI::MusicSoundMix' has a wrong offset!");
static_assert(offsetof(UCrabGI, CosmeticsDA) == 0x0002F0, "Member 'UCrabGI::CosmeticsDA' has a wrong offset!");
static_assert(offsetof(UCrabGI, Challenges) == 0x0002F8, "Member 'UCrabGI::Challenges' has a wrong offset!");
static_assert(offsetof(UCrabGI, bDebugUnlockAllContent) == 0x000308, "Member 'UCrabGI::bDebugUnlockAllContent' has a wrong offset!");
static_assert(offsetof(UCrabGI, DebugAutoSave) == 0x000310, "Member 'UCrabGI::DebugAutoSave' has a wrong offset!");

// Class CrabChampions.CrabGM
// 0x00B0 (0x0370 - 0x02C0)
class ACrabGM : public AGameModeBase
{
public:
	TSubclassOf<class ACrabPC>                    PCToSpawn;                                         // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabLM*                                LM;                                                // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C8[0x18];                                    // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WaitingForMorePlayersDelay;                        // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PreStartDelay;                                     // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACrabC>                     CharacterToSpawn;                                  // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugCurrentIsland;                                // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabIslandType                               DebugIslandType;                                   // 0x02FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabChallengeModifier                        DebugChallengeModifier;                            // 0x02FD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabBlessing                                 DebugBlessing;                                     // 0x02FE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C9[0x9];                                     // 0x02FF(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACrabPortal*, int32>               CurrentPortals;                                    // 0x0308(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class ACrabPortal*                            ChosenPortal;                                      // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CA[0x10];                                    // 0x0360(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugCompleteIsland();
	void DebugEndRun();
	void DebugGoToIsland(int32 IslandToGoTo);
	void DebugGoToNextBiome();
	void DebugGoToNextIsland();
	void OnNavigationGenerationFinished(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGM">();
	}
	static class ACrabGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabGM>();
	}
};
static_assert(alignof(ACrabGM) == 0x000008, "Wrong alignment on ACrabGM");
static_assert(sizeof(ACrabGM) == 0x000370, "Wrong size on ACrabGM");
static_assert(offsetof(ACrabGM, PCToSpawn) == 0x0002C0, "Member 'ACrabGM::PCToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabGM, LM) == 0x0002C8, "Member 'ACrabGM::LM' has a wrong offset!");
static_assert(offsetof(ACrabGM, WaitingForMorePlayersDelay) == 0x0002E8, "Member 'ACrabGM::WaitingForMorePlayersDelay' has a wrong offset!");
static_assert(offsetof(ACrabGM, PreStartDelay) == 0x0002EC, "Member 'ACrabGM::PreStartDelay' has a wrong offset!");
static_assert(offsetof(ACrabGM, CharacterToSpawn) == 0x0002F0, "Member 'ACrabGM::CharacterToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugCurrentIsland) == 0x0002F8, "Member 'ACrabGM::DebugCurrentIsland' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugIslandType) == 0x0002FC, "Member 'ACrabGM::DebugIslandType' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugChallengeModifier) == 0x0002FD, "Member 'ACrabGM::DebugChallengeModifier' has a wrong offset!");
static_assert(offsetof(ACrabGM, DebugBlessing) == 0x0002FE, "Member 'ACrabGM::DebugBlessing' has a wrong offset!");
static_assert(offsetof(ACrabGM, CurrentPortals) == 0x000308, "Member 'ACrabGM::CurrentPortals' has a wrong offset!");
static_assert(offsetof(ACrabGM, ChosenPortal) == 0x000358, "Member 'ACrabGM::ChosenPortal' has a wrong offset!");

// Class CrabChampions.CrabGS
// 0x0100 (0x0370 - 0x0270)
class ACrabGS final : public AGameStateBase
{
public:
	class ACrabLM*                                LM;                                                // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabMatchState                               MatchState;                                        // 0x0278(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CB[0x1F];                                    // 0x0279(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTimePaused;                                     // 0x0298(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CC[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTime;                                       // 0x029C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentCountdown;                                  // 0x02A0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabDifficulty                               Difficulty;                                        // 0x02A4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CD[0x3];                                     // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x02A8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	ECrabBiome                                    Biome;                                             // 0x02B8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CE[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIsland;                                     // 0x02BC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabIslandType                               CurrentIslandType;                                 // 0x02C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14CF[0x3];                                     // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIslandStartTime;                            // 0x02C4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D0[0x4];                                     // 0x02C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIslandTimeRemaining;                        // 0x02CC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D1[0x8];                                     // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabChallengeModifier>                ChallengeModifiers;                                // 0x02D8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	ECrabBlessing                                 Blessing;                                          // 0x02E8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabLootPool                                 RewardLootPool;                                    // 0x02E9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D2[0x2];                                     // 0x02EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinigameScore;                                     // 0x02EC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D3[0x80];                                    // 0x02F0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Blessing();
	void OnRep_ChallengeModifiers();
	void OnRep_CurrentCountdown();
	void OnRep_CurrentIslandTimeRemaining();
	void OnRep_CurrentIslandType();
	void OnRep_CurrentTime();
	void OnRep_Difficulty();
	void OnRep_DifficultyModifiers();
	void OnRep_MatchState();
	void OnRep_MinigameScore();
	void OnRep_RewardLootPool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabGS">();
	}
	static class ACrabGS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabGS>();
	}
};
static_assert(alignof(ACrabGS) == 0x000008, "Wrong alignment on ACrabGS");
static_assert(sizeof(ACrabGS) == 0x000370, "Wrong size on ACrabGS");
static_assert(offsetof(ACrabGS, LM) == 0x000270, "Member 'ACrabGS::LM' has a wrong offset!");
static_assert(offsetof(ACrabGS, MatchState) == 0x000278, "Member 'ACrabGS::MatchState' has a wrong offset!");
static_assert(offsetof(ACrabGS, bIsTimePaused) == 0x000298, "Member 'ACrabGS::bIsTimePaused' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentTime) == 0x00029C, "Member 'ACrabGS::CurrentTime' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentCountdown) == 0x0002A0, "Member 'ACrabGS::CurrentCountdown' has a wrong offset!");
static_assert(offsetof(ACrabGS, Difficulty) == 0x0002A4, "Member 'ACrabGS::Difficulty' has a wrong offset!");
static_assert(offsetof(ACrabGS, DifficultyModifiers) == 0x0002A8, "Member 'ACrabGS::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(ACrabGS, Biome) == 0x0002B8, "Member 'ACrabGS::Biome' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIsland) == 0x0002BC, "Member 'ACrabGS::CurrentIsland' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIslandType) == 0x0002C0, "Member 'ACrabGS::CurrentIslandType' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIslandStartTime) == 0x0002C4, "Member 'ACrabGS::CurrentIslandStartTime' has a wrong offset!");
static_assert(offsetof(ACrabGS, CurrentIslandTimeRemaining) == 0x0002CC, "Member 'ACrabGS::CurrentIslandTimeRemaining' has a wrong offset!");
static_assert(offsetof(ACrabGS, ChallengeModifiers) == 0x0002D8, "Member 'ACrabGS::ChallengeModifiers' has a wrong offset!");
static_assert(offsetof(ACrabGS, Blessing) == 0x0002E8, "Member 'ACrabGS::Blessing' has a wrong offset!");
static_assert(offsetof(ACrabGS, RewardLootPool) == 0x0002E9, "Member 'ACrabGS::RewardLootPool' has a wrong offset!");
static_assert(offsetof(ACrabGS, MinigameScore) == 0x0002EC, "Member 'ACrabGS::MinigameScore' has a wrong offset!");

// Class CrabChampions.CrabHC
// 0x0080 (0x0130 - 0x00B0)
class UCrabHC final : public UActorComponent
{
public:
	class ACrabC*                                 OwningC;                                           // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BaseArmorPlates;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D4[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseMaxHealth;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D5[0xC];                                     // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldRegenerateHealth;                           // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D6[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRegenAmount;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D7[0x20];                                    // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBeEliminated;                                  // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasOneShotProtection;                             // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D8[0x2];                                     // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x00FC(0x001C)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D9[0x18];                                    // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HealthInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabHC">();
	}
	static class UCrabHC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabHC>();
	}
};
static_assert(alignof(UCrabHC) == 0x000008, "Wrong alignment on UCrabHC");
static_assert(sizeof(UCrabHC) == 0x000130, "Wrong size on UCrabHC");
static_assert(offsetof(UCrabHC, OwningC) == 0x0000B0, "Member 'UCrabHC::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabHC, BaseArmorPlates) == 0x0000B8, "Member 'UCrabHC::BaseArmorPlates' has a wrong offset!");
static_assert(offsetof(UCrabHC, BaseMaxHealth) == 0x0000C0, "Member 'UCrabHC::BaseMaxHealth' has a wrong offset!");
static_assert(offsetof(UCrabHC, bShouldRegenerateHealth) == 0x0000D0, "Member 'UCrabHC::bShouldRegenerateHealth' has a wrong offset!");
static_assert(offsetof(UCrabHC, HealthRegenAmount) == 0x0000D4, "Member 'UCrabHC::HealthRegenAmount' has a wrong offset!");
static_assert(offsetof(UCrabHC, bCanBeEliminated) == 0x0000F8, "Member 'UCrabHC::bCanBeEliminated' has a wrong offset!");
static_assert(offsetof(UCrabHC, bHasOneShotProtection) == 0x0000F9, "Member 'UCrabHC::bHasOneShotProtection' has a wrong offset!");
static_assert(offsetof(UCrabHC, HealthInfo) == 0x0000FC, "Member 'UCrabHC::HealthInfo' has a wrong offset!");

// Class CrabChampions.CrabLM
// 0x0328 (0x0548 - 0x0220)
class ACrabLM : public AActor
{
public:
	class USceneComponent*                        LMRoot;                                            // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Skydome;                                           // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionalLightComponent*             DL;                                                // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkyLightComponent*                     SL;                                                // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PP;                                                // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExponentialHeightFogComponent*         HF;                                                // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   Ocean;                                             // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          UnderwaterBounds;                                  // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  UnderwaterPP;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   IslandBounds;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AmbienceAC;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        MusicAC;                                           // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            SkydomeMesh;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            OceanMesh;                                         // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            IslandBoundsMesh;                                  // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BananaPPDistortionMat;                             // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     UnderwaterPPDistortionMat;                         // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           GlobalMPC;                                         // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollectionInstance*   GlobalMPCInstance;                                 // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRandomLightingPreset;                          // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DA[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LightingPresetIndex;                               // 0x02BC(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCrabLightingPreset>            LightingPresets;                                   // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCrabLightingPreset                    CurrentLightingPreset;                             // 0x02D0(0x00A0)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                GlobalSaturation;                                  // 0x0370(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlobalContrast;                                    // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumProjectilesToPool;                              // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DB[0x4];                                     // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACrabProjectile*>                PooledProjectiles;                                 // 0x0388(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCrabSpawnablesDA*                      SpawnablesDA;                                      // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           LocalC;                                            // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACrabC*>                         CharactersAffectingRippleSim;                      // 0x03A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         RippleSimUpdateRate;                               // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RippleViewDistance;                                // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RippleRTResolution;                                // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DC[0x4];                                     // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RippleHeightSimRTA;                                // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RippleHeightSimRTB;                                // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RippleHeightSimRTC;                                // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RippleNormalRT;                                    // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RippleDrawMat;                                     // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RippleDrawDMI;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RippleHeightSimMat;                                // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RippleHeightSimDMI;                                // 0x0400(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     RippleNormalSimMat;                                // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               RippleNormalSimDMI;                                // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RippleRadius;                                      // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RippleIntensity;                                   // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DD[0x8];                                     // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCrabPickupDA*>                  AllUnlockedPickups;                                // 0x0428(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DE[0x78];                                    // 0x0438(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACrabEnemyC>>        EnemyTypesToSpawn;                                 // 0x04B0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ACrabEnemyC>>        EnemiesToSpawn;                                    // 0x04C0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ACrabSpawnPoint*>                SpawnPoints;                                       // 0x04D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14DF[0x18];                                    // 0x04E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpawnBudgetCurve;                                  // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E0[0x48];                                    // 0x0500(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastPlayOneShotFX(class UNiagaraSystem* FXToPlay, class USoundCue* SoundToPlay, const struct FVector& SpawnLoc);
	void MulticastSpawnCosmeticProjectile(const struct FCrabProjectileInfo& ProjectileInfo, class AActor* ProjectileOwner, const struct FVector_NetQuantize& StartLoc, bool bExplodeInstantly);
	void OnRep_LightingPresetIndex();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabLM">();
	}
	static class ACrabLM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabLM>();
	}
};
static_assert(alignof(ACrabLM) == 0x000008, "Wrong alignment on ACrabLM");
static_assert(sizeof(ACrabLM) == 0x000548, "Wrong size on ACrabLM");
static_assert(offsetof(ACrabLM, LMRoot) == 0x000220, "Member 'ACrabLM::LMRoot' has a wrong offset!");
static_assert(offsetof(ACrabLM, Skydome) == 0x000228, "Member 'ACrabLM::Skydome' has a wrong offset!");
static_assert(offsetof(ACrabLM, DL) == 0x000230, "Member 'ACrabLM::DL' has a wrong offset!");
static_assert(offsetof(ACrabLM, SL) == 0x000238, "Member 'ACrabLM::SL' has a wrong offset!");
static_assert(offsetof(ACrabLM, PP) == 0x000240, "Member 'ACrabLM::PP' has a wrong offset!");
static_assert(offsetof(ACrabLM, HF) == 0x000248, "Member 'ACrabLM::HF' has a wrong offset!");
static_assert(offsetof(ACrabLM, Ocean) == 0x000250, "Member 'ACrabLM::Ocean' has a wrong offset!");
static_assert(offsetof(ACrabLM, UnderwaterBounds) == 0x000258, "Member 'ACrabLM::UnderwaterBounds' has a wrong offset!");
static_assert(offsetof(ACrabLM, UnderwaterPP) == 0x000260, "Member 'ACrabLM::UnderwaterPP' has a wrong offset!");
static_assert(offsetof(ACrabLM, IslandBounds) == 0x000268, "Member 'ACrabLM::IslandBounds' has a wrong offset!");
static_assert(offsetof(ACrabLM, AmbienceAC) == 0x000270, "Member 'ACrabLM::AmbienceAC' has a wrong offset!");
static_assert(offsetof(ACrabLM, MusicAC) == 0x000278, "Member 'ACrabLM::MusicAC' has a wrong offset!");
static_assert(offsetof(ACrabLM, SkydomeMesh) == 0x000280, "Member 'ACrabLM::SkydomeMesh' has a wrong offset!");
static_assert(offsetof(ACrabLM, OceanMesh) == 0x000288, "Member 'ACrabLM::OceanMesh' has a wrong offset!");
static_assert(offsetof(ACrabLM, IslandBoundsMesh) == 0x000290, "Member 'ACrabLM::IslandBoundsMesh' has a wrong offset!");
static_assert(offsetof(ACrabLM, BananaPPDistortionMat) == 0x000298, "Member 'ACrabLM::BananaPPDistortionMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, UnderwaterPPDistortionMat) == 0x0002A0, "Member 'ACrabLM::UnderwaterPPDistortionMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalMPC) == 0x0002A8, "Member 'ACrabLM::GlobalMPC' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalMPCInstance) == 0x0002B0, "Member 'ACrabLM::GlobalMPCInstance' has a wrong offset!");
static_assert(offsetof(ACrabLM, bUseRandomLightingPreset) == 0x0002B8, "Member 'ACrabLM::bUseRandomLightingPreset' has a wrong offset!");
static_assert(offsetof(ACrabLM, LightingPresetIndex) == 0x0002BC, "Member 'ACrabLM::LightingPresetIndex' has a wrong offset!");
static_assert(offsetof(ACrabLM, LightingPresets) == 0x0002C0, "Member 'ACrabLM::LightingPresets' has a wrong offset!");
static_assert(offsetof(ACrabLM, CurrentLightingPreset) == 0x0002D0, "Member 'ACrabLM::CurrentLightingPreset' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalSaturation) == 0x000370, "Member 'ACrabLM::GlobalSaturation' has a wrong offset!");
static_assert(offsetof(ACrabLM, GlobalContrast) == 0x00037C, "Member 'ACrabLM::GlobalContrast' has a wrong offset!");
static_assert(offsetof(ACrabLM, NumProjectilesToPool) == 0x000380, "Member 'ACrabLM::NumProjectilesToPool' has a wrong offset!");
static_assert(offsetof(ACrabLM, PooledProjectiles) == 0x000388, "Member 'ACrabLM::PooledProjectiles' has a wrong offset!");
static_assert(offsetof(ACrabLM, SpawnablesDA) == 0x000398, "Member 'ACrabLM::SpawnablesDA' has a wrong offset!");
static_assert(offsetof(ACrabLM, LocalC) == 0x0003A0, "Member 'ACrabLM::LocalC' has a wrong offset!");
static_assert(offsetof(ACrabLM, CharactersAffectingRippleSim) == 0x0003A8, "Member 'ACrabLM::CharactersAffectingRippleSim' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleSimUpdateRate) == 0x0003B8, "Member 'ACrabLM::RippleSimUpdateRate' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleViewDistance) == 0x0003BC, "Member 'ACrabLM::RippleViewDistance' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleRTResolution) == 0x0003C0, "Member 'ACrabLM::RippleRTResolution' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimRTA) == 0x0003C8, "Member 'ACrabLM::RippleHeightSimRTA' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimRTB) == 0x0003D0, "Member 'ACrabLM::RippleHeightSimRTB' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimRTC) == 0x0003D8, "Member 'ACrabLM::RippleHeightSimRTC' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleNormalRT) == 0x0003E0, "Member 'ACrabLM::RippleNormalRT' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleDrawMat) == 0x0003E8, "Member 'ACrabLM::RippleDrawMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleDrawDMI) == 0x0003F0, "Member 'ACrabLM::RippleDrawDMI' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimMat) == 0x0003F8, "Member 'ACrabLM::RippleHeightSimMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleHeightSimDMI) == 0x000400, "Member 'ACrabLM::RippleHeightSimDMI' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleNormalSimMat) == 0x000408, "Member 'ACrabLM::RippleNormalSimMat' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleNormalSimDMI) == 0x000410, "Member 'ACrabLM::RippleNormalSimDMI' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleRadius) == 0x000418, "Member 'ACrabLM::RippleRadius' has a wrong offset!");
static_assert(offsetof(ACrabLM, RippleIntensity) == 0x00041C, "Member 'ACrabLM::RippleIntensity' has a wrong offset!");
static_assert(offsetof(ACrabLM, AllUnlockedPickups) == 0x000428, "Member 'ACrabLM::AllUnlockedPickups' has a wrong offset!");
static_assert(offsetof(ACrabLM, EnemyTypesToSpawn) == 0x0004B0, "Member 'ACrabLM::EnemyTypesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabLM, EnemiesToSpawn) == 0x0004C0, "Member 'ACrabLM::EnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabLM, SpawnPoints) == 0x0004D0, "Member 'ACrabLM::SpawnPoints' has a wrong offset!");
static_assert(offsetof(ACrabLM, SpawnBudgetCurve) == 0x0004F8, "Member 'ACrabLM::SpawnBudgetCurve' has a wrong offset!");

// Class CrabChampions.CrabPC
// 0x0350 (0x08C0 - 0x0570)
class ACrabPC : public APlayerController
{
public:
	class USoundCue*                              ArmorHitmarkerSound;                               // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ArmorBreakHitmarkerSound;                          // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              QuietHitmarkerSound;                               // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              NormalHitmarkerSound;                              // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LoudHitmarkerSound;                                // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              QuietCritHitmarkerSound;                           // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              NormalCritHitmarkerSound;                          // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              LoudCritHitmarkerSound;                            // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              KnockbackDamageHitmarkerSound;                     // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              EliminationHitmarkerSound;                         // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E3[0x8];                                     // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              SlomoRampTimeline;                                 // 0x05C8(0x0098)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SlomoRampCurve;                                    // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    LSActor;                                           // 0x0668(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E4[0x48];                                    // 0x0670(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class USubmixEffectFilterPreset*              LowPassSubmixEffect;                               // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         PortalTransitionLS;                                // 0x06C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabAutoSave                          PendingAutoSave;                                   // 0x06C8(0x0130)(Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDamageTextUI>          DamageTextUIToSpawn;                               // 0x07F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACrabDamageTextActor*>           PooledDamageTextActors;                            // 0x0800(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabChallenge>                 CompletedChallenges;                               // 0x0810(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ACrabPlayerC*                           ClientOwnedC;                                      // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameStateUI>           GameStateUIToSpawn;                                // 0x0828(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabGameStateUI*                       GameStateUI;                                       // 0x0830(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameplayUI>            GameplayUIToSpawn;                                 // 0x0838(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabGameplayUI*                        GameplayUI;                                        // 0x0840(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInventoryUI>           InventoryUIToSpawn;                                // 0x0848(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInventoryUI*                       InventoryUI;                                       // 0x0850(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInGameMenuUI>          InGameMenuToSpawn;                                 // 0x0858(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInGameMenuUI*                      InGameMenuUI;                                      // 0x0860(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabCosmeticsMenuUI>       CosmeticsMenuUIToSpawn;                            // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCosmeticsMenuUI*                   CosmeticsMenuUI;                                   // 0x0870(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDifficultyMenuUI>      DifficultyMenuUIToSpawn;                           // 0x0878(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabDifficultyMenuUI*                  DifficultyMenuUI;                                  // 0x0880(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabMultiplayerMenuUI>     MultiplayerMenuUIToSpawn;                          // 0x0888(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMultiplayerMenuUI*                 MultiplayerMenuUI;                                 // 0x0890(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabGameOverUI>            GameOverUIToSpawn;                                 // 0x0898(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabGameOverUI*                        GameOverUI;                                        // 0x08A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabMinigameGameOverUI>    MinigameGameOverUIToSpawn;                         // 0x08A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMinigameGameOverUI*                MinigameGameOverUI;                                // 0x08B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabFocusMenuUI*                       ActiveFocusMenuUI;                                 // 0x08B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClientClearAutoSave();
	void ClientInventoryEvent(const class FString& InventoryEventMessage);
	void ClientLeaveGame();
	void ClientNotifyDamageDealt(const struct FCrabDamageInfo& DamageInfo, ECrabDamageHitType DamageHitType);
	void ClientOnClearedIsland(bool bWasFlawlessClear);
	void ClientOnEliminated(const class FString& EliminatedByPlayerName);
	void ClientOnEnteredPortal(const struct FCrabNextIslandInfo& NextIslandInfo);
	void ClientOnInteractedWithKeyTotem(class ACrabTotem* KeyTotem);
	void ClientOnPickedUpPickup(class UCrabPickupDA* PickupDA, uint8 Level);
	void ClientOnReceivedChatMessage(const class FString& PlayerName, const class FString& ChatMessage);
	void ClientOnTookDamage(ECrabDamageHitType DamageHitType);
	void ClientPlayerLeftGame();
	void ClientRefreshPSUI();
	void ClientSetIsCharacterInputEnabled(bool bNewIsCharacterInputEnabled);
	void ClientShowCosmeticsMenuUI();
	void ClientShowLoadingScreenUI();
	void ClientStartSlomoRamp();
	void ClientUploadLobbyStats();
	void OnSlomoRampTimelineUpdated(float Value);
	void ServerRestoreAutoSave(const struct FCrabAutoSave& AutoSave);
	void ServerSendChatMessage(const class FString& ChatMessage);
	void ServerSpawnKeyTotemPickup(class ACrabTotem* KeyTotem, class UCrabPickupDA* PickupToSpawn);
	void ServerSpectateNextPlayer();
	void ServerUploadLobbyStats(const struct FCrabLobbyStats& LobbyStats);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPC">();
	}
	static class ACrabPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPC>();
	}
};
static_assert(alignof(ACrabPC) == 0x000008, "Wrong alignment on ACrabPC");
static_assert(sizeof(ACrabPC) == 0x0008C0, "Wrong size on ACrabPC");
static_assert(offsetof(ACrabPC, ArmorHitmarkerSound) == 0x000570, "Member 'ACrabPC::ArmorHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, ArmorBreakHitmarkerSound) == 0x000578, "Member 'ACrabPC::ArmorBreakHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, QuietHitmarkerSound) == 0x000580, "Member 'ACrabPC::QuietHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, NormalHitmarkerSound) == 0x000588, "Member 'ACrabPC::NormalHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, LoudHitmarkerSound) == 0x000590, "Member 'ACrabPC::LoudHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, QuietCritHitmarkerSound) == 0x000598, "Member 'ACrabPC::QuietCritHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, NormalCritHitmarkerSound) == 0x0005A0, "Member 'ACrabPC::NormalCritHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, LoudCritHitmarkerSound) == 0x0005A8, "Member 'ACrabPC::LoudCritHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, KnockbackDamageHitmarkerSound) == 0x0005B0, "Member 'ACrabPC::KnockbackDamageHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, EliminationHitmarkerSound) == 0x0005B8, "Member 'ACrabPC::EliminationHitmarkerSound' has a wrong offset!");
static_assert(offsetof(ACrabPC, SlomoRampTimeline) == 0x0005C8, "Member 'ACrabPC::SlomoRampTimeline' has a wrong offset!");
static_assert(offsetof(ACrabPC, SlomoRampCurve) == 0x000660, "Member 'ACrabPC::SlomoRampCurve' has a wrong offset!");
static_assert(offsetof(ACrabPC, LSActor) == 0x000668, "Member 'ACrabPC::LSActor' has a wrong offset!");
static_assert(offsetof(ACrabPC, LowPassSubmixEffect) == 0x0006B8, "Member 'ACrabPC::LowPassSubmixEffect' has a wrong offset!");
static_assert(offsetof(ACrabPC, PortalTransitionLS) == 0x0006C0, "Member 'ACrabPC::PortalTransitionLS' has a wrong offset!");
static_assert(offsetof(ACrabPC, PendingAutoSave) == 0x0006C8, "Member 'ACrabPC::PendingAutoSave' has a wrong offset!");
static_assert(offsetof(ACrabPC, DamageTextUIToSpawn) == 0x0007F8, "Member 'ACrabPC::DamageTextUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, PooledDamageTextActors) == 0x000800, "Member 'ACrabPC::PooledDamageTextActors' has a wrong offset!");
static_assert(offsetof(ACrabPC, CompletedChallenges) == 0x000810, "Member 'ACrabPC::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(ACrabPC, ClientOwnedC) == 0x000820, "Member 'ACrabPC::ClientOwnedC' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameStateUIToSpawn) == 0x000828, "Member 'ACrabPC::GameStateUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameStateUI) == 0x000830, "Member 'ACrabPC::GameStateUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameplayUIToSpawn) == 0x000838, "Member 'ACrabPC::GameplayUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameplayUI) == 0x000840, "Member 'ACrabPC::GameplayUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, InventoryUIToSpawn) == 0x000848, "Member 'ACrabPC::InventoryUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, InventoryUI) == 0x000850, "Member 'ACrabPC::InventoryUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, InGameMenuToSpawn) == 0x000858, "Member 'ACrabPC::InGameMenuToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, InGameMenuUI) == 0x000860, "Member 'ACrabPC::InGameMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, CosmeticsMenuUIToSpawn) == 0x000868, "Member 'ACrabPC::CosmeticsMenuUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, CosmeticsMenuUI) == 0x000870, "Member 'ACrabPC::CosmeticsMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, DifficultyMenuUIToSpawn) == 0x000878, "Member 'ACrabPC::DifficultyMenuUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, DifficultyMenuUI) == 0x000880, "Member 'ACrabPC::DifficultyMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, MultiplayerMenuUIToSpawn) == 0x000888, "Member 'ACrabPC::MultiplayerMenuUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, MultiplayerMenuUI) == 0x000890, "Member 'ACrabPC::MultiplayerMenuUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameOverUIToSpawn) == 0x000898, "Member 'ACrabPC::GameOverUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, GameOverUI) == 0x0008A0, "Member 'ACrabPC::GameOverUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, MinigameGameOverUIToSpawn) == 0x0008A8, "Member 'ACrabPC::MinigameGameOverUIToSpawn' has a wrong offset!");
static_assert(offsetof(ACrabPC, MinigameGameOverUI) == 0x0008B0, "Member 'ACrabPC::MinigameGameOverUI' has a wrong offset!");
static_assert(offsetof(ACrabPC, ActiveFocusMenuUI) == 0x0008B8, "Member 'ACrabPC::ActiveFocusMenuUI' has a wrong offset!");

// Class CrabChampions.CrabPMC
// 0x00C8 (0x01B8 - 0x00F0)
class UCrabPMC final : public UMovementComponent
{
public:
	uint8                                         Pad_14E7[0x38];                                    // 0x00F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabC*                                 HomingTarget;                                      // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E8[0x10];                                    // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrabProjectileDA*                      ProjectileDA;                                      // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabC*                                 OwningC;                                           // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACrabProjectile*                        OwningProjectile;                                  // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14E9[0x60];                                    // 0x0158(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPMC">();
	}
	static class UCrabPMC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPMC>();
	}
};
static_assert(alignof(UCrabPMC) == 0x000008, "Wrong alignment on UCrabPMC");
static_assert(sizeof(UCrabPMC) == 0x0001B8, "Wrong size on UCrabPMC");
static_assert(offsetof(UCrabPMC, HomingTarget) == 0x000128, "Member 'UCrabPMC::HomingTarget' has a wrong offset!");
static_assert(offsetof(UCrabPMC, ProjectileDA) == 0x000140, "Member 'UCrabPMC::ProjectileDA' has a wrong offset!");
static_assert(offsetof(UCrabPMC, OwningC) == 0x000148, "Member 'UCrabPMC::OwningC' has a wrong offset!");
static_assert(offsetof(UCrabPMC, OwningProjectile) == 0x000150, "Member 'UCrabPMC::OwningProjectile' has a wrong offset!");

// Class CrabChampions.CrabPS
// 0x0240 (0x0560 - 0x0320)
class ACrabPS final : public APlayerState
{
public:
	uint8                                         Pad_14EA[0x8];                                     // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabInventoryCooldown>         InventoryCooldowns;                                // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         PlayerColorIndex;                                  // 0x0338(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14EB[0x7];                                     // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCrabPickupDA*>                  PSPickups;                                         // 0x0340(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         Points;                                            // 0x0350(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ComboCounter;                                      // 0x0354(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Combo;                                             // 0x0358(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Eliminations;                                      // 0x035C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14EC[0xC];                                     // 0x0360(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        DamageDealt;                                       // 0x036C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        HighestDamageDealt;                                // 0x0370(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageTaken;                                       // 0x0374(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DamageTakenOnThisIsland;                           // 0x0378(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumFlawlessIslands;                                // 0x037C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabHealthInfo                        HealthInfo;                                        // 0x0380(0x001C)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxHealthMultiplier;                               // 0x039C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageMultiplier;                                  // 0x03A0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleMultiplier;                                   // 0x03A4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECrabRank                                     AccountRank;                                       // 0x03A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14ED[0x3];                                     // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccountLevel;                                      // 0x03AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Keys;                                              // 0x03B0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14EE[0x4];                                     // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CrabSkin;                                          // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x03C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x03C8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x03D0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumWeaponModSlots;                                 // 0x03D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14EF[0x7];                                     // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabWeaponMod>                 WeaponMods;                                        // 0x03E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         NumGrenadeModSlots;                                // 0x03F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F0[0x7];                                     // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabGrenadeMod>                GrenadeMods;                                       // 0x03F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         NumPerkSlots;                                      // 0x0408(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F1[0x7];                                     // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabPerk>                      Perks;                                             // 0x0410(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCrabRelic>                     Relics;                                            // 0x0420(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F2[0x1C];                                    // 0x0430(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTimesSalvaged;                                  // 0x044C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumShopPurchases;                                  // 0x0450(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumShopRerolls;                                    // 0x0454(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumTotemsDestroyed;                                // 0x0458(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        Crystals;                                          // 0x045C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F3[0x4];                                     // 0x0460(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ECrabRarity                                   IslandRewardRarity;                                // 0x0464(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F4[0x3];                                     // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ACrabCheckpoint*                        ParkourCheckpoint;                                 // 0x0468(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACrabPortal*                            ChosenPortal;                                      // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalTimeTaken;                                    // 0x0478(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14F5[0xE4];                                    // 0x047C(0x00E4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbilityDA();
	void OnRep_AccountLevel();
	void OnRep_AccountRank();
	void OnRep_Combo();
	void OnRep_Crystals();
	void OnRep_Eliminations();
	void OnRep_Inventory();
	void OnRep_IslandRewardRarity();
	void OnRep_Keys();
	void OnRep_MeleeDA();
	void OnRep_Points();
	void OnRep_ScaleMultiplier();
	void OnRep_WeaponDA();
	void ServerEquipCosmetics(class UMaterialInterface* NewCrabSkin);
	void ServerEquipInventory(class UCrabWeaponDA* NewWeaponDA, class UCrabAbilityDA* NewAbilityDA, class UCrabMeleeDA* NewMeleeDA);
	void ServerIncrementNumInventorySlots(ECrabPickupType PickupType, int32 Cost);
	void ServerRefreshAccount(ECrabRank NewAccountRank, int32 NewAccountLevel, int32 NewKeys);
	void ServerRemoveGrenadeMod(ECrabGrenadeModType GrenadeModType);
	void ServerRemovePerk(ECrabPerkType PerkType);
	void ServerRemoveRelic(ECrabRelicType RelicType);
	void ServerRemoveWeaponMod(ECrabWeaponModType WeaponModType);
	void ServerSetAbilityDA(class UCrabAbilityDA* NewAbilityDA);
	void ServerSetMeleeDA(class UCrabMeleeDA* NewMeleeDA);
	void ServerSetWeaponDA(class UCrabWeaponDA* NewWeaponDA);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPS">();
	}
	static class ACrabPS* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrabPS>();
	}
};
static_assert(alignof(ACrabPS) == 0x000008, "Wrong alignment on ACrabPS");
static_assert(sizeof(ACrabPS) == 0x000560, "Wrong size on ACrabPS");
static_assert(offsetof(ACrabPS, InventoryCooldowns) == 0x000328, "Member 'ACrabPS::InventoryCooldowns' has a wrong offset!");
static_assert(offsetof(ACrabPS, PlayerColorIndex) == 0x000338, "Member 'ACrabPS::PlayerColorIndex' has a wrong offset!");
static_assert(offsetof(ACrabPS, PSPickups) == 0x000340, "Member 'ACrabPS::PSPickups' has a wrong offset!");
static_assert(offsetof(ACrabPS, Points) == 0x000350, "Member 'ACrabPS::Points' has a wrong offset!");
static_assert(offsetof(ACrabPS, ComboCounter) == 0x000354, "Member 'ACrabPS::ComboCounter' has a wrong offset!");
static_assert(offsetof(ACrabPS, Combo) == 0x000358, "Member 'ACrabPS::Combo' has a wrong offset!");
static_assert(offsetof(ACrabPS, Eliminations) == 0x00035C, "Member 'ACrabPS::Eliminations' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageDealt) == 0x00036C, "Member 'ACrabPS::DamageDealt' has a wrong offset!");
static_assert(offsetof(ACrabPS, HighestDamageDealt) == 0x000370, "Member 'ACrabPS::HighestDamageDealt' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageTaken) == 0x000374, "Member 'ACrabPS::DamageTaken' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageTakenOnThisIsland) == 0x000378, "Member 'ACrabPS::DamageTakenOnThisIsland' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumFlawlessIslands) == 0x00037C, "Member 'ACrabPS::NumFlawlessIslands' has a wrong offset!");
static_assert(offsetof(ACrabPS, HealthInfo) == 0x000380, "Member 'ACrabPS::HealthInfo' has a wrong offset!");
static_assert(offsetof(ACrabPS, MaxHealthMultiplier) == 0x00039C, "Member 'ACrabPS::MaxHealthMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPS, DamageMultiplier) == 0x0003A0, "Member 'ACrabPS::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPS, ScaleMultiplier) == 0x0003A4, "Member 'ACrabPS::ScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ACrabPS, AccountRank) == 0x0003A8, "Member 'ACrabPS::AccountRank' has a wrong offset!");
static_assert(offsetof(ACrabPS, AccountLevel) == 0x0003AC, "Member 'ACrabPS::AccountLevel' has a wrong offset!");
static_assert(offsetof(ACrabPS, Keys) == 0x0003B0, "Member 'ACrabPS::Keys' has a wrong offset!");
static_assert(offsetof(ACrabPS, CrabSkin) == 0x0003B8, "Member 'ACrabPS::CrabSkin' has a wrong offset!");
static_assert(offsetof(ACrabPS, WeaponDA) == 0x0003C0, "Member 'ACrabPS::WeaponDA' has a wrong offset!");
static_assert(offsetof(ACrabPS, AbilityDA) == 0x0003C8, "Member 'ACrabPS::AbilityDA' has a wrong offset!");
static_assert(offsetof(ACrabPS, MeleeDA) == 0x0003D0, "Member 'ACrabPS::MeleeDA' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumWeaponModSlots) == 0x0003D8, "Member 'ACrabPS::NumWeaponModSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, WeaponMods) == 0x0003E0, "Member 'ACrabPS::WeaponMods' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumGrenadeModSlots) == 0x0003F0, "Member 'ACrabPS::NumGrenadeModSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, GrenadeMods) == 0x0003F8, "Member 'ACrabPS::GrenadeMods' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumPerkSlots) == 0x000408, "Member 'ACrabPS::NumPerkSlots' has a wrong offset!");
static_assert(offsetof(ACrabPS, Perks) == 0x000410, "Member 'ACrabPS::Perks' has a wrong offset!");
static_assert(offsetof(ACrabPS, Relics) == 0x000420, "Member 'ACrabPS::Relics' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumTimesSalvaged) == 0x00044C, "Member 'ACrabPS::NumTimesSalvaged' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumShopPurchases) == 0x000450, "Member 'ACrabPS::NumShopPurchases' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumShopRerolls) == 0x000454, "Member 'ACrabPS::NumShopRerolls' has a wrong offset!");
static_assert(offsetof(ACrabPS, NumTotemsDestroyed) == 0x000458, "Member 'ACrabPS::NumTotemsDestroyed' has a wrong offset!");
static_assert(offsetof(ACrabPS, Crystals) == 0x00045C, "Member 'ACrabPS::Crystals' has a wrong offset!");
static_assert(offsetof(ACrabPS, IslandRewardRarity) == 0x000464, "Member 'ACrabPS::IslandRewardRarity' has a wrong offset!");
static_assert(offsetof(ACrabPS, ParkourCheckpoint) == 0x000468, "Member 'ACrabPS::ParkourCheckpoint' has a wrong offset!");
static_assert(offsetof(ACrabPS, ChosenPortal) == 0x000470, "Member 'ACrabPS::ChosenPortal' has a wrong offset!");
static_assert(offsetof(ACrabPS, TotalTimeTaken) == 0x000478, "Member 'ACrabPS::TotalTimeTaken' has a wrong offset!");

// Class CrabChampions.CrabSG
// 0x0268 (0x0290 - 0x0028)
class UCrabSG final : public USaveGame
{
public:
	int32                                         CrabChampionsVersion;                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastSavedBackupA;                                 // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F8[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         XPToNextLevelUp;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F9[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCrabRankedWeapon>              RankedWeapons;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AccountLevel;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Keys;                                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrabDifficulty                               Difficulty;                                        // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14FA[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECrabDifficultyModifier>               DifficultyModifiers;                               // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CrabSkin;                                          // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabWeaponDA*                          WeaponDA;                                          // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabAbilityDA*                         AbilityDA;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCrabMeleeDA*                           MeleeDA;                                           // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrabChallenge>                 Challenges;                                        // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedWeapons;                                   // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedAbilities;                                 // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedMeleeWeapons;                              // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedWeaponMods;                                // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedGrenadeMods;                               // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedPerks;                                     // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCrabPickupDA*>                  UnlockedRelics;                                    // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         EasyHighScore;                                     // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyAttempts;                                      // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyWins;                                          // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyWinStreak;                                     // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyHighestIslandReached;                          // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalHighScore;                                   // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalAttempts;                                    // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalWins;                                        // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalWinStreak;                                   // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NormalHighestIslandReached;                        // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareHighScore;                                // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareAttempts;                                 // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareWins;                                     // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareWinStreak;                                // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NightmareHighestIslandReached;                     // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosHighScore;                               // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosAttempts;                                // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosWins;                                    // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosWinStreak;                               // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltraChaosHighestIslandReached;                    // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCrabAutoSave                          AutoSave;                                          // 0x0158(0x0130)(NativeAccessSpecifierPublic)
	int32                                         ArcadeHighScore;                                   // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HoldoutHighScore;                                  // 0x028C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabSG">();
	}
	static class UCrabSG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabSG>();
	}
};
static_assert(alignof(UCrabSG) == 0x000008, "Wrong alignment on UCrabSG");
static_assert(sizeof(UCrabSG) == 0x000290, "Wrong size on UCrabSG");
static_assert(offsetof(UCrabSG, CrabChampionsVersion) == 0x000028, "Member 'UCrabSG::CrabChampionsVersion' has a wrong offset!");
static_assert(offsetof(UCrabSG, bLastSavedBackupA) == 0x00002C, "Member 'UCrabSG::bLastSavedBackupA' has a wrong offset!");
static_assert(offsetof(UCrabSG, XPToNextLevelUp) == 0x000030, "Member 'UCrabSG::XPToNextLevelUp' has a wrong offset!");
static_assert(offsetof(UCrabSG, RankedWeapons) == 0x000038, "Member 'UCrabSG::RankedWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSG, AccountLevel) == 0x000048, "Member 'UCrabSG::AccountLevel' has a wrong offset!");
static_assert(offsetof(UCrabSG, Keys) == 0x00004C, "Member 'UCrabSG::Keys' has a wrong offset!");
static_assert(offsetof(UCrabSG, Difficulty) == 0x000050, "Member 'UCrabSG::Difficulty' has a wrong offset!");
static_assert(offsetof(UCrabSG, DifficultyModifiers) == 0x000058, "Member 'UCrabSG::DifficultyModifiers' has a wrong offset!");
static_assert(offsetof(UCrabSG, CrabSkin) == 0x000068, "Member 'UCrabSG::CrabSkin' has a wrong offset!");
static_assert(offsetof(UCrabSG, WeaponDA) == 0x000070, "Member 'UCrabSG::WeaponDA' has a wrong offset!");
static_assert(offsetof(UCrabSG, AbilityDA) == 0x000078, "Member 'UCrabSG::AbilityDA' has a wrong offset!");
static_assert(offsetof(UCrabSG, MeleeDA) == 0x000080, "Member 'UCrabSG::MeleeDA' has a wrong offset!");
static_assert(offsetof(UCrabSG, Challenges) == 0x000088, "Member 'UCrabSG::Challenges' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedWeapons) == 0x000098, "Member 'UCrabSG::UnlockedWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedAbilities) == 0x0000A8, "Member 'UCrabSG::UnlockedAbilities' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedMeleeWeapons) == 0x0000B8, "Member 'UCrabSG::UnlockedMeleeWeapons' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedWeaponMods) == 0x0000C8, "Member 'UCrabSG::UnlockedWeaponMods' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedGrenadeMods) == 0x0000D8, "Member 'UCrabSG::UnlockedGrenadeMods' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedPerks) == 0x0000E8, "Member 'UCrabSG::UnlockedPerks' has a wrong offset!");
static_assert(offsetof(UCrabSG, UnlockedRelics) == 0x0000F8, "Member 'UCrabSG::UnlockedRelics' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyHighScore) == 0x000108, "Member 'UCrabSG::EasyHighScore' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyAttempts) == 0x00010C, "Member 'UCrabSG::EasyAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyWins) == 0x000110, "Member 'UCrabSG::EasyWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyWinStreak) == 0x000114, "Member 'UCrabSG::EasyWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, EasyHighestIslandReached) == 0x000118, "Member 'UCrabSG::EasyHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalHighScore) == 0x00011C, "Member 'UCrabSG::NormalHighScore' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalAttempts) == 0x000120, "Member 'UCrabSG::NormalAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalWins) == 0x000124, "Member 'UCrabSG::NormalWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalWinStreak) == 0x000128, "Member 'UCrabSG::NormalWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, NormalHighestIslandReached) == 0x00012C, "Member 'UCrabSG::NormalHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareHighScore) == 0x000130, "Member 'UCrabSG::NightmareHighScore' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareAttempts) == 0x000134, "Member 'UCrabSG::NightmareAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareWins) == 0x000138, "Member 'UCrabSG::NightmareWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareWinStreak) == 0x00013C, "Member 'UCrabSG::NightmareWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, NightmareHighestIslandReached) == 0x000140, "Member 'UCrabSG::NightmareHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosHighScore) == 0x000144, "Member 'UCrabSG::UltraChaosHighScore' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosAttempts) == 0x000148, "Member 'UCrabSG::UltraChaosAttempts' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosWins) == 0x00014C, "Member 'UCrabSG::UltraChaosWins' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosWinStreak) == 0x000150, "Member 'UCrabSG::UltraChaosWinStreak' has a wrong offset!");
static_assert(offsetof(UCrabSG, UltraChaosHighestIslandReached) == 0x000154, "Member 'UCrabSG::UltraChaosHighestIslandReached' has a wrong offset!");
static_assert(offsetof(UCrabSG, AutoSave) == 0x000158, "Member 'UCrabSG::AutoSave' has a wrong offset!");
static_assert(offsetof(UCrabSG, ArcadeHighScore) == 0x000288, "Member 'UCrabSG::ArcadeHighScore' has a wrong offset!");
static_assert(offsetof(UCrabSG, HoldoutHighScore) == 0x00028C, "Member 'UCrabSG::HoldoutHighScore' has a wrong offset!");

// Class CrabChampions.CrabArrowSelectionUI
// 0x0050 (0x0308 - 0x02B8)
class UCrabArrowSelectionUI : public UCrabUI
{
public:
	uint8                                         Pad_14FB[0x20];                                    // 0x02B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             CurrentSelectionText;                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NextButton;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                PreviousButton;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FC[0x18];                                    // 0x02F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredNextButton();
	void OnHoveredPreviousButton();
	void OnPressedNextButton();
	void OnPressedPreviousButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabArrowSelectionUI">();
	}
	static class UCrabArrowSelectionUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabArrowSelectionUI>();
	}
};
static_assert(alignof(UCrabArrowSelectionUI) == 0x000008, "Wrong alignment on UCrabArrowSelectionUI");
static_assert(sizeof(UCrabArrowSelectionUI) == 0x000308, "Wrong size on UCrabArrowSelectionUI");
static_assert(offsetof(UCrabArrowSelectionUI, CurrentSelectionText) == 0x0002D8, "Member 'UCrabArrowSelectionUI::CurrentSelectionText' has a wrong offset!");
static_assert(offsetof(UCrabArrowSelectionUI, NextButton) == 0x0002E0, "Member 'UCrabArrowSelectionUI::NextButton' has a wrong offset!");
static_assert(offsetof(UCrabArrowSelectionUI, PreviousButton) == 0x0002E8, "Member 'UCrabArrowSelectionUI::PreviousButton' has a wrong offset!");

// Class CrabChampions.CrabCosmeticsMenuUI
// 0x0058 (0x0428 - 0x03D0)
class UCrabCosmeticsMenuUI : public UCrabFocusMenuUI
{
public:
	class ACrabCosmeticC*                         CosmeticC;                                         // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabCosmeticSlotUI>        CosmeticSlotUIToSpawn;                             // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      CosmeticsUniformGridPanel;                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                CrabSkinsButton;                                   // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                WeaponSkinsButton;                                 // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabCosmeticSlotUI*                    SelectedCosmeticSlotUI;                            // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticNameText;                                  // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeDescriptionText;                          // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeProgressText;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeGoalText;                                 // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ChallengePB;                                       // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPressedCrabSkinsButton();
	void OnPressedWeaponSkinsButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabCosmeticsMenuUI">();
	}
	static class UCrabCosmeticsMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabCosmeticsMenuUI>();
	}
};
static_assert(alignof(UCrabCosmeticsMenuUI) == 0x000008, "Wrong alignment on UCrabCosmeticsMenuUI");
static_assert(sizeof(UCrabCosmeticsMenuUI) == 0x000428, "Wrong size on UCrabCosmeticsMenuUI");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticC) == 0x0003D0, "Member 'UCrabCosmeticsMenuUI::CosmeticC' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticSlotUIToSpawn) == 0x0003D8, "Member 'UCrabCosmeticsMenuUI::CosmeticSlotUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticsUniformGridPanel) == 0x0003E0, "Member 'UCrabCosmeticsMenuUI::CosmeticsUniformGridPanel' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CrabSkinsButton) == 0x0003E8, "Member 'UCrabCosmeticsMenuUI::CrabSkinsButton' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, WeaponSkinsButton) == 0x0003F0, "Member 'UCrabCosmeticsMenuUI::WeaponSkinsButton' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, SelectedCosmeticSlotUI) == 0x0003F8, "Member 'UCrabCosmeticsMenuUI::SelectedCosmeticSlotUI' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, CosmeticNameText) == 0x000400, "Member 'UCrabCosmeticsMenuUI::CosmeticNameText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengeDescriptionText) == 0x000408, "Member 'UCrabCosmeticsMenuUI::ChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengeProgressText) == 0x000410, "Member 'UCrabCosmeticsMenuUI::ChallengeProgressText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengeGoalText) == 0x000418, "Member 'UCrabCosmeticsMenuUI::ChallengeGoalText' has a wrong offset!");
static_assert(offsetof(UCrabCosmeticsMenuUI, ChallengePB) == 0x000420, "Member 'UCrabCosmeticsMenuUI::ChallengePB' has a wrong offset!");

// Class CrabChampions.CrabDifficultyMenuUI
// 0x0080 (0x0450 - 0x03D0)
class UCrabDifficultyMenuUI : public UCrabFocusMenuUI
{
public:
	class UOverlay*                               EasyButtonOverlay;                                 // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                EasyButton;                                        // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               EasyChallengeLevelOverlay;                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NormalButtonOverlay;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NormalButton;                                      // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NormalChallengeLevelOverlay;                       // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NightmareButtonOverlay;                            // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NightmareButton;                                   // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               NightmareChallengeLevelOverlay;                    // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         UltraChaosHorizontalBox;                           // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               UltraChaosButtonOverlay;                           // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                UltraChaosButton;                                  // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               UltraChaosChallengeLevelOverlay;                   // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeLevelText;                                // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           DifficultyModifiersVerticalBox;                    // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabDifficultyModifierUI>  DifficultyModifierUIToSpawn;                       // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredEasyButton();
	void OnHoveredNightmareButton();
	void OnHoveredNormalButton();
	void OnHoveredUltraChaosButton();
	void OnPressedEasyButton();
	void OnPressedNightmareButton();
	void OnPressedNormalButton();
	void OnPressedUltraChaosButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabDifficultyMenuUI">();
	}
	static class UCrabDifficultyMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabDifficultyMenuUI>();
	}
};
static_assert(alignof(UCrabDifficultyMenuUI) == 0x000008, "Wrong alignment on UCrabDifficultyMenuUI");
static_assert(sizeof(UCrabDifficultyMenuUI) == 0x000450, "Wrong size on UCrabDifficultyMenuUI");
static_assert(offsetof(UCrabDifficultyMenuUI, EasyButtonOverlay) == 0x0003D0, "Member 'UCrabDifficultyMenuUI::EasyButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, EasyButton) == 0x0003D8, "Member 'UCrabDifficultyMenuUI::EasyButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, EasyChallengeLevelOverlay) == 0x0003E0, "Member 'UCrabDifficultyMenuUI::EasyChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NormalButtonOverlay) == 0x0003E8, "Member 'UCrabDifficultyMenuUI::NormalButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NormalButton) == 0x0003F0, "Member 'UCrabDifficultyMenuUI::NormalButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NormalChallengeLevelOverlay) == 0x0003F8, "Member 'UCrabDifficultyMenuUI::NormalChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NightmareButtonOverlay) == 0x000400, "Member 'UCrabDifficultyMenuUI::NightmareButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NightmareButton) == 0x000408, "Member 'UCrabDifficultyMenuUI::NightmareButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, NightmareChallengeLevelOverlay) == 0x000410, "Member 'UCrabDifficultyMenuUI::NightmareChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosHorizontalBox) == 0x000418, "Member 'UCrabDifficultyMenuUI::UltraChaosHorizontalBox' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosButtonOverlay) == 0x000420, "Member 'UCrabDifficultyMenuUI::UltraChaosButtonOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosButton) == 0x000428, "Member 'UCrabDifficultyMenuUI::UltraChaosButton' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, UltraChaosChallengeLevelOverlay) == 0x000430, "Member 'UCrabDifficultyMenuUI::UltraChaosChallengeLevelOverlay' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, ChallengeLevelText) == 0x000438, "Member 'UCrabDifficultyMenuUI::ChallengeLevelText' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, DifficultyModifiersVerticalBox) == 0x000440, "Member 'UCrabDifficultyMenuUI::DifficultyModifiersVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabDifficultyMenuUI, DifficultyModifierUIToSpawn) == 0x000448, "Member 'UCrabDifficultyMenuUI::DifficultyModifierUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabMinigameGameOverUI
// 0x0030 (0x0400 - 0x03D0)
class UCrabMinigameGameOverUI : public UCrabFocusMenuUI
{
public:
	class UTextBlock*                             MinigameNameText;                                  // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        MinigameGameOverWidgetSwitcher;                    // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ScoreText;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HighScoreText;                                     // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           MinigameGameOverRowUIVerticalBox;                  // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabMinigameGameOverRowUI> MinigameGameOverRowUIToSpawn;                      // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMinigameGameOverUI">();
	}
	static class UCrabMinigameGameOverUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMinigameGameOverUI>();
	}
};
static_assert(alignof(UCrabMinigameGameOverUI) == 0x000008, "Wrong alignment on UCrabMinigameGameOverUI");
static_assert(sizeof(UCrabMinigameGameOverUI) == 0x000400, "Wrong size on UCrabMinigameGameOverUI");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameNameText) == 0x0003D0, "Member 'UCrabMinigameGameOverUI::MinigameNameText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameGameOverWidgetSwitcher) == 0x0003D8, "Member 'UCrabMinigameGameOverUI::MinigameGameOverWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, ScoreText) == 0x0003E0, "Member 'UCrabMinigameGameOverUI::ScoreText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, HighScoreText) == 0x0003E8, "Member 'UCrabMinigameGameOverUI::HighScoreText' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameGameOverRowUIVerticalBox) == 0x0003F0, "Member 'UCrabMinigameGameOverUI::MinigameGameOverRowUIVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabMinigameGameOverUI, MinigameGameOverRowUIToSpawn) == 0x0003F8, "Member 'UCrabMinigameGameOverUI::MinigameGameOverRowUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabMultiplayerMenuUI
// 0x0038 (0x0408 - 0x03D0)
class UCrabMultiplayerMenuUI : public UCrabFocusMenuUI
{
public:
	class UCrabArrowSelectionUI*                  QuickplayDifficultyAS;                             // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuickplayButton;                                   // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             QuickplayButtonText;                               // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             FriendsScrollBox;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabInviteFriendRowUI>     InviteFriendRowUIToSpawn;                          // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           JoinedPlayersVerticalBox;                          // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrabJoinedPlayerRowUI>     JoinedPlayerRowUIToSpawn;                          // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredQuickplayButton();
	void OnPressedQuickplayButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabMultiplayerMenuUI">();
	}
	static class UCrabMultiplayerMenuUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabMultiplayerMenuUI>();
	}
};
static_assert(alignof(UCrabMultiplayerMenuUI) == 0x000008, "Wrong alignment on UCrabMultiplayerMenuUI");
static_assert(sizeof(UCrabMultiplayerMenuUI) == 0x000408, "Wrong size on UCrabMultiplayerMenuUI");
static_assert(offsetof(UCrabMultiplayerMenuUI, QuickplayDifficultyAS) == 0x0003D0, "Member 'UCrabMultiplayerMenuUI::QuickplayDifficultyAS' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, QuickplayButton) == 0x0003D8, "Member 'UCrabMultiplayerMenuUI::QuickplayButton' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, QuickplayButtonText) == 0x0003E0, "Member 'UCrabMultiplayerMenuUI::QuickplayButtonText' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, FriendsScrollBox) == 0x0003E8, "Member 'UCrabMultiplayerMenuUI::FriendsScrollBox' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, InviteFriendRowUIToSpawn) == 0x0003F0, "Member 'UCrabMultiplayerMenuUI::InviteFriendRowUIToSpawn' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, JoinedPlayersVerticalBox) == 0x0003F8, "Member 'UCrabMultiplayerMenuUI::JoinedPlayersVerticalBox' has a wrong offset!");
static_assert(offsetof(UCrabMultiplayerMenuUI, JoinedPlayerRowUIToSpawn) == 0x000400, "Member 'UCrabMultiplayerMenuUI::JoinedPlayerRowUIToSpawn' has a wrong offset!");

// Class CrabChampions.CrabPortalInteractUI
// 0x0068 (0x03C0 - 0x0358)
class UCrabPortalInteractUI : public UCrabInteractUI
{
public:
	class UBorder*                                ChallengeBorder;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeNameText;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChallengeDescriptionText;                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                AdditionalChallengeBorder;                         // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeNameText;                       // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalChallengeDescriptionText;                // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                BlessingBorder;                                    // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingNameText;                                  // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BlessingDescriptionText;                           // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                RewardBorder;                                      // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DoubleRewardText;                                  // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RewardNameText;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RewardDescriptionText;                             // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabPortalInteractUI">();
	}
	static class UCrabPortalInteractUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabPortalInteractUI>();
	}
};
static_assert(alignof(UCrabPortalInteractUI) == 0x000008, "Wrong alignment on UCrabPortalInteractUI");
static_assert(sizeof(UCrabPortalInteractUI) == 0x0003C0, "Wrong size on UCrabPortalInteractUI");
static_assert(offsetof(UCrabPortalInteractUI, ChallengeBorder) == 0x000358, "Member 'UCrabPortalInteractUI::ChallengeBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, ChallengeNameText) == 0x000360, "Member 'UCrabPortalInteractUI::ChallengeNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, ChallengeDescriptionText) == 0x000368, "Member 'UCrabPortalInteractUI::ChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, AdditionalChallengeBorder) == 0x000370, "Member 'UCrabPortalInteractUI::AdditionalChallengeBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, AdditionalChallengeNameText) == 0x000378, "Member 'UCrabPortalInteractUI::AdditionalChallengeNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, AdditionalChallengeDescriptionText) == 0x000380, "Member 'UCrabPortalInteractUI::AdditionalChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, BlessingBorder) == 0x000388, "Member 'UCrabPortalInteractUI::BlessingBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, BlessingNameText) == 0x000390, "Member 'UCrabPortalInteractUI::BlessingNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, BlessingDescriptionText) == 0x000398, "Member 'UCrabPortalInteractUI::BlessingDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, RewardBorder) == 0x0003A0, "Member 'UCrabPortalInteractUI::RewardBorder' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, DoubleRewardText) == 0x0003A8, "Member 'UCrabPortalInteractUI::DoubleRewardText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, RewardNameText) == 0x0003B0, "Member 'UCrabPortalInteractUI::RewardNameText' has a wrong offset!");
static_assert(offsetof(UCrabPortalInteractUI, RewardDescriptionText) == 0x0003B8, "Member 'UCrabPortalInteractUI::RewardDescriptionText' has a wrong offset!");

// Class CrabChampions.CrabInventoryEventUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabInventoryEventUI : public UCrabUI
{
public:
	class UTextBlock*                             InventoryEventMessageText;                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       InventoryEventAnim;                                // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventoryEventUI">();
	}
	static class UCrabInventoryEventUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventoryEventUI>();
	}
};
static_assert(alignof(UCrabInventoryEventUI) == 0x000008, "Wrong alignment on UCrabInventoryEventUI");
static_assert(sizeof(UCrabInventoryEventUI) == 0x0002C8, "Wrong size on UCrabInventoryEventUI");
static_assert(offsetof(UCrabInventoryEventUI, InventoryEventMessageText) == 0x0002B8, "Member 'UCrabInventoryEventUI::InventoryEventMessageText' has a wrong offset!");
static_assert(offsetof(UCrabInventoryEventUI, InventoryEventAnim) == 0x0002C0, "Member 'UCrabInventoryEventUI::InventoryEventAnim' has a wrong offset!");

// Class CrabChampions.CrabInventorySlotUI
// 0x0068 (0x0320 - 0x02B8)
class UCrabInventorySlotUI : public UCrabUI
{
public:
	class UCrabInventoryUI*                       OwningInventoryUI;                                 // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCrabInventoryDA*                       InventoryDA;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCrabInventoryInfo                     InventoryInfo;                                     // 0x02C8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBorder*                                SlotBorder;                                        // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                SlotButton;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotLockedImage;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FD[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 SlotIconImage;                                     // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SlotLevelText;                                     // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SlotEnhanceableIconImage;                          // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHoveredSlotButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInventorySlotUI">();
	}
	static class UCrabInventorySlotUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInventorySlotUI>();
	}
};
static_assert(alignof(UCrabInventorySlotUI) == 0x000008, "Wrong alignment on UCrabInventorySlotUI");
static_assert(sizeof(UCrabInventorySlotUI) == 0x000320, "Wrong size on UCrabInventorySlotUI");
static_assert(offsetof(UCrabInventorySlotUI, OwningInventoryUI) == 0x0002B8, "Member 'UCrabInventorySlotUI::OwningInventoryUI' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, InventoryDA) == 0x0002C0, "Member 'UCrabInventorySlotUI::InventoryDA' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, InventoryInfo) == 0x0002C8, "Member 'UCrabInventorySlotUI::InventoryInfo' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotBorder) == 0x0002E8, "Member 'UCrabInventorySlotUI::SlotBorder' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotButton) == 0x0002F0, "Member 'UCrabInventorySlotUI::SlotButton' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotLockedImage) == 0x0002F8, "Member 'UCrabInventorySlotUI::SlotLockedImage' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotIconImage) == 0x000308, "Member 'UCrabInventorySlotUI::SlotIconImage' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotLevelText) == 0x000310, "Member 'UCrabInventorySlotUI::SlotLevelText' has a wrong offset!");
static_assert(offsetof(UCrabInventorySlotUI, SlotEnhanceableIconImage) == 0x000318, "Member 'UCrabInventorySlotUI::SlotEnhanceableIconImage' has a wrong offset!");

// Class CrabChampions.CrabInviteFriendRowUI
// 0x0030 (0x02E8 - 0x02B8)
class UCrabInviteFriendRowUI : public UCrabUI
{
public:
	class UTextBlock*                             FriendNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FE[0x10];                                    // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                InviteButton;                                      // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InviteButtonText;                                  // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14FF[0x8];                                     // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHoveredInviteButton();
	void OnPressedInviteButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabInviteFriendRowUI">();
	}
	static class UCrabInviteFriendRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabInviteFriendRowUI>();
	}
};
static_assert(alignof(UCrabInviteFriendRowUI) == 0x000008, "Wrong alignment on UCrabInviteFriendRowUI");
static_assert(sizeof(UCrabInviteFriendRowUI) == 0x0002E8, "Wrong size on UCrabInviteFriendRowUI");
static_assert(offsetof(UCrabInviteFriendRowUI, FriendNameText) == 0x0002B8, "Member 'UCrabInviteFriendRowUI::FriendNameText' has a wrong offset!");
static_assert(offsetof(UCrabInviteFriendRowUI, InviteButton) == 0x0002D0, "Member 'UCrabInviteFriendRowUI::InviteButton' has a wrong offset!");
static_assert(offsetof(UCrabInviteFriendRowUI, InviteButtonText) == 0x0002D8, "Member 'UCrabInviteFriendRowUI::InviteButtonText' has a wrong offset!");

// Class CrabChampions.CrabJoinedPlayerRowUI
// 0x0010 (0x02C8 - 0x02B8)
class UCrabJoinedPlayerRowUI : public UCrabUI
{
public:
	class UTextBlock*                             PlayerNameText;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerPingText;                                    // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabJoinedPlayerRowUI">();
	}
	static class UCrabJoinedPlayerRowUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabJoinedPlayerRowUI>();
	}
};
static_assert(alignof(UCrabJoinedPlayerRowUI) == 0x000008, "Wrong alignment on UCrabJoinedPlayerRowUI");
static_assert(sizeof(UCrabJoinedPlayerRowUI) == 0x0002C8, "Wrong size on UCrabJoinedPlayerRowUI");
static_assert(offsetof(UCrabJoinedPlayerRowUI, PlayerNameText) == 0x0002B8, "Member 'UCrabJoinedPlayerRowUI::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UCrabJoinedPlayerRowUI, PlayerPingText) == 0x0002C0, "Member 'UCrabJoinedPlayerRowUI::PlayerPingText' has a wrong offset!");

// Class CrabChampions.CrabUnlockedCosmeticUI
// 0x0028 (0x02E0 - 0x02B8)
class UCrabUnlockedCosmeticUI : public UCrabUI
{
public:
	class UTextBlock*                             ChallengeDescriptionText;                          // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticTypeText;                                  // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CosmeticNameText;                                  // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CosmeticIconImage;                                 // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UnlockedAnim;                                      // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrabUnlockedCosmeticUI">();
	}
	static class UCrabUnlockedCosmeticUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrabUnlockedCosmeticUI>();
	}
};
static_assert(alignof(UCrabUnlockedCosmeticUI) == 0x000008, "Wrong alignment on UCrabUnlockedCosmeticUI");
static_assert(sizeof(UCrabUnlockedCosmeticUI) == 0x0002E0, "Wrong size on UCrabUnlockedCosmeticUI");
static_assert(offsetof(UCrabUnlockedCosmeticUI, ChallengeDescriptionText) == 0x0002B8, "Member 'UCrabUnlockedCosmeticUI::ChallengeDescriptionText' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, CosmeticTypeText) == 0x0002C0, "Member 'UCrabUnlockedCosmeticUI::CosmeticTypeText' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, CosmeticNameText) == 0x0002C8, "Member 'UCrabUnlockedCosmeticUI::CosmeticNameText' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, CosmeticIconImage) == 0x0002D0, "Member 'UCrabUnlockedCosmeticUI::CosmeticIconImage' has a wrong offset!");
static_assert(offsetof(UCrabUnlockedCosmeticUI, UnlockedAnim) == 0x0002D8, "Member 'UCrabUnlockedCosmeticUI::UnlockedAnim' has a wrong offset!");

}

